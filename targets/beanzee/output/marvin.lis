marvin.asm:
     1                              INCLUDE "asm/main.inc"
../asm/main.inc:
     1                          IFNDEF _MAIN_INC
     2                          DEFINE _MAIN_INC
     3                          
     4                          ; start of user RAM
     5                          RAMSTART equ 0x8000
     6                          
     7                          ; 8-byte status area
     8                          CONSOLE_STATUS equ 0xf000
     9                          ; 8-byte keyscan buffer
    10                          KEY_MATRIX_BUFFER equ 0xf010
    11                          ; command buffer
    12                          CMD_BUFFER equ 0xf020
    13                          ; this should really be 0x0000 as the CPU will dec SP before PUSH
    14                          STACK equ 0xffff
    15                          
    16                          UM245R_CTRL equ 0 ; serial control port
    17                          UM245R_DATA equ 1 ; serial data port
    18                          KEYSCAN_OUT equ 2 ; either 2 or 3 will work
    19                          KEYSCAN_IN  equ 3 ; either 2 or 3 will work
    20                          LCD_CTRL    equ 4 ; LCD control port
    21                          LCD_DATA    equ 5 ; LCD data port
    22                          GPIO_OUT    equ 6 ; either 6 or 7 will work
    23                          GPIO_IN     equ 7 ; either 6 or 7 will work
    24                          
    25                          CONSOLE_STATUS_USB equ 1
    26                          CONSOLE_STATUS_BEANBOARD equ 2
    27                          
    28                          ENDIF
    29                          
marvin.asm:
     2                              INCLUDE "asm/escapestring.inc"
../asm/escapestring.inc:
     1                          IFNDEF _ESCAPESTRING_INC
     2                          DEFINE _ESCAPESTRING_INC
     3                          
     4                          ; escape character constants for assembler compatibility
     5                          ; sjasmplus requires double quotes around escape sequences: "\n" and would not interpret '\n' but truncate
     6                          ; z88dk-z80asm requires single quotes around so would correctly interpret '\n' but reject "\n"
     7                          
     8                          ESC_B equ 0x08 ; \b
     9                          ESC_T equ 0x09 ; \t
    10                          ESC_N equ 0x0a ; \n
    11                          ESC_R equ 0x0d ; \r
    12                          ESC_E equ 0x1b ; \e
    13                          SLASH equ 0x5c ; \\
    14                          QUOTE equ 0x27 ; \'
    15                          
    16                          ENDIF
    17                          
marvin.asm:
     3                          
     4                              PUBLIC MARVIN
     5                              PUBLIC PROMPT
     6                          
     7                          IFDEF MODULAR
     8                              EXTERN puts
     9                              EXTERN putchar
    10                              EXTERN getchar
    11                              EXTERN hex_byte_val
    12                              EXTERN putchar_hex
    13                              EXTERN WELCOME_MSG
    14                              EXTERN BAD_CMD_MSG
    15                              EXTERN CMD_W_NULL_MSG
    16                          ENDIF
    17                          
    18                          ; ****************************************************
    19                          ; *  Marvin - a Z80 homebrew monitor program
    20                          ; * (c) Stephen Willcock 2024
    21                          ; * https://github.com/PainfulDiodes
    22                          ; ****************************************************
    23                          
    24                          ; MAIN PROGRAM LOOP
    25                          
    26                          MARVIN:
    27                              ; point DE to zero - this is the default address argument for commands
    28  0000  110000                ld de,0x0000
    29                          
    30  0003  210000                ld hl,WELCOME_MSG
    31  0006  cd0000                call puts
    32                          
    33                          PROMPT:
    34                              ; point HL to the beginning of the input buffer
    35  0009  2120f0                ld hl,CMD_BUFFER
    36  000c  3e3e                  ld a,'>'
    37  000e  cd0000                call putchar
    38                          
    39                          _get_cmd:
    40                              ; get character from console
    41  0011  cd0000                call getchar
    42                              ; echo the character to console
    43  0014  cd0000                call putchar
    44                              ; is CR?
    45  0017  fe0d                  cp ESC_R
    46                              ; yes: skip this
    47  0019  28f6                  jr z,_get_cmd
    48                              ; is tab?
    49  001b  fe09                  cp ESC_T
    50                              ; yes: skip this
    51  001d  28f2                  jr z,_get_cmd
    52                              ; is space?
    53  001f  fe20                  cp ' '
    54                              ; yes - skip this
    55  0021  28ee                  jr z,_get_cmd
    56                              ; escape?
    57  0023  fe1b                  cp ESC_E
    58                              ; yes
    59  0025  2808                  jr z, _get_cmd_esc
    60                              ; end of line?
    61  0027  fe0a                  cp ESC_N
    62                              ; yes
    63  0029  280b                  jr z, _get_cmd_end
    64                              ; no: add character to the buffer
    65  002b  77                    ld(hl),a
    66                              ; move pointer to next buffer location - we're not checking for overrun
    67  002c  23                    inc hl
    68                              ; next character
    69  002d  18e2                  jr _get_cmd
    70                              ; do escape
    71                          _get_cmd_esc:
    72                              ; new line
    73  002f  3e0a                  ld a,ESC_N
    74  0031  cd0000                call putchar
    75                              ; back to prompt
    76  0034  18d3                  jr PROMPT
    77                          _get_cmd_end:
    78                              ; string terminator
    79  0036  3e00                  ld a,0
    80                              ; add terminator to end of buffer
    81  0038  77                    ld(hl),a
    82                          ; process command from buffer
    83                              ; point to start of buffer
    84  0039  2120f0                ld hl,CMD_BUFFER
    85                              ; load character from buffer
    86  003c  7e                    ld a,(hl)
    87                              ; end of string?
    88  003d  fe00                  cp 0
    89                              ; yes - empty line - go back to prompt
    90  003f  28c8                  jr z,PROMPT
    91                              ; advance the buffer pointer
    92  0041  23                    inc hl
    93  0042  fe72                  cp 'r'
    94  0044  2815                  jr z,_cmd_read
    95  0046  fe77                  cp 'w'
    96  0048  2847                  jr z,_cmd_write
    97  004a  fe78                  cp 'x'
    98  004c  2868                  jr z,_cmd_execute
    99                              ; ':' = load from intel hex format
   100  004e  fe3a                  cp ':'
   101  0050  2879                  jr z,_cmd_load
   102                              ; otherwise error
   103  0052  210000                ld hl,BAD_CMD_MSG
   104  0055  cd0000                call puts
   105                              ; loop back to the prompt
   106  0058  c30900                jp PROMPT
   107                          
   108                          ; COMMANDS
   109                          
   110                          ; READ
   111                          ; read bytes from memory and send hex values to console
   112                          _cmd_read:
   113                              ; load character from buffer
   114  005b  7e                    ld a,(hl)
   115                              ; end of string?
   116  005c  fe00                  cp 0
   117                              ; yes: no address argument, so skip to read row
   118  005e  2808                  jr z, _cmd_read_row
   119                              ; parse first pair of characters
   120  0060  cd0000                call hex_byte_val
   121                              ; load into upper byte of memory pointer
   122  0063  57                    ld d,a
   123                              ; parse second pair of characters
   124  0064  cd0000                call hex_byte_val
   125                              ; load into lower byte of memory pointer
   126  0067  5f                    ld e,a
   127                          _cmd_read_row:
   128                              ; initialise byte counter - each row will have this many bytes
   129  0068  0e10                  ld c, 0x10
   130                              ; print DE content: the read address
   131  006a  7a                    ld a,d
   132  006b  cd0000                call putchar_hex
   133  006e  7b                    ld a,e
   134  006f  cd0000                call putchar_hex
   135                              ; separator between address and data
   136  0072  3e3a                  ld a,':'
   137  0074  cd0000                call putchar
   138  0077  3e20                  ld a,' '
   139  0079  cd0000                call putchar
   140                              ; get a byte
   141                          _cmd_read_byte:
   142  007c  1a                    ld a,(de)
   143                              ; and print it
   144  007d  cd0000                call putchar_hex
   145                              ; add space between bytes
   146  0080  3e20                  ld a,' '
   147  0082  cd0000                call putchar
   148                              ; next address
   149  0085  13                    inc de
   150                              ; reduce byte counter
   151                              ; TODO djnz ?
   152  0086  0d                    dec c
   153                              ; repeat if the counter is not 0
   154  0087  20f3                  jr nz, _cmd_read_byte
   155                              ; otherwise, new line
   156  0089  3e0a                  ld a,ESC_N
   157  008b  cd0000                call putchar
   158                              ; and back to prompt
   159  008e  c30900                jp PROMPT
   160                          
   161                          ; WRITE
   162                          
   163                          ; write bytes to memory interpreting hex values from console
   164                          _cmd_write:
   165                              ; load character from buffer
   166  0091  7e                    ld a,(hl)
   167                              ; end of string?
   168  0092  fe00                  cp 0
   169                              ; yes: no data
   170  0094  2817                  jr z, _cmd_write_null
   171                              ; parse first pair of characters - address high
   172  0096  cd0000                call hex_byte_val
   173                              ; load into upper byte of memory pointer
   174  0099  57                    ld d,a
   175                              ; parse second pair of characters - address low
   176  009a  cd0000                call hex_byte_val
   177                              ; load into lower byte of memory pointer
   178  009d  5f                    ld e,a
   179                          _cmd_write_data:
   180                              ; load character from buffer
   181  009e  7e                    ld a,(hl)
   182                              ; end of string?
   183  009f  fe00                  cp 0
   184                              ; yes: we're done
   185  00a1  2807                  jr z, _cmd_write_end
   186                              ; parse data byte
   187  00a3  cd0000                call hex_byte_val
   188                              ; write byte to memory
   189  00a6  12                    ld (de),a
   190                              ; advance destination pointer
   191  00a7  13                    inc de
   192  00a8  18f4                  jr _cmd_write_data
   193                          _cmd_write_end:
   194  00aa  c30900                jp PROMPT
   195                              ; w with no data
   196                          _cmd_write_null:
   197  00ad  210000                ld hl,CMD_W_NULL_MSG
   198  00b0  cd0000                call puts
   199                              ; and back to prompt
   200  00b3  c30900                jp PROMPT
   201                          
   202                          ; EXECUTE
   203                          
   204                          ; start executing from given address
   205                          _cmd_execute:
   206                              ; load character from buffer
   207  00b6  7e                    ld a,(hl)
   208                              ; end of string?
   209  00b7  fe00                  cp 0
   210                              ; yes - no data
   211  00b9  cac700                jp z, _cmd_exec_df
   212                              ; parse first pair of characters - address high
   213  00bc  cd0000                call hex_byte_val
   214                              ; load into upper byte of memory pointer
   215  00bf  57                    ld d,a
   216                              ; parse second pair of characters - address low
   217  00c0  cd0000                call hex_byte_val
   218                              ; load into lower byte of memory pointer
   219  00c3  5f                    ld e,a
   220  00c4  626b                  ld hl,de
   221                              ; execute from address
   222  00c6  e9                    jp (hl)
   223                              ; start executing from default address
   224                          _cmd_exec_df:
   225  00c7  210080                ld hl,RAMSTART
   226                              ; execute from address
   227  00ca  e9                    jp (hl)
   228                          
   229                          ; LOAD
   230                          
   231                          ; load from INTEL HEX - records are read from the buffer
   232                          _cmd_load:
   233                              ; load character from buffer
   234  00cb  7e                    ld a,(hl)
   235                              ; end of string?
   236  00cc  fe00                  cp 0
   237                              ; yes: no data - quit
   238  00ce  caf700                jp z, _cmd_load_end
   239                              ; parse first pair of characters - byte count
   240  00d1  cd0000                call hex_byte_val
   241  00d4  fe00                  cp 0
   242                              ; yes - zero byte count - quit
   243  00d6  caf700                jp z, _cmd_load_end
   244                              ; load byte count into C
   245  00d9  4f                    ld c,a
   246                              ; parse address high
   247  00da  cd0000                call hex_byte_val
   248                              ; load into upper byte of memory pointer
   249  00dd  57                    ld d,a
   250                              ; parse address low
   251  00de  cd0000                call hex_byte_val
   252                              ; load into lower byte of memory pointer
   253  00e1  5f                    ld e,a
   254                              ; parse record type
   255  00e2  cd0000                call hex_byte_val
   256                              ; record type zero?
   257  00e5  fe00                  cp 0
   258                              ; no: quit
   259  00e7  c2f700                jp nz, _cmd_load_end
   260                          _cmd_load_data:
   261                              ; load character from buffer
   262  00ea  7e                    ld a,(hl)
   263                              ; end of string?
   264  00eb  fe00                  cp 0
   265                              ; yes: we're done
   266  00ed  2808                  jr z, _cmd_load_end
   267                              ; no:
   268                              ; parse data byte
   269  00ef  cd0000                call hex_byte_val
   270                              ; write byte to memory
   271  00f2  12                    ld (de),a
   272                              ; advance destination pointer
   273  00f3  13                    inc de
   274                              ; decrement byte counter
   275                              ; TODO djnz
   276  00f4  0d                    dec c
   277                              ; if byte counter not zero then go again
   278  00f5  20f3                  jr nz,_cmd_load_data
   279                          _cmd_load_end:
   280  00f7  c30900                jp PROMPT
   281                          
