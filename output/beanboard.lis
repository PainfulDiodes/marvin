beanboard.asm:
     1                          ; MARVIN build for BeanZee with BeanBoard
     2                          ; https://github.com/PainfulDiodes/BeanZee
     3                          ; https://github.com/PainfulDiodes/BeanBoard
     4                          
     5                          BEANBOARD EQU 1
     6                          
     7                          include "asm/main.inc"
asm/main.inc:
     1                          ; start of user RAM
     2                          RAMSTART equ 0x8000
     3                          
     4                          ; 8-byte status area
     5                          CONSOLE_STATUS equ 0xf000
     6                          ; 8-byte keyscan buffer
     7                          KEY_MATRIX_BUFFER equ 0xf010
     8                          ; command buffer
     9                          CMD_BUFFER equ 0xf020
    10                          ; this should really be 0x0000 as the CPU will dec SP before PUSH
    11                          STACK equ 0xffff
    12                          
    13                          UM245R_CTRL equ 0 ; serial control port
    14                          UM245R_DATA equ 1 ; serial data port
    15                          KEYSCAN_OUT equ 2 ; either 2 or 3 will work
    16                          KEYSCAN_IN  equ 3 ; either 2 or 3 will work
    17                          LCD_CTRL    equ 4 ; LCD control port
    18                          LCD_DATA    equ 5 ; LCD data port
    19                          GPIO_OUT    equ 6 ; either 6 or 7 will work
    20                          GPIO_IN     equ 7 ; either 6 or 7 will work
    21                          
    22                          CONSOLE_STATUS_USB equ 1
    23                          CONSOLE_STATUS_BEANBOARD equ 2
    24                          
beanboard.asm:
     8                          include "asm/escapestring.inc"
asm/escapestring.inc:
     1                          ; escape character constants for assembler compatibility
     2                          ; sjasmplus requires double quotes around escape sequences: "\n" and would not interpret '\n' but truncate
     3                          ; z88dk-z80asm requires single quotes around so would correctly interpret '\n' but reject "\n"
     4                          
     5                          ESC_B equ 0x08 ; \b
     6                          ESC_T equ 0x09 ; \t
     7                          ESC_N equ 0x0a ; \n
     8                          ESC_R equ 0x0d ; \r
     9                          ESC_E equ 0x1b ; \e
    10                          SLASH equ 0x5c ; \\
    11                          QUOTE equ 0x27 ; \'
    12                          
beanboard.asm:
     9                          include "asm/HD44780LCD.inc"
asm/HD44780LCD.inc:
     1                          ; LCD commands
     2                          LCD_CLEAR_DISPLAY equ 0x01
     3                          LCD_RETURN_HOME equ 0x02
     4                          LCD_ENTRY_MODE_SET equ 0x04
     5                          LCD_DISPLAY_ON_OFF_CONTROL equ 0x08
     6                          LCD_CURSOR_DISPLAY_SHIFT equ 0x10
     7                          LCD_FUNCTION_SET equ 0x20
     8                          LCD_SET_CGRAM_ADDR equ 0x40
     9                          LCD_SET_DDRAM_ADDR equ 0x80
    10                          
    11                          ; LCD_ENTRY_MODE_SET options
    12                          LCD_ENTRY_INC equ 0x02 ; left
    13                          LCD_ENTRY_DEC equ 0x00 ; right
    14                          LCD_ENTRY_SHIFT equ 0x01
    15                          LCD_ENTRY_NO_SHIFT equ 0x00
    16                          
    17                          ; LCD_DISPLAY_ON_OFF_CONTROL options
    18                          LCD_DISPLAY_ON equ 0x04
    19                          LCD_DISPLAY_OFF equ 0x00
    20                          LCD_CURSOR_ON equ 0x02
    21                          LCD_CURSOR_OFF equ 0x00
    22                          LCD_BLINK_ON equ 0x01
    23                          LCD_BLINK_OFF equ 0x00
    24                          
    25                          ; LCD_CURSOR_DISPLAY_SHIFT options
    26                          LCD_SHIFT_DISPLAY equ 0x08
    27                          LCD_SHIFT_CURSOR equ 0x00
    28                          LCD_SHIFT_RIGHT equ 0x04
    29                          LCD_SHIFT_LEFT equ 0x00
    30                          
    31                          ; LCD_FUNCTION_SET options
    32                          LCD_DATA_LEN_8 equ 0x10
    33                          LCD_DATA_LEN_4 equ 0x00
    34                          LCD_DISP_LINES_2 equ 0x08
    35                          LCD_DISP_LINES_1 equ 0x00
    36                          LCD_FONT_10 equ 0x04
    37                          LCD_FONT_8 equ 0x00
    38                          
    39                          LCD_LINE_LEN equ 0x14
    40                          LCD_NUM_LINES equ 4
    41                          LCD_BUFFER_LEN equ LCD_LINE_LEN*LCD_NUM_LINES
    42                          
    43                          ; LCD_SET_DDRAM_ADDR options
    44                          LCD_LINE_0_ADDR equ 0x00
    45                          LCD_LINE_1_ADDR equ 0x40
    46                          LCD_LINE_2_ADDR equ 0x00+LCD_LINE_LEN
    47                          LCD_LINE_3_ADDR equ 0x40+LCD_LINE_LEN
    48                          LCD_EOL_0 equ 0x00+LCD_LINE_LEN-1
    49                          LCD_EOL_1 equ 0x40+LCD_LINE_LEN-1
    50                          LCD_EOL_2 equ 0x00+LCD_LINE_LEN*2-1
    51                          LCD_EOL_3 equ 0x40+LCD_LINE_LEN*2-1
    52                          
beanboard.asm:
    10                          include "asm/main.asm"
asm/main.asm:
     1                          ORG MARVINORG
     2  0000  31ffff                ld sp, STACK
     3                          IF BEANBOARD
     4  0003  cd0b02                call lcd_init
     5  0006  cd6400                call beanboard_console_init
     6                          ENDIF
     7  0009  00000000000000    ALIGN 0x0010 ; fix the warmstart address across targets
     8                          WARMSTART:
     9  0010  c3b600                jp MARVIN
    10                          
beanboard.asm:
    11                          include "asm/console.asm"
asm/console.asm:
     1                          ; wait for a character and return in A
     2                          getchar:
     3  0013  cd1b00                call readchar
     4  0016  fe00                  cp 0
     5  0018  c0                    ret nz
     6  0019  18f8                  jr getchar
     7                          
     8                          IF BEANBOARD
     9                          ; read a character from the console and return in A - return 0 if there is no character
    10                          readchar:
    11  001b  e5                    push hl
    12  001c  2100f0                ld hl,CONSOLE_STATUS
    13  001f  3e02                  ld a,CONSOLE_STATUS_BEANBOARD
    14  0021  a6                    and (hl)
    15  0022  2007                  jr nz,_readchar_beanboard
    16  0024  3e01                  ld a,CONSOLE_STATUS_USB
    17  0026  a6                    and (hl)
    18  0027  2007                  jr nz,_readchar_usb
    19  0029  1808                  jr _readchar_end
    20                          _readchar_beanboard:
    21  002b  cdf502                call key_readchar
    22  002e  1803                  jr _readchar_end
    23                          _readchar_usb:
    24  0030  cd7a00                call usb_readchar
    25                          _readchar_end:
    26  0033  e1                    pop hl
    27  0034  c9                    ret
    28                          ELSE
    29                          ; read a character from the console and return in A - return 0 if there is no character
    30                          readchar:
    31                              call usb_readchar
    32                              ret
    33                          ENDIF
    34                          
    35                          IF BEANBOARD
    36                          ; sent character in A to the console
    37                          putchar:
    38  0035  e5                    push hl
    39  0036  c5                    push bc
    40  0037  47                    ld b,a
    41  0038  2100f0                ld hl,CONSOLE_STATUS
    42  003b  3e02                  ld a,CONSOLE_STATUS_BEANBOARD
    43  003d  a6                    and (hl)
    44  003e  2007                  jr nz,_putchar_beanboard
    45  0040  3e01                  ld a,CONSOLE_STATUS_USB
    46  0042  a6                    and (hl)
    47  0043  2008                  jr nz,_putchar_usb
    48  0045  180a                  jr _putchar_end
    49                          _putchar_beanboard:
    50  0047  78                    ld a,b
    51  0048  cd3802                call lcd_putchar
    52  004b  1804                  jr _putchar_end
    53                          _putchar_usb:
    54  004d  78                    ld a,b
    55  004e  cd8b00                call usb_putchar
    56                          _putchar_end:
    57  0051  78                    ld a,b
    58  0052  c1                    pop bc
    59  0053  e1                    pop hl
    60  0054  c9                    ret
    61                          ELSE
    62                          ; sent character in A to the console
    63                          putchar:
    64                              push bc
    65                              ld b,a
    66                              call usb_putchar
    67                              ld a,b
    68                              pop bc
    69                              ret
    70                          ENDIF
    71                          
    72                          ; print a zero-terminated string pointed to by hl to the console
    73                          puts:
    74  0055  e5                    push hl
    75                          _puts_loop:
    76                              ; get character from string
    77  0056  7e                    ld a,(hl)
    78                              ; is it zero?
    79  0057  fe00                  cp 0
    80                              ; yes
    81  0059  2807                  jr z, _puts_end
    82                              ; no: send character
    83  005b  cd3500                call putchar
    84                              ; next character position
    85  005e  23                    inc hl
    86                              ; loop for next character
    87  005f  c35600                jp _puts_loop
    88                          _puts_end:
    89  0062  e1                    pop hl
    90  0063  c9                    ret
    91                          
    92                          IF BEANBOARD
    93                          ; determine which console should be active - Reset=beanboard, shift-Reset=USB
    94                          beanboard_console_init:
    95                              ; check for modifier keys being held down
    96  0064  cd4203                call modifierkeys
    97                              ; shift key down?
    98  0067  e601                  and MOD_KEY_SHIFT
    99                              ; yes shift
   100  0069  c27300                jp nz,_beanboard_console_init_usb
   101                              ; no shift
   102  006c  3e02                  ld a,CONSOLE_STATUS_BEANBOARD
   103  006e  2100f0                ld hl,CONSOLE_STATUS
   104  0071  77                    ld (hl),a
   105  0072  c9                    ret
   106                          _beanboard_console_init_usb:
   107  0073  3e01                  ld a,CONSOLE_STATUS_USB
   108  0075  2100f0                ld hl,CONSOLE_STATUS
   109  0078  77                    ld (hl),a
   110  0079  c9                    ret
   111                          ENDIF
   112                          
beanboard.asm:
    12                          include "asm/UM245R.asm"
asm/UM245R.asm:
     1                          ; It is assumed that UM245R status signals are gated to the data bus as an IO port where:
     2                          ; /TXE = bit 0
     3                          ; /RXF = bit 1
     4                          ; As per:
     5                          ; https://github.com/PainfulDiodes/z80-breadboard-computer
     6                          ;
     7                          ; line endings are translated:
     8                          ; incoming line endings from the terminal are expected to be \r
     9                          ; and are tranlslated to \n
    10                          ; (\r\n would count as 2 line endings)
    11                          ; and outgoing line endings are sent as \r\n
    12                          ; externally this is consistent with VT100/ANSI terminal behaviour
    13                          ; and internally line endings are always \n
    14                          
    15                          ; get character and return in A
    16                          usb_readchar:
    17                              ; get the USB status
    18  007a  db00                  in a,(UM245R_CTRL)
    19                              ; data to read? (active low)
    20  007c  cb4f                  bit 1,a
    21                              ; no, the buffer is empty
    22  007e  2008                  jr nz,_usb_no_char
    23                              ; yes, read the received char
    24  0080  db01                  in a,(UM245R_DATA)
    25                              ; is CR?
    26  0082  fe0d                  cp ESC_R
    27                              ; no:
    28  0084  c0                    ret nz
    29                              ; yes: convert CR to LF
    30  0085  3e0a                  ld a, ESC_N
    31  0087  c9                    ret
    32                          _usb_no_char:
    33  0088  3e00                  ld a,0
    34  008a  c9                    ret
    35                          
    36                          usb_putchar:
    37                              ; newline?
    38  008b  fe0a                  cp ESC_N
    39                              ; no: just send the char
    40  008d  2007                  jr nz,_do_usb_put
    41  008f  3e0d                  ld a, ESC_R
    42  0091  cd9a00                call _usb_put
    43  0094  3e0a                  ld a, ESC_N
    44                          _do_usb_put:
    45  0096  cd9a00                call _usb_put
    46  0099  c9                    ret
    47                          
    48                          ; transmit character in A
    49                          _usb_put:
    50  009a  c5                    push bc
    51                              ; stash the transmit character
    52  009b  47                    ld b,a
    53                          _usb_put_loop:
    54                              ; get the USB status
    55  009c  db00                  in a,(UM245R_CTRL)
    56                              ; ready to transmit? (active low)
    57  009e  cb47                  bit 0,a
    58                              ; no: bit is high
    59  00a0  20fa                  jr nz,_usb_put_loop
    60                              ; yes: restore the stashed transmit character
    61  00a2  78                    ld a,b
    62                              ; transmit the character
    63  00a3  d301                  out (UM245R_DATA),a
    64  00a5  c1                    pop bc
    65  00a6  c9                    ret
    66                          
    67                          ; print a zero-terminated string pointed to by hl to the USB
    68                          usb_puts:
    69  00a7  e5                    push hl
    70                          _usb_puts_loop:
    71                              ; get character from string
    72  00a8  7e                    ld a,(hl)
    73                              ; is it zero?
    74  00a9  fe00                  cp 0
    75                              ; yes
    76  00ab  2807                  jr z, _usb_puts_end
    77                              ; no: send character
    78  00ad  cd8b00                call usb_putchar
    79                              ; next character position
    80  00b0  23                    inc hl
    81                              ; loop for next character
    82  00b1  c3a800                jp _usb_puts_loop
    83                          _usb_puts_end:
    84  00b4  e1                    pop hl
    85  00b5  c9                    ret
    86                          
    87                          
beanboard.asm:
    13                          include "asm/marvin.asm"
asm/marvin.asm:
     1                          ; ****************************************************
     2                          ; *  Marvin - a Z80 homebrew monitor program
     3                          ; * (c) Stephen Willcock 2024
     4                          ; * https://github.com/PainfulDiodes
     5                          ; ****************************************************
     6                          
     7                          ; MAIN PROGRAM LOOP
     8                          
     9                          MARVIN:
    10                              ; point DE to zero - this is the default address argument for commands
    11  00b6  110000                ld de,0x0000
    12                          
    13  00b9  21e703                ld hl,WELCOME_MSG
    14  00bc  cd5500                call puts
    15                          
    16                          PROMPT:
    17                              ; point HL to the beginning of the input buffer
    18  00bf  2120f0                ld hl,CMD_BUFFER
    19  00c2  3e3e                  ld a,'>'
    20  00c4  cd3500                call putchar
    21                          
    22                          _get_cmd:
    23                              ; get character from console
    24  00c7  cd1300                call getchar
    25                              ; echo the character to console
    26  00ca  cd3500                call putchar
    27                              ; is CR?
    28  00cd  fe0d                  cp ESC_R
    29                              ; yes: skip this
    30  00cf  28f6                  jr z,_get_cmd
    31                              ; is tab?
    32  00d1  fe09                  cp ESC_T
    33                              ; yes: skip this
    34  00d3  28f2                  jr z,_get_cmd
    35                              ; is space?
    36  00d5  fe20                  cp ' '
    37                              ; yes - skip this
    38  00d7  28ee                  jr z,_get_cmd
    39                              ; escape?
    40  00d9  fe1b                  cp ESC_E
    41                              ; yes
    42  00db  2808                  jr z, _get_cmd_esc
    43                              ; end of line?
    44  00dd  fe0a                  cp ESC_N
    45                              ; yes
    46  00df  280b                  jr z, _get_cmd_end
    47                              ; no: add character to the buffer
    48  00e1  77                    ld(hl),a
    49                              ; move pointer to next buffer location - we're not checking for overrun
    50  00e2  23                    inc hl
    51                              ; next character
    52  00e3  18e2                  jr _get_cmd
    53                              ; do escape
    54                          _get_cmd_esc:
    55                              ; new line
    56  00e5  3e0a                  ld a,ESC_N
    57  00e7  cd3500                call putchar
    58                              ; back to prompt
    59  00ea  18d3                  jr PROMPT
    60                          _get_cmd_end:
    61                              ; string terminator
    62  00ec  3e00                  ld a,0
    63                              ; add terminator to end of buffer
    64  00ee  77                    ld(hl),a
    65                          ; process command from buffer
    66                              ; point to start of buffer
    67  00ef  2120f0                ld hl,CMD_BUFFER
    68                              ; load character from buffer
    69  00f2  7e                    ld a,(hl)
    70                              ; end of string?
    71  00f3  fe00                  cp 0
    72                              ; yes - empty line - go back to prompt
    73  00f5  28c8                  jr z,PROMPT
    74                              ; advance the buffer pointer
    75  00f7  23                    inc hl
    76  00f8  fe72                  cp 'r'
    77  00fa  2815                  jr z,_cmd_read
    78  00fc  fe77                  cp 'w'
    79  00fe  2847                  jr z,_cmd_write
    80  0100  fe78                  cp 'x'
    81  0102  2868                  jr z,_cmd_execute
    82                              ; ':' = load from intel hex format
    83  0104  fe3a                  cp ':'
    84  0106  2879                  jr z,_cmd_load
    85                              ; otherwise error
    86  0108  210e04                ld hl,BAD_CMD_MSG
    87  010b  cd5500                call puts
    88                              ; loop back to the prompt
    89  010e  c3bf00                jp PROMPT
    90                          
    91                          ; COMMANDS
    92                          
    93                          ; READ
    94                          ; read bytes from memory and send hex values to console
    95                          _cmd_read:
    96                              ; load character from buffer
    97  0111  7e                    ld a,(hl)
    98                              ; end of string?
    99  0112  fe00                  cp 0
   100                              ; yes: no address argument, so skip to read row
   101  0114  2808                  jr z, _cmd_read_row
   102                              ; parse first pair of characters
   103  0116  cdb001                call hex_byte_val
   104                              ; load into upper byte of memory pointer
   105  0119  57                    ld d,a
   106                              ; parse second pair of characters
   107  011a  cdb001                call hex_byte_val
   108                              ; load into lower byte of memory pointer
   109  011d  5f                    ld e,a
   110                          _cmd_read_row:
   111                              ; initialise byte counter - each row will have this many bytes
   112  011e  0e10                  ld c, 0x10
   113                              ; print DE content: the read address
   114  0120  7a                    ld a,d
   115  0121  cde401                call putchar_hex
   116  0124  7b                    ld a,e
   117  0125  cde401                call putchar_hex
   118                              ; separator between address and data
   119  0128  3e3a                  ld a,':'
   120  012a  cd3500                call putchar
   121  012d  3e20                  ld a,' '
   122  012f  cd3500                call putchar
   123                              ; get a byte
   124                          _cmd_read_byte:
   125  0132  1a                    ld a,(de)
   126                              ; and print it
   127  0133  cde401                call putchar_hex
   128                              ; add space between bytes
   129  0136  3e20                  ld a,' '
   130  0138  cd3500                call putchar
   131                              ; next address
   132  013b  13                    inc de
   133                              ; reduce byte counter
   134                              ; TODO djnz ?
   135  013c  0d                    dec c
   136                              ; repeat if the counter is not 0
   137  013d  20f3                  jr nz, _cmd_read_byte
   138                              ; otherwise, new line
   139  013f  3e0a                  ld a,ESC_N
   140  0141  cd3500                call putchar
   141                              ; and back to prompt
   142  0144  c3bf00                jp PROMPT
   143                          
   144                          ; WRITE
   145                          
   146                          ; write bytes to memory interpreting hex values from console
   147                          _cmd_write:
   148                              ; load character from buffer
   149  0147  7e                    ld a,(hl)
   150                              ; end of string?
   151  0148  fe00                  cp 0
   152                              ; yes: no data
   153  014a  2817                  jr z, _cmd_write_null
   154                              ; parse first pair of characters - address high
   155  014c  cdb001                call hex_byte_val
   156                              ; load into upper byte of memory pointer
   157  014f  57                    ld d,a
   158                              ; parse second pair of characters - address low
   159  0150  cdb001                call hex_byte_val
   160                              ; load into lower byte of memory pointer
   161  0153  5f                    ld e,a
   162                          _cmd_write_data:
   163                              ; load character from buffer
   164  0154  7e                    ld a,(hl)
   165                              ; end of string?
   166  0155  fe00                  cp 0
   167                              ; yes: we're done
   168  0157  2807                  jr z, _cmd_write_end
   169                              ; parse data byte
   170  0159  cdb001                call hex_byte_val
   171                              ; write byte to memory
   172  015c  12                    ld (de),a
   173                              ; advance destination pointer
   174  015d  13                    inc de
   175  015e  18f4                  jr _cmd_write_data
   176                          _cmd_write_end:
   177  0160  c3bf00                jp PROMPT
   178                              ; w with no data
   179                          _cmd_write_null:
   180  0163  211b04                ld hl,CMD_W_NULL_MSG
   181  0166  cd5500                call puts
   182                              ; and back to prompt
   183  0169  c3bf00                jp PROMPT
   184                          
   185                          ; EXECUTE
   186                          
   187                          ; start executing from given address
   188                          _cmd_execute:
   189                              ; load character from buffer
   190  016c  7e                    ld a,(hl)
   191                              ; end of string?
   192  016d  fe00                  cp 0
   193                              ; yes - no data
   194  016f  ca7d01                jp z, _cmd_exec_df
   195                              ; parse first pair of characters - address high
   196  0172  cdb001                call hex_byte_val
   197                              ; load into upper byte of memory pointer
   198  0175  57                    ld d,a
   199                              ; parse second pair of characters - address low
   200  0176  cdb001                call hex_byte_val
   201                              ; load into lower byte of memory pointer
   202  0179  5f                    ld e,a
   203  017a  626b                  ld hl,de
   204                              ; execute from address
   205  017c  e9                    jp (hl)
   206                              ; start executing from default address
   207                          _cmd_exec_df:
   208  017d  210080                ld hl,RAMSTART
   209                              ; execute from address
   210  0180  e9                    jp (hl)
   211                          
   212                          ; LOAD
   213                          
   214                          ; load from INTEL HEX - records are read from the buffer
   215                          _cmd_load:
   216                              ; load character from buffer
   217  0181  7e                    ld a,(hl)
   218                              ; end of string?
   219  0182  fe00                  cp 0
   220                              ; yes: no data - quit
   221  0184  caad01                jp z, _cmd_load_end
   222                              ; parse first pair of characters - byte count
   223  0187  cdb001                call hex_byte_val
   224  018a  fe00                  cp 0
   225                              ; yes - zero byte count - quit
   226  018c  caad01                jp z, _cmd_load_end
   227                              ; load byte count into C
   228  018f  4f                    ld c,a
   229                              ; parse address high
   230  0190  cdb001                call hex_byte_val
   231                              ; load into upper byte of memory pointer
   232  0193  57                    ld d,a
   233                              ; parse address low
   234  0194  cdb001                call hex_byte_val
   235                              ; load into lower byte of memory pointer
   236  0197  5f                    ld e,a
   237                              ; parse record type
   238  0198  cdb001                call hex_byte_val
   239                              ; record type zero?
   240  019b  fe00                  cp 0
   241                              ; no: quit
   242  019d  c2ad01                jp nz, _cmd_load_end
   243                          _cmd_load_data:
   244                              ; load character from buffer
   245  01a0  7e                    ld a,(hl)
   246                              ; end of string?
   247  01a1  fe00                  cp 0
   248                              ; yes: we're done
   249  01a3  2808                  jr z, _cmd_load_end
   250                              ; no:
   251                              ; parse data byte
   252  01a5  cdb001                call hex_byte_val
   253                              ; write byte to memory
   254  01a8  12                    ld (de),a
   255                              ; advance destination pointer
   256  01a9  13                    inc de
   257                              ; decrement byte counter
   258                              ; TODO djnz
   259  01aa  0d                    dec c
   260                              ; if byte counter not zero then go again
   261  01ab  20f3                  jr nz,_cmd_load_data
   262                          _cmd_load_end:
   263  01ad  c3bf00                jp PROMPT
   264                          
beanboard.asm:
    14                          include "asm/strings.asm"
asm/strings.asm:
     1                          ; string subroutines
     2                          
     3                          ; read 2 ASCII hex chars from memory by HL pointer, return converted value in A and advance HL pointer
     4                          hex_byte_val:
     5                              ; preserve BC
     6  01b0  c5                    push bc
     7                              ; load 1st character from memory
     8  01b1  7e                    ld a,(hl)
     9                              ; end of string?
    10  01b2  fe00                  cp 0
    11                              ; yes: no value - return zero
    12  01b4  2819                  jr z,_hex_byte_val_zero
    13                              ; no:
    14                              ; advance the buffer pointer
    15  01b6  23                    inc hl
    16                              ; convert first hex digit
    17  01b7  cdd301                call hex_val
    18                              ; shift left 4 bits to put value into top nibble
    19  01ba  cb27                  sla a
    20  01bc  cb27                  sla a
    21  01be  cb27                  sla a
    22  01c0  cb27                  sla a
    23                              ; cache the result
    24  01c2  47                    ld b,a
    25                              ; load 2nd character from memory
    26  01c3  7e                    ld a,(hl)
    27                              ; end of string?
    28  01c4  fe00                  cp 0
    29                              ; yes: incomplete byte - return zero
    30  01c6  2807                  jr z,_hex_byte_val_zero
    31                              ; advance the buffer pointer
    32  01c8  23                    inc hl
    33                              ; and convert 2nd hex digit
    34  01c9  cdd301                call hex_val
    35                              ; add first and second digits
    36  01cc  80                    add a,b
    37                              ; restore BC
    38  01cd  c1                    pop bc
    39  01ce  c9                    ret
    40                          _hex_byte_val_zero:
    41                              ; zero return value
    42  01cf  3e00                  ld a,0
    43                              ; restore BC
    44  01d1  c1                    pop bc
    45  01d2  c9                    ret
    46                          
    47                          ; convert an ASCII hex char in A to a number value (lower 4 bits)
    48                          hex_val:
    49                              ; is it lowercase alphabetic?
    50  01d3  fe61                  cp 'a'
    51                              ; no: uppercase/numeric
    52  01d5  3803                  jr c,_hex_val_u_n
    53                              ; yes: alphabetic
    54  01d7  d657                  sub 'a'-0x0a
    55  01d9  c9                    ret
    56                          _hex_val_u_n:
    57                              ; is it uppercase alphabetic?
    58  01da  fe41                  cp 'A'
    59                              ; no: numeric
    60  01dc  3803                  jr c,_hex_val_n
    61                              ; y:
    62  01de  d637                  sub 'A'-0x0a
    63  01e0  c9                    ret
    64                          _hex_val_n:
    65                              ; numeric
    66  01e1  d630                  sub '0'
    67  01e3  c9                    ret
    68                          
    69                          ; convert value in A into an ASCII pair and send to console
    70                          putchar_hex:
    71  01e4  f5                    push af
    72  01e5  c5                    push bc
    73                              ; stash in B
    74  01e6  47                    ld b,a
    75                              ; shift A right x4 e.g. transform 10110010 to 00001011
    76  01e7  cb3f                  srl a
    77  01e9  cb3f                  srl a
    78  01eb  cb3f                  srl a
    79  01ed  cb3f                  srl a
    80                              ; most significant digit
    81  01ef  cdfb01                call _putchar_hex_dgt
    82                              ; recover from stash
    83  01f2  78                    ld a,b
    84                              ; clear the top 4 bits
    85  01f3  e60f                  and 0b00001111
    86                              ; least significant digit
    87  01f5  cdfb01                call _putchar_hex_dgt
    88  01f8  c1                    pop bc
    89  01f9  f1                    pop af
    90  01fa  c9                    ret
    91                          _putchar_hex_dgt:
    92                              ; is it an alpha or numeric?
    93  01fb  fe0a                  cp 0x0a
    94                              ; numeric
    95  01fd  3806                  jr c,_putchar_hex_n
    96                              ; alpha
    97                              ; for alpha add the base ascii for 'a' but then sub 10 / 0x0a as hex 'a' = 10d
    98  01ff  c657                  add a,'a'-0x0a
    99  0201  cd3500                call putchar
   100  0204  c9                    ret
   101                          _putchar_hex_n:
   102                              ; for numeric add the base ascii for '0'
   103  0205  c630                  add a,'0'
   104  0207  cd3500                call putchar
   105  020a  c9                    ret
   106                          
beanboard.asm:
    15                          include "asm/HD44780LCD.asm"
asm/HD44780LCD.asm:
     1                          LCD_COMMAND_0 equ LCD_FUNCTION_SET+LCD_DATA_LEN_8+LCD_DISP_LINES_2+LCD_FONT_8
     2                          LCD_COMMAND_1 equ LCD_DISPLAY_ON_OFF_CONTROL+LCD_DISPLAY_ON+LCD_CURSOR_ON+LCD_BLINK_ON
     3                          
     4                          ; initialise LCD
     5                          lcd_init:
     6                          ; preserve registers
     7  020b  f5                    push af
     8                          ; intitialise device
     9  020c  3e38              	ld a,LCD_COMMAND_0
    10  020e  cd2202            	call lcd_putcmd
    11  0211  3e0f              	ld a,LCD_COMMAND_1
    12  0213  cd2202            	call lcd_putcmd
    13  0216  3e01              	ld a,LCD_CLEAR_DISPLAY
    14  0218  cd2202            	call lcd_putcmd
    15  021b  3e00                  ld a,0
    16  021d  cd3802                call lcd_putchar
    17                          ; restore registers
    18  0220  f1                    pop af
    19  0221  c9                    ret
    20                          
    21                          ; transmit character in A to the LCD control port
    22                          lcd_putcmd:
    23  0222  c5                    push bc
    24                          ; save the transmit character
    25  0223  47                    ld b,a
    26                          _lcd_putcmd_loop:
    27                          ; get the LCD status
    28  0224  db04                  in a,(LCD_CTRL)
    29                          ; busy ?
    30  0226  cb7f                  bit 7,a
    31                          ; yes
    32  0228  20fa                  jr nz,_lcd_putcmd_loop
    33                          ; no, restore the transmit character
    34  022a  78                    ld a,b
    35                          ; transmit the character
    36  022b  d304                  out (LCD_CTRL),a
    37  022d  c1                    pop bc
    38  022e  c9                    ret
    39                          
    40                          ; get character from LCD data port and return in A
    41                          lcd_getchar:
    42                          ; get the LCD status
    43  022f  db04                  in a,(LCD_CTRL)
    44                          ; busy ?
    45  0231  cb7f                  bit 7,a
    46                          ; yes
    47  0233  20fa                  jr nz,lcd_getchar
    48                          ; no, get a character
    49  0235  db05                  in a,(LCD_DATA)
    50  0237  c9                    ret
    51                          
    52                          ; transmit character in A to the LCD data port
    53                          lcd_putchar:
    54                              ; newline char?
    55  0238  fe0a                  cp ESC_N
    56  023a  c25802                jp nz,_lcd_putchar_printable
    57                              ; newline - fill out the line until EOL
    58                          _lcd_putchar_pad:
    59  023d  3e20                  ld a,' '
    60  023f  cd9002                call _lcd_putdata
    61  0242  fe13                  cp LCD_EOL_0
    62  0244  ca7202                jp z,_lcd_putchar_eol0
    63  0247  fe53                  cp LCD_EOL_1
    64  0249  ca7902                jp z,_lcd_putchar_eol1
    65  024c  fe27                  cp LCD_EOL_2
    66  024e  ca8002                jp z,_lcd_putchar_eol2
    67  0251  fe67                  cp LCD_EOL_3
    68  0253  ca8702                jp z,_lcd_putchar_eol3
    69                              ; loop until EOL
    70  0256  18e5                  jr _lcd_putchar_pad
    71                          _lcd_putchar_printable:
    72  0258  cd9002                call _lcd_putdata
    73                              ; check for overflow - DDRAM address returned in A
    74  025b  fe13                  cp LCD_EOL_0
    75  025d  ca7202                jp z,_lcd_putchar_eol0
    76  0260  fe53                  cp LCD_EOL_1
    77  0262  ca7902                jp z,_lcd_putchar_eol1
    78  0265  fe27                  cp LCD_EOL_2
    79  0267  ca8002                jp z,_lcd_putchar_eol2
    80  026a  fe67                  cp LCD_EOL_3
    81  026c  ca8702                jp z,_lcd_putchar_eol3
    82  026f  c38f02                jp _lcd_putchar_end
    83                          _lcd_putchar_eol0:
    84  0272  3ec0                  ld a,LCD_SET_DDRAM_ADDR+LCD_LINE_1_ADDR
    85  0274  cd2202            	call lcd_putcmd
    86  0277  1816                  jr _lcd_putchar_end
    87                          _lcd_putchar_eol1:
    88  0279  3e94                  ld a,LCD_SET_DDRAM_ADDR+LCD_LINE_2_ADDR
    89  027b  cd2202            	call lcd_putcmd
    90  027e  180f                  jr _lcd_putchar_end
    91                          _lcd_putchar_eol2:
    92  0280  3ed4                  ld a,LCD_SET_DDRAM_ADDR+LCD_LINE_3_ADDR
    93  0282  cd2202            	call lcd_putcmd
    94  0285  1808                  jr _lcd_putchar_end
    95                          _lcd_putchar_eol3:
    96  0287  cda102                call lcd_scroll
    97  028a  3ed4                  ld a,LCD_SET_DDRAM_ADDR+LCD_LINE_3_ADDR
    98  028c  cd2202            	call lcd_putcmd
    99                          _lcd_putchar_end:
   100  028f  c9                    ret
   101                          
   102                          ; transmit character in A to the LCD data port,
   103                          ; return in A the DDRAM address where the character was sent
   104                          _lcd_putdata:
   105  0290  c5                    push bc
   106                              ; save the transmit character
   107  0291  47                    ld b,a
   108                          __lcd_putdata_loop:
   109                              ; get the LCD status
   110  0292  db04                  in a,(LCD_CTRL)
   111                              ; busy ?
   112  0294  cb7f                  bit 7,a
   113                              ; yes
   114  0296  20fa                  jr nz,__lcd_putdata_loop
   115                              ; no, reset the 'busy' bit and preserve the DDRAM address
   116  0298  e67f                  and 0b01111111
   117  029a  4f                    ld c,a
   118                              ; restore the transmit character and send it
   119  029b  78                    ld a,b
   120  029c  d305                  out (LCD_DATA),a
   121                              ; restore the DDRAM address
   122  029e  79                    ld a,c
   123  029f  c1                    pop bc
   124  02a0  c9                    ret
   125                          
   126                          lcd_scroll:
   127  02a1  c5                    push bc
   128  02a2  d5                    push de
   129  02a3  16c0                  ld d,LCD_SET_DDRAM_ADDR+LCD_LINE_1_ADDR
   130  02a5  1e80                  ld e,LCD_SET_DDRAM_ADDR+LCD_LINE_0_ADDR
   131  02a7  cdc002                call _lcd_scroll_line
   132  02aa  1694                  ld d,LCD_SET_DDRAM_ADDR+LCD_LINE_2_ADDR
   133  02ac  1ec0                  ld e,LCD_SET_DDRAM_ADDR+LCD_LINE_1_ADDR
   134  02ae  cdc002                call _lcd_scroll_line
   135  02b1  16d4                  ld d,LCD_SET_DDRAM_ADDR+LCD_LINE_3_ADDR
   136  02b3  1e94                  ld e,LCD_SET_DDRAM_ADDR+LCD_LINE_2_ADDR
   137  02b5  cdc002                call _lcd_scroll_line
   138  02b8  3ed4                  ld a,LCD_SET_DDRAM_ADDR+LCD_LINE_3_ADDR
   139  02ba  cdd902                call _lcd_scroll_clear_line
   140  02bd  d1                    pop de
   141  02be  c1                    pop bc
   142  02bf  c9                    ret
   143                          _lcd_scroll_line:
   144                              ; b = character counter
   145                              ; c = stash char
   146                              ; d = source line to copy from
   147                              ; e = destination line to copy to
   148  02c0  0614                  ld b,LCD_LINE_LEN
   149                          _lcd_scroll_line_loop:
   150                              ; load source
   151  02c2  7a                    ld a,d
   152                              ; character counter is an offset
   153  02c3  80                    add b
   154                              ; zero based index so -1
   155  02c4  3d                    dec a
   156  02c5  cd2202                call lcd_putcmd
   157  02c8  cd2f02                call lcd_getchar
   158                              ; stash the value
   159  02cb  4f                    ld c,a
   160                              ; load destination
   161  02cc  7b                    ld a,e
   162                              ; character counter is an offset
   163  02cd  80                    add b
   164                              ; zero based index so -1
   165  02ce  3d                    dec a
   166  02cf  cd2202                call lcd_putcmd
   167                              ; recover the stashed value
   168  02d2  79                    ld a,c
   169  02d3  cd9002                call _lcd_putdata
   170  02d6  10ea                  djnz _lcd_scroll_line_loop
   171  02d8  c9                    ret
   172                          _lcd_scroll_clear_line:
   173                              ; a = destination line to clear
   174                              ; b = character counter
   175  02d9  0614                  ld b,LCD_LINE_LEN
   176  02db  cd2202                call lcd_putcmd
   177                          _lcd_scroll_clear_line_loop:
   178  02de  3e20                  ld a,' '
   179  02e0  cd9002                call _lcd_putdata
   180  02e3  10f9                  djnz _lcd_scroll_clear_line_loop
   181  02e5  c9                    ret
   182                          
   183                          ; print a zero-terminated string pointed to by hl to the LCD
   184                          lcd_puts:
   185  02e6  e5                    push hl
   186                          _lcd_puts_loop:
   187                              ; get character from string
   188  02e7  7e                    ld a,(hl)
   189                              ; is it zero?
   190  02e8  fe00                  cp 0
   191                              ; yes
   192  02ea  2807                  jr z, _lcd_puts_end
   193                              ; no: send character
   194  02ec  cd3802                call lcd_putchar
   195                              ; next character position
   196  02ef  23                    inc hl
   197                              ; loop for next character
   198  02f0  c3e702                jp _lcd_puts_loop
   199                          _lcd_puts_end:
   200  02f3  e1                    pop hl
   201  02f4  c9                    ret
   202                          
   203                          
beanboard.asm:
    16                          include "asm/keymatrix.asm"
asm/keymatrix.asm:
     1                          DEBOUNCE_DELAY  equ 0x4000
     2                          
     3                          MOD_KEY_SHIFT   equ 0b00000001
     4                          MOD_KEY_FN      equ 0b00000010
     5                          MOD_KEY_CONTROL equ 0b00000100
     6                          MOD_KEY_ALT     equ 0b00001000
     7                          MOD_KEY_CMD     equ 0b00010000
     8                          
     9                          ; return keyboard char value in A, or 0
    10                          key_readchar:
    11  02f5  c5                    push bc
    12  02f6  d5                    push de
    13  02f7  e5                    push hl
    14                              ; initial row bit - only 1 bit is ever set at a time - it is shifted from bit 0 to bit 7
    15  02f8  0601                  ld b,0x01
    16                              ; row counter - 0 => 7
    17  02fa  0e00                  ld c,0x00
    18                              ; location of previous values
    19  02fc  2110f0                ld hl,KEY_MATRIX_BUFFER
    20  02ff  cd4203                call modifierkeys
    21                              ; initialise map pointer
    22  0302  116703                ld de,QWERTY_KEYMAP_L
    23                              ; shift key down?
    24  0305  e601                  and MOD_KEY_SHIFT
    25  0307  ca0d03                jp z,_keyscanloop
    26  030a  11a703                ld de,QWERTY_KEYMAP_U
    27                          _keyscanloop:
    28  030d  cd3503                call _rowscan
    29                              ; ASCII returned in A, or 0
    30  0310  cd5203                call _colscan
    31  0313  fe00                  cp 0
    32  0315  c21f03                jp nz,key_readchar_end
    33                              ; move the pointer of previous values to the next row slot
    34  0318  23                    inc hl
    35                              ; increment row counter
    36  0319  0c                    inc c
    37                              ; clear the carry flag
    38  031a  b7                    or a
    39                              ; shift row bit left - when we've done all 8, it will move to the carry flag
    40  031b  cb10                  rl b
    41                              ; loop if not done all rows
    42  031d  30ee                  jr nc,_keyscanloop
    43                          key_readchar_end:
    44                              ; debounce delay, restore state and return
    45  031f  cd2603                call _debounce_delay
    46  0322  e1                    pop hl
    47  0323  d1                    pop de
    48  0324  c1                    pop bc
    49  0325  c9                    ret
    50                          
    51                          _debounce_delay:
    52  0326  f5                    push af
    53  0327  d5                    push de
    54  0328  110040                ld de,DEBOUNCE_DELAY
    55                          _delay_loop:
    56  032b  1b                    dec de
    57  032c  00                    nop
    58  032d  7a                    ld a, d
    59  032e  fe00                  cp 0
    60  0330  20f9                  jr nz,_delay_loop
    61                          _delay_end:
    62  0332  d1                    pop de
    63  0333  f1                    pop af
    64  0334  c9                    ret
    65                          
    66                          ; get row bitmap representing new keystrokes:
    67                          ; B contains row bit,
    68                          ; C contains row count,
    69                          ; HL contains a pointer to the old value.
    70                          ; return value in A
    71                          _rowscan:
    72                              ; preserve registers
    73  0335  d5                    push de
    74                              ; fetch previous value for comparison
    75  0336  7e                    ld a,(hl)
    76                              ; invert A - we want to check keys becoming closed - so zeroed bits on the previous value are significant
    77  0337  2f                    cpl
    78                              ; store inverted previous value
    79  0338  57                    ld d,a
    80                              ; get the current row bit
    81  0339  78                    ld a,b
    82                              ; output row strobe
    83  033a  d302                  out (KEYSCAN_OUT),a
    84                              ; get column values
    85  033c  db03                  in a,(KEYSCAN_IN)
    86                              ; store the new value
    87  033e  77                    ld (hl),a
    88                              ; newVal AND ~oldVal means bits are set only when the previous bit value was 0
    89  033f  a2                    and d
    90                              ; restore registers
    91  0340  d1                    pop de
    92  0341  c9                    ret
    93                          
    94                          ; return bitmap representing modifier keys in A
    95                          modifierkeys:
    96  0342  3e10                  ld a,0b00010000 ; row 4
    97                              ; output row strobe
    98  0344  d302                  out (KEYSCAN_OUT),a
    99                              ; get column values
   100  0346  db03                  in a,(KEYSCAN_IN)
   101  0348  e601                  and 0b00000001 ; row 4, bit 0 is SHIFT
   102                              ; left shift modifier
   103  034a  2003                  jr nz,_modifier_shift
   104                              ; no modifiers
   105  034c  3e00                  ld a,0
   106  034e  c9                    ret
   107                          _modifier_shift:
   108  034f  3e01                  ld a,MOD_KEY_SHIFT
   109  0351  c9                    ret
   110                          
   111                          ; A contains row bitmap representing new keystrokes,
   112                          ; DE contains a pointer to the ASCII map for the row - which is incremented in the subroutine
   113                          ; first printable character returned in A
   114                          _colscan:
   115                              ; preserve registers
   116  0352  c5                    push bc
   117                              ; initialise col bit mask - only 1 bit is ever set at a time - it is shifted from bit 0 to bit 7
   118  0353  0e01                  ld c,0x01
   119                              ; stash the bitmap
   120  0355  47                    ld b,a
   121                          _colscanloop:
   122                              ; reload the bitmap
   123  0356  78                    ld a,b
   124                              ; mask the bitmap - use the column mask (C) over the bitmap value in A
   125  0357  a1                    and c
   126                              ; if zero then no keypress
   127  0358  2805                  jr z,_colscanloopnext
   128  035a  1a                    ld a,(de)
   129                              ; ASCII is 0?
   130  035b  fe00                  cp 0
   131  035d  2006                  jr nz,_colscanend
   132                          _colscanloopnext:
   133                              ; increment character map pointer
   134  035f  13                    inc de
   135                              ; clear the carry flag
   136  0360  b7                    or a
   137                              ; shift row bit left - when we've done all 8, it will move to the carry flag
   138  0361  cb11                  rl c
   139                              ; loop if not done all rows
   140  0363  30f1                  jr nc,_colscanloop
   141                          _colscanend:
   142                              ; restore registers
   143  0365  c1                    pop bc
   144  0366  c9                    ret
   145                          
   146                          ; define values for control keys
   147                          ; modifiers have zero value
   148                          QWERTY_SHIFT equ 0
   149                          QWERTY_FN equ 0
   150                          QWERTY_CTRL equ 0
   151                          QWERTY_ALT equ 0
   152                          QWERTY_CMD equ 0
   153                          QWERTY_CURS_UP equ 1
   154                          QWERTY_CURS_DOWN equ 2
   155                          QWERTY_CURS_LEFT equ 3
   156                          QWERTY_CURS_RIGHT equ 4
   157                          QWERTY_CAPS equ 5
   158                          
   159                          QWERTY_KEYMAP_L:
   160  0367  1b71776572747975      db ESC_E,'q','w','e','r','t','y','u','i','o','p',QWERTY_CAPS,ESC_B,'7','8','9'
              696f700508373839  
   161  0377  096173646667686a      db ESC_T,'a','s','d','f','g','h','j','k','l',';',QUOTE,ESC_N,'4','5','6'
              6b6c3b270a343536  
   162  0387  007a786376626e6d      db QWERTY_SHIFT,'z','x','c','v','b','n','m',',','.','/',SLASH,QWERTY_CURS_UP,'1','2','3'
              2c2e2f5c01313233  
   163  0397  00000000205b5d20      db QWERTY_FN,QWERTY_CTRL,QWERTY_ALT,QWERTY_CMD,' ','[',']',' ','`','-','=',QWERTY_CURS_LEFT,QWERTY_CURS_DOWN,QWERTY_CURS_RIGHT,'0',ESC_N
              602d3d030204300a  
   164                          QWERTY_KEYMAP_U:
   165  03a7  1b51574552545955      db ESC_E,'Q','W','E','R','T','Y','U','I','O','P',QWERTY_CAPS,ESC_B,'&','*','('
              494f500508262a28  
   166  03b7  094153444647484a      db ESC_T,'A','S','D','F','G','H','J','K','L',':','"',ESC_N,'$','%','^'
              4b4c3a220a24255e  
   167  03c7  005a584356424e4d      db QWERTY_SHIFT,'Z','X','C','V','B','N','M','<','>','?',SLASH,QWERTY_CURS_UP,'!','@','#'
              3c3e3f5c01214023  
   168  03d7  00000000207b7d20      db QWERTY_FN,QWERTY_CTRL,QWERTY_ALT,QWERTY_CMD,' ','{','}',' ','~','_','+',QWERTY_CURS_LEFT,QWERTY_CURS_DOWN,QWERTY_CURS_RIGHT,')',ESC_N
              7e5f2b030204290a  
   169                          
beanboard.asm:
    17                          include "asm/messages_small.asm"
asm/messages_small.asm:
     1                          WELCOME_MSG:
     2  03e7  5061696e66756c44                  db "PainfulDiodes\n"
              696f6465730a      
     3  03f5  4d415256494e205a                  db "MARVIN Z80 monitor\n"
              3830206d6f6e6974  
              6f720a            
     4  0408  76312e320a00                      db "v1.2\n",0
     5                          
     6                          
     7                          BAD_CMD_MSG:
     8  040e  42616420636f6d6d                  db "Bad command\n",0
              616e640a00        
     9                          
    10                          CMD_W_NULL_MSG:
    11  041b  4e6f20646174610a                  db "No data\n",0
              00                
    12                          
beanboard.asm:
    18                          
