beanboard-ram.asm:
     1                          ; MARVIN build for BeanZee with BeanBoard - RAM version
     2                          ; https://github.com/PainfulDiodes/BeanZee
     3                          ; https://github.com/PainfulDiodes/BeanBoard
     4                          
     5                          BEANBOARD EQU 1
     6                          
     7                          ORG 0x8000
     8                          
     9                          ; start of user RAM
    10                          RAMSTART equ 0x9000
    11                          ; 8-byte keyscan buffer
    12                          KEYSCAN_BUFFER equ 0xf000
    13                          ; input buffer - start of system RAM
    14                          CMD_BUFFER equ 0xf010
    15                          ; this should really be 0x0000 as the CPU will dec SP before PUSH
    16                          STACK equ 0xffff
    17                          
    18                          UM245R_CTRL equ 0 ; serial control port
    19                          UM245R_DATA equ 1 ; serial data port
    20                          KEYSCAN_OUT equ 2 ; either 2 or 3 will work
    21                          KEYSCAN_IN  equ 3 ; either 2 or 3 will work
    22                          LCD_CTRL    equ 4 ; LCD control port
    23                          LCD_DATA    equ 5 ; LCD data port
    24                          
    25  0000  31ffff                ld sp, STACK
    26  0003  cd9f02                call lcd_init
    27  0006  cd7a03                call keyscan_init
    28  0009  c38000                jp start
    29                          
    30                          include "escapestring.inc"
escapestring.inc:
     1                          ; escape character constants for assembler compatibility
     2                          ; sjasmplus requires double quotes around escape sequences: "\n" and would not interpret '\n' but truncate
     3                          ; z88dk-z80asm requires single quotes around so would correctly interpret '\n' but reject "\n"
     4                          
     5                          ESC_B equ 0x08 ; \b
     6                          ESC_T equ 0x09 ; \t
     7                          ESC_N equ 0x0a ; \n
     8                          ESC_R equ 0x0d ; \r
     9                          ESC_E equ 0x1b ; \e
    10                          SLASH equ 0x5c ; \\
    11                          QUOTE equ 0x27 ; \'
    12                          
beanboard-ram.asm:
    31                          include "HD44780LCD.inc"
HD44780LCD.inc:
     1                          ; LCD commands
     2                          LCD_CLEAR_DISPLAY equ 0x01
     3                          LCD_RETURN_HOME equ 0x02
     4                          LCD_ENTRY_MODE_SET equ 0x04
     5                          LCD_DISPLAY_ON_OFF_CONTROL equ 0x08
     6                          LCD_CURSOR_DISPLAY_SHIFT equ 0x10
     7                          LCD_FUNCTION_SET equ 0x20
     8                          LCD_SET_CGRAM_ADDR equ 0x40
     9                          LCD_SET_DDRAM_ADDR equ 0x80
    10                          
    11                          ; LCD_ENTRY_MODE_SET options
    12                          LCD_ENTRY_INC equ 0x02 ; left
    13                          LCD_ENTRY_DEC equ 0x00 ; right
    14                          LCD_ENTRY_SHIFT equ 0x01
    15                          LCD_ENTRY_NO_SHIFT equ 0x00
    16                          
    17                          ; LCD_DISPLAY_ON_OFF_CONTROL options
    18                          LCD_DISPLAY_ON equ 0x04
    19                          LCD_DISPLAY_OFF equ 0x00
    20                          LCD_CURSOR_ON equ 0x02
    21                          LCD_CURSOR_OFF equ 0x00
    22                          LCD_BLINK_ON equ 0x01
    23                          LCD_BLINK_OFF equ 0x00
    24                          
    25                          ; LCD_CURSOR_DISPLAY_SHIFT options
    26                          LCD_SHIFT_DISPLAY equ 0x08
    27                          LCD_SHIFT_CURSOR equ 0x00
    28                          LCD_SHIFT_RIGHT equ 0x04
    29                          LCD_SHIFT_LEFT equ 0x00
    30                          
    31                          ; LCD_FUNCTION_SET options
    32                          LCD_DATA_LEN_8 equ 0x10
    33                          LCD_DATA_LEN_4 equ 0x00
    34                          LCD_DISP_LINES_2 equ 0x08
    35                          LCD_DISP_LINES_1 equ 0x00
    36                          LCD_FONT_10 equ 0x04
    37                          LCD_FONT_8 equ 0x00
    38                          
    39                          LCD_LINE_LEN equ 0x14
    40                          LCD_NUM_LINES equ 4
    41                          LCD_BUFFER_LEN equ LCD_LINE_LEN*LCD_NUM_LINES
    42                          
    43                          ; LCD_SET_DDRAM_ADDR options
    44                          LCD_LINE_0_ADDR equ 0x00
    45                          LCD_LINE_1_ADDR equ 0x40
    46                          LCD_LINE_2_ADDR equ 0x00+LCD_LINE_LEN
    47                          LCD_LINE_3_ADDR equ 0x40+LCD_LINE_LEN
    48                          LCD_EOL_0 equ 0x00+LCD_LINE_LEN-1
    49                          LCD_EOL_1 equ 0x40+LCD_LINE_LEN-1
    50                          LCD_EOL_2 equ 0x00+LCD_LINE_LEN*2-1
    51                          LCD_EOL_3 equ 0x40+LCD_LINE_LEN*2-1
    52                          
beanboard-ram.asm:
    32                          include "console.asm"
console.asm:
     1  000c  00000000          ALIGN 0x10
     2                          
     3                          ; wait for a character and return in A
     4                          getchar:
     5  0010  cd2000                call readchar
     6  0013  fe00                  cp 0
     7  0015  c0                    ret nz
     8  0016  18f8                  jr getchar
     9                          
    10  0018  0000000000000000  ALIGN 0x10
    11                          
    12                          ; read a character from the console and return it,
    13                          ; or 0 if there is no character
    14                          readchar:
    15                          IF BEANBOARD
    16                              ; check keyboard
    17  0020  cd8903                call keyscan
    18                              ; is there a character?
    19  0023  fe00                  cp 0
    20                              ; yes: return it
    21  0025  c0                    ret nz
    22                              ; no:
    23                          ENDIF
    24                              ; check usb
    25  0026  cd4f00                call usb_readchar
    26                              ; return the result - 0 if no char
    27  0029  c9                    ret
    28                          
    29  002a  000000000000      ALIGN 0x10
    30                          
    31                          putchar:
    32                              ; A is not guaranteed to be preserved in these calls,
    33                              ; so preserve across the first call
    34                          IF BEANBOARD
    35  0030  f5                    push af
    36  0031  cdcc02                call lcd_putchar
    37  0034  f1                    pop af
    38                          ENDIF
    39  0035  cd6000                call usb_putchar
    40  0038  c9                    ret
    41                          
    42  0039  00000000000000    ALIGN 0x10
    43                          
    44                          ; print a zero-terminated string, pointed to by hl
    45                          puts:
    46  0040  e5                    push hl
    47                          _puts_loop:
    48                              ; get character from string
    49  0041  7e                    ld a,(hl)
    50                              ; is it zero?
    51  0042  fe00                  cp 0
    52                              ; yes
    53  0044  2807                  jr z, _puts_end
    54                              ; no: send character
    55  0046  cd3000                call putchar
    56                              ; next character position
    57  0049  23                    inc hl
    58                              ; loop for next character
    59  004a  c34100                jp _puts_loop
    60                          _puts_end:
    61  004d  e1                    pop hl
    62  004e  c9                    ret
    63                          
beanboard-ram.asm:
    33                          include "UM245R.asm"
UM245R.asm:
     1                          ; It is assumed that UM245R status signals are gated to the data bus as an IO port where:
     2                          ; /TXE = bit 0
     3                          ; /RXF = bit 1
     4                          ; As per:
     5                          ; https://github.com/PainfulDiodes/z80-breadboard-computer
     6                          ;
     7                          ; line endings are translated:
     8                          ; incoming line endings from the terminal are expected to be \r
     9                          ; and are tranlslated to \n
    10                          ; (\r\n would count as 2 line endings)
    11                          ; and outgoing line endings are sent as \r\n
    12                          ; externally this is consistent with VT100/ANSI terminal behaviour
    13                          ; and internally line endings are always \n
    14                          
    15                          ; get character and return in A
    16                          usb_readchar:
    17                              ; get the USB status
    18  004f  db00                  in a,(UM245R_CTRL)
    19                              ; data to read? (active low)
    20  0051  cb4f                  bit 1,a
    21                              ; no, the buffer is empty
    22  0053  2008                  jr nz,_usb_no_char
    23                              ; yes, read the received char
    24  0055  db01                  in a,(UM245R_DATA)
    25                              ; is CR?
    26  0057  fe0d                  cp ESC_R
    27                              ; no:
    28  0059  c0                    ret nz
    29                              ; yes: convert CR to LF
    30  005a  3e0a                  ld a, ESC_N
    31  005c  c9                    ret
    32                          _usb_no_char:
    33  005d  3e00                  ld a,0
    34  005f  c9                    ret
    35                          
    36                          usb_putchar:
    37                              ; newline?
    38  0060  fe0a                  cp ESC_N
    39                              ; no: just send the char
    40  0062  2007                  jr nz,_do_usb_put
    41  0064  3e0d                  ld a, ESC_R
    42  0066  cd6f00                call _usb_put
    43  0069  3e0a                  ld a, ESC_N
    44                          _do_usb_put:
    45  006b  cd6f00                call _usb_put
    46  006e  c9                    ret
    47                          
    48                          ; transmit character in A
    49                          _usb_put:
    50  006f  c5                    push bc
    51                              ; stash the transmit character
    52  0070  47                    ld b,a
    53                          _usb_put_loop:
    54                              ; get the USB status
    55  0071  db00                  in a,(UM245R_CTRL)
    56                              ; ready to transmit? (active low)
    57  0073  cb47                  bit 0,a
    58                              ; no: bit is high
    59  0075  20fa                  jr nz,_usb_put_loop
    60                              ; yes: restore the stashed transmit character
    61  0077  78                    ld a,b
    62                              ; transmit the character
    63  0078  d301                  out (UM245R_DATA),a
    64  007a  c1                    pop bc
    65  007b  c9                    ret
    66                          
beanboard-ram.asm:
    34                          include "marvin.asm"
marvin.asm:
     1                          ; ****************************************************
     2                          ; *  Marvin - a Z80 homebrew monitor program
     3                          ; * (c) Stephen Willcock 2024
     4                          ; * https://github.com/PainfulDiodes
     5                          ; ****************************************************
     6                          
     7                          ; MAIN PROGRAM LOOP
     8                          
     9  007c  00000000          ALIGN 0x10
    10                          
    11                          start:
    12                              ; point DE to zero - this is the default address argument for commands
    13  0080  110000                ld de,0x0000
    14                          
    15  0083  21ee01                ld hl,welcome_msg
    16  0086  cd4000                call puts
    17                          
    18                          prompt:
    19                              ; point HL to the beginning of the input buffer
    20  0089  2110f0                ld hl,CMD_BUFFER
    21  008c  3e3e                  ld a,'>'
    22  008e  cd3000                call putchar
    23                          
    24                          _get_cmd:
    25                              ; get character from console
    26  0091  cd1000                call getchar
    27                              ; echo the character to console
    28  0094  cd3000                call putchar
    29                              ; is CR?
    30  0097  fe0d                  cp ESC_R
    31                              ; yes: skip this
    32  0099  28f6                  jr z,_get_cmd
    33                              ; is tab?
    34  009b  fe09                  cp ESC_T
    35                              ; yes: skip this
    36  009d  28f2                  jr z,_get_cmd
    37                              ; is space?
    38  009f  fe20                  cp ' '
    39                              ; yes - skip this
    40  00a1  28ee                  jr z,_get_cmd
    41                              ; escape?
    42  00a3  fe1b                  cp ESC_E
    43                              ; yes
    44  00a5  2808                  jr z, _get_cmd_esc
    45                              ; end of line?
    46  00a7  fe0a                  cp ESC_N
    47                              ; yes
    48  00a9  280b                  jr z, _get_cmd_end
    49                              ; no: add character to the buffer
    50  00ab  77                    ld(hl),a
    51                              ; move pointer to next buffer location - we're not checking for overrun
    52  00ac  23                    inc hl
    53                              ; next character
    54  00ad  18e2                  jr _get_cmd
    55                              ; do escape
    56                          _get_cmd_esc:
    57                              ; new line
    58  00af  3e0a                  ld a,ESC_N
    59  00b1  cd3000                call putchar
    60                              ; back to prompt
    61  00b4  18d3                  jr prompt
    62                          _get_cmd_end:
    63                              ; string terminator
    64  00b6  3e00                  ld a,0
    65                              ; add terminator to end of buffer
    66  00b8  77                    ld(hl),a
    67                          ; process command from buffer
    68                              ; point to start of buffer
    69  00b9  2110f0                ld hl,CMD_BUFFER
    70                              ; load character from buffer
    71  00bc  7e                    ld a,(hl)
    72                              ; end of string?
    73  00bd  fe00                  cp 0
    74                              ; yes - empty line - go back to prompt
    75  00bf  28c8                  jr z,prompt
    76                              ; advance the buffer pointer
    77  00c1  23                    inc hl
    78  00c2  fe72                  cp 'r'
    79  00c4  2815                  jr z,_cmd_read
    80  00c6  fe77                  cp 'w'
    81  00c8  2847                  jr z,_cmd_write
    82  00ca  fe78                  cp 'x'
    83  00cc  2868                  jr z,_cmd_execute
    84                              ; ':' = load from intel hex format
    85  00ce  fe3a                  cp ':'
    86  00d0  2879                  jr z,_cmd_load
    87                              ; otherwise error
    88  00d2  211a02                ld hl,bad_cmd_msg
    89  00d5  cd4000                call puts
    90                              ; loop back to the prompt
    91  00d8  c38900                jp prompt
    92                          
    93                          ; COMMANDS
    94                          
    95                          ; READ
    96                          ; read bytes from memory and send hex values to console
    97                          _cmd_read:
    98                              ; load character from buffer
    99  00db  7e                    ld a,(hl)
   100                              ; end of string?
   101  00dc  fe00                  cp 0
   102                              ; yes: no address argument, so skip to read row
   103  00de  2808                  jr z, _cmd_read_row
   104                              ; parse first pair of characters
   105  00e0  cd4402                call hex_byte_val
   106                              ; load into upper byte of memory pointer
   107  00e3  57                    ld d,a
   108                              ; parse second pair of characters
   109  00e4  cd4402                call hex_byte_val
   110                              ; load into lower byte of memory pointer
   111  00e7  5f                    ld e,a
   112                          _cmd_read_row:
   113                              ; initialise byte counter - each row will have this many bytes
   114  00e8  0e10                  ld c, 0x10
   115                              ; print DE content: the read address
   116  00ea  7a                    ld a,d
   117  00eb  cd7802                call putchar_hex
   118  00ee  7b                    ld a,e
   119  00ef  cd7802                call putchar_hex
   120                              ; separator between address and data
   121  00f2  3e3a                  ld a,':'
   122  00f4  cd3000                call putchar
   123  00f7  3e20                  ld a,' '
   124  00f9  cd3000                call putchar
   125                              ; get a byte
   126                          _cmd_read_byte:
   127  00fc  1a                    ld a,(de)
   128                              ; and print it
   129  00fd  cd7802                call putchar_hex
   130                              ; add space between bytes
   131  0100  3e20                  ld a,' '
   132  0102  cd3000                call putchar
   133                              ; next address
   134  0105  13                    inc de
   135                              ; reduce byte counter
   136                              ; TODO djnz ?
   137  0106  0d                    dec c
   138                              ; repeat if the counter is not 0
   139  0107  20f3                  jr nz, _cmd_read_byte
   140                              ; otherwise, new line
   141  0109  3e0a                  ld a,ESC_N
   142  010b  cd3000                call putchar
   143                              ; and back to prompt
   144  010e  c38900                jp prompt
   145                          
   146                          ; WRITE
   147                          
   148                          ; write bytes to memory interpreting hex values from console
   149                          _cmd_write:
   150                              ; load character from buffer
   151  0111  7e                    ld a,(hl)
   152                              ; end of string?
   153  0112  fe00                  cp 0
   154                              ; yes: no data
   155  0114  2817                  jr z, _cmd_write_null
   156                              ; parse first pair of characters - address high
   157  0116  cd4402                call hex_byte_val
   158                              ; load into upper byte of memory pointer
   159  0119  57                    ld d,a
   160                              ; parse second pair of characters - address low
   161  011a  cd4402                call hex_byte_val
   162                              ; load into lower byte of memory pointer
   163  011d  5f                    ld e,a
   164                          _cmd_write_data:
   165                              ; load character from buffer
   166  011e  7e                    ld a,(hl)
   167                              ; end of string?
   168  011f  fe00                  cp 0
   169                              ; yes: we're done
   170  0121  2807                  jr z, _cmd_write_end
   171                              ; parse data byte
   172  0123  cd4402                call hex_byte_val
   173                              ; write byte to memory
   174  0126  12                    ld (de),a
   175                              ; advance destination pointer
   176  0127  13                    inc de
   177  0128  18f4                  jr _cmd_write_data
   178                          _cmd_write_end:
   179  012a  c38900                jp prompt
   180                              ; w with no data
   181                          _cmd_write_null:
   182  012d  213202                ld hl,cmd_w_null_msg
   183  0130  cd4000                call puts
   184                              ; and back to prompt
   185  0133  c38900                jp prompt
   186                          
   187                          ; EXECUTE
   188                          
   189                          ; start executing from given address
   190                          _cmd_execute:
   191                              ; load character from buffer
   192  0136  7e                    ld a,(hl)
   193                              ; end of string?
   194  0137  fe00                  cp 0
   195                              ; yes - no data
   196  0139  ca4701                jp z, _cmd_exec_df
   197                              ; parse first pair of characters - address high
   198  013c  cd4402                call hex_byte_val
   199                              ; load into upper byte of memory pointer
   200  013f  57                    ld d,a
   201                              ; parse second pair of characters - address low
   202  0140  cd4402                call hex_byte_val
   203                              ; load into lower byte of memory pointer
   204  0143  5f                    ld e,a
   205  0144  626b                  ld hl,de
   206                              ; execute from address
   207  0146  e9                    jp (hl)
   208                              ; start executing from default address
   209                          _cmd_exec_df:
   210  0147  210090                ld hl,RAMSTART
   211                              ; execute from address
   212  014a  e9                    jp (hl)
   213                          
   214                          ; LOAD
   215                          
   216                          ; load from INTEL HEX - records are read from the buffer
   217                          _cmd_load:
   218                              ; load character from buffer
   219  014b  7e                    ld a,(hl)
   220                              ; end of string?
   221  014c  fe00                  cp 0
   222                              ; yes: no data - quit
   223  014e  ca7701                jp z, _cmd_load_end
   224                              ; parse first pair of characters - byte count
   225  0151  cd4402                call hex_byte_val
   226  0154  fe00                  cp 0
   227                              ; yes - zero byte count - quit
   228  0156  ca7701                jp z, _cmd_load_end
   229                              ; load byte count into C
   230  0159  4f                    ld c,a
   231                              ; parse address high
   232  015a  cd4402                call hex_byte_val
   233                              ; load into upper byte of memory pointer
   234  015d  57                    ld d,a
   235                              ; parse address low
   236  015e  cd4402                call hex_byte_val
   237                              ; load into lower byte of memory pointer
   238  0161  5f                    ld e,a
   239                              ; parse record type
   240  0162  cd4402                call hex_byte_val
   241                              ; record type zero?
   242  0165  fe00                  cp 0
   243                              ; no: quit
   244  0167  c27701                jp nz, _cmd_load_end
   245                          _cmd_load_data:
   246                              ; load character from buffer
   247  016a  7e                    ld a,(hl)
   248                              ; end of string?
   249  016b  fe00                  cp 0
   250                              ; yes: we're done
   251  016d  2808                  jr z, _cmd_load_end
   252                              ; no:
   253                              ; parse data byte
   254  016f  cd4402                call hex_byte_val
   255                              ; write byte to memory
   256  0172  12                    ld (de),a
   257                              ; advance destination pointer
   258  0173  13                    inc de
   259                              ; decrement byte counter
   260                              ; TODO djnz
   261  0174  0d                    dec c
   262                              ; if byte counter not zero then go again
   263  0175  20f3                  jr nz,_cmd_load_data
   264                          _cmd_load_end:
   265  0177  c38900                jp prompt
   266                          
   267                          alt_welcome_msg:
   268  017a  4d415256494e2076                  db "MARVIN v1.1.beta\n"
              312e312e62657461  
              0a                
   269  018b  412073696d706c65                  db "A simple Z80 homebrew monitor program\n"
              205a383020686f6d  
              6562726577206d6f  
              6e69746f72207072  
              6f6772616d0a      
   270  01b1  2863292053746570                  db "(c) Stephen Willcock 2024\n"
              68656e2057696c6c  
              636f636b20323032  
              340a              
   271  01cb  68747470733a2f2f                  db "https://github.com/PainfulDiodes\n\n",0
              6769746875622e63  
              6f6d2f5061696e66  
              756c44696f646573  
              0a0a00            
   272                          
   273                          welcome_msg:
   274  01ee  5061696e66756c44                  db "PainfulDiodes\n"
              696f6465730a      
   275  01fc  4d415256494e205a                  db "MARVIN Z80 monitor\n"
              3830206d6f6e6974  
              6f720a            
   276  020f  76312e312e626574                  db "v1.1.beta\n",0
              610a00            
   277                          
   278                          bad_cmd_msg:
   279  021a  436f6d6d616e6420                  db "Command not recognised\n",0
              6e6f74207265636f  
              676e697365640a00  
   280                          
   281                          cmd_w_null_msg:
   282  0232  4e6f206461746120                  db "No data to write\n",0
              746f207772697465  
              0a00              
   283                          
beanboard-ram.asm:
    35                          include "strings.asm"
strings.asm:
     1                          ; string subroutines
     2                          
     3                          ; read 2 ASCII hex chars from memory by HL pointer, return converted value in A and advance HL pointer
     4                          hex_byte_val:
     5                              ; preserve BC
     6  0244  c5                    push bc
     7                              ; load 1st character from memory
     8  0245  7e                    ld a,(hl)
     9                              ; end of string?
    10  0246  fe00                  cp 0
    11                              ; yes: no value - return zero
    12  0248  2819                  jr z,_hex_byte_val_zero
    13                              ; no:
    14                              ; advance the buffer pointer
    15  024a  23                    inc hl
    16                              ; convert first hex digit
    17  024b  cd6702                call hex_val
    18                              ; shift left 4 bits to put value into top nibble
    19  024e  cb27                  sla a
    20  0250  cb27                  sla a
    21  0252  cb27                  sla a
    22  0254  cb27                  sla a
    23                              ; cache the result
    24  0256  47                    ld b,a
    25                              ; load 2nd character from memory
    26  0257  7e                    ld a,(hl)
    27                              ; end of string?
    28  0258  fe00                  cp 0
    29                              ; yes: incomplete byte - return zero
    30  025a  2807                  jr z,_hex_byte_val_zero
    31                              ; advance the buffer pointer
    32  025c  23                    inc hl
    33                              ; and convert 2nd hex digit
    34  025d  cd6702                call hex_val
    35                              ; add first and second digits
    36  0260  80                    add a,b
    37                              ; restore BC
    38  0261  c1                    pop bc
    39  0262  c9                    ret
    40                          _hex_byte_val_zero:
    41                              ; zero return value
    42  0263  3e00                  ld a,0
    43                              ; restore BC
    44  0265  c1                    pop bc
    45  0266  c9                    ret
    46                          
    47                          ; convert an ASCII hex char in A to a number value (lower 4 bits)
    48                          hex_val:
    49                              ; is it lowercase alphabetic?
    50  0267  fe61                  cp 'a'
    51                              ; no: uppercase/numeric
    52  0269  3803                  jr c,_hex_val_u_n
    53                              ; yes: alphabetic
    54  026b  d657                  sub 'a'-0x0a
    55  026d  c9                    ret
    56                          _hex_val_u_n:
    57                              ; is it uppercase alphabetic?
    58  026e  fe41                  cp 'A'
    59                              ; no: numeric
    60  0270  3803                  jr c,_hex_val_n
    61                              ; y:
    62  0272  d637                  sub 'A'-0x0a
    63  0274  c9                    ret
    64                          _hex_val_n:
    65                              ; numeric
    66  0275  d630                  sub '0'
    67  0277  c9                    ret
    68                          
    69                          ; convert value in A into an ASCII pair and send to console
    70                          putchar_hex:
    71  0278  f5                    push af
    72  0279  c5                    push bc
    73                              ; stash in B
    74  027a  47                    ld b,a
    75                              ; shift A right x4 e.g. transform 10110010 to 00001011
    76  027b  cb3f                  srl a
    77  027d  cb3f                  srl a
    78  027f  cb3f                  srl a
    79  0281  cb3f                  srl a
    80                              ; most significant digit
    81  0283  cd8f02                call _putchar_hex_dgt
    82                              ; recover from stash
    83  0286  78                    ld a,b
    84                              ; clear the top 4 bits
    85  0287  e60f                  and %00001111
    86                              ; least significant digit
    87  0289  cd8f02                call _putchar_hex_dgt
    88  028c  c1                    pop bc
    89  028d  f1                    pop af
    90  028e  c9                    ret
    91                          _putchar_hex_dgt:
    92                              ; is it an alpha or numeric?
    93  028f  fe0a                  cp 0x0a
    94                              ; numeric
    95  0291  3806                  jr c,_putchar_hex_n
    96                              ; alpha
    97                              ; for alpha add the base ascii for 'a' but then sub 10 / 0x0a as hex 'a' = 10d
    98  0293  c657                  add a,'a'-0x0a
    99  0295  cd3000                call putchar
   100  0298  c9                    ret
   101                          _putchar_hex_n:
   102                              ; for numeric add the base ascii for '0'
   103  0299  c630                  add a,'0'
   104  029b  cd3000                call putchar
   105  029e  c9                    ret
   106                          
beanboard-ram.asm:
    36                          include "HD44780LCD.asm"
HD44780LCD.asm:
     1                          LCD_COMMAND_0 equ LCD_FUNCTION_SET+LCD_DATA_LEN_8+LCD_DISP_LINES_2+LCD_FONT_8
     2                          LCD_COMMAND_1 equ LCD_DISPLAY_ON_OFF_CONTROL+LCD_DISPLAY_ON+LCD_CURSOR_ON+LCD_BLINK_ON
     3                          
     4                          lcd_init:
     5                          ; preserve registers
     6  029f  f5                    push af
     7                          ; intitialise device
     8  02a0  3e38              	ld a,LCD_COMMAND_0
     9  02a2  cdb602            	call lcd_putcmd
    10  02a5  3e0f              	ld a,LCD_COMMAND_1
    11  02a7  cdb602            	call lcd_putcmd
    12  02aa  3e01              	ld a,LCD_CLEAR_DISPLAY
    13  02ac  cdb602            	call lcd_putcmd
    14  02af  3e00                  ld a,0
    15  02b1  cdcc02                call lcd_putchar
    16                          ; restore registers
    17  02b4  f1                    pop af
    18  02b5  c9                    ret
    19                          
    20                          ; transmit character in A to the control port
    21                          lcd_putcmd:
    22  02b6  c5                    push bc
    23                          ; save the transmit character
    24  02b7  47                    ld b,a
    25                          _lcd_putcmd_loop:
    26                          ; get the LCD status
    27  02b8  db04                  in a,(LCD_CTRL)
    28                          ; busy ?
    29  02ba  cb7f                  bit 7,a
    30                          ; yes
    31  02bc  20fa                  jr nz,_lcd_putcmd_loop
    32                          ; no, restore the transmit character
    33  02be  78                    ld a,b
    34                          ; transmit the character
    35  02bf  d304                  out (LCD_CTRL),a
    36  02c1  c1                    pop bc
    37  02c2  c9                    ret
    38                          
    39                          ; get character from data port and return in A
    40                          lcd_getchar:
    41                          ; get the LCD status
    42  02c3  db04                  in a,(LCD_CTRL)
    43                          ; busy ?
    44  02c5  cb7f                  bit 7,a
    45                          ; yes
    46  02c7  20fa                  jr nz,lcd_getchar
    47                          ; no, get a character
    48  02c9  db05                  in a,(LCD_DATA)
    49  02cb  c9                    ret
    50                          
    51                          ; transmit character in A to the data port
    52                          lcd_putchar:
    53                              ; newline char?
    54  02cc  fe0a                  cp ESC_N
    55  02ce  c2ec02                jp nz,_lcd_putchar_printable
    56                              ; newline - fill out the line until EOL
    57                          _lcd_putchar_pad:
    58  02d1  3e20                  ld a,' '
    59  02d3  cd2403                call lcd_putdata
    60  02d6  fe13                  cp LCD_EOL_0
    61  02d8  ca0603                jp z,_lcd_putchar_eol0
    62  02db  fe53                  cp LCD_EOL_1
    63  02dd  ca0d03                jp z,_lcd_putchar_eol1
    64  02e0  fe27                  cp LCD_EOL_2
    65  02e2  ca1403                jp z,_lcd_putchar_eol2
    66  02e5  fe67                  cp LCD_EOL_3
    67  02e7  ca1b03                jp z,_lcd_putchar_eol3
    68                              ; loop until EOL
    69  02ea  18e5                  jr _lcd_putchar_pad
    70                          _lcd_putchar_printable:
    71  02ec  cd2403                call lcd_putdata
    72                              ; check for overflow - DDRAM address returned in A
    73  02ef  fe13                  cp LCD_EOL_0
    74  02f1  ca0603                jp z,_lcd_putchar_eol0
    75  02f4  fe53                  cp LCD_EOL_1
    76  02f6  ca0d03                jp z,_lcd_putchar_eol1
    77  02f9  fe27                  cp LCD_EOL_2
    78  02fb  ca1403                jp z,_lcd_putchar_eol2
    79  02fe  fe67                  cp LCD_EOL_3
    80  0300  ca1b03                jp z,_lcd_putchar_eol3
    81  0303  c32303                jp _lcd_putchar_end
    82                          _lcd_putchar_eol0:
    83  0306  3ec0                  ld a,LCD_SET_DDRAM_ADDR+LCD_LINE_1_ADDR
    84  0308  cdb602            	call lcd_putcmd
    85  030b  1816                  jr _lcd_putchar_end
    86                          _lcd_putchar_eol1:
    87  030d  3e94                  ld a,LCD_SET_DDRAM_ADDR+LCD_LINE_2_ADDR
    88  030f  cdb602            	call lcd_putcmd
    89  0312  180f                  jr _lcd_putchar_end
    90                          _lcd_putchar_eol2:
    91  0314  3ed4                  ld a,LCD_SET_DDRAM_ADDR+LCD_LINE_3_ADDR
    92  0316  cdb602            	call lcd_putcmd
    93  0319  1808                  jr _lcd_putchar_end
    94                          _lcd_putchar_eol3:
    95  031b  cd3503                call lcd_scroll
    96  031e  3ed4                  ld a,LCD_SET_DDRAM_ADDR+LCD_LINE_3_ADDR
    97  0320  cdb602            	call lcd_putcmd
    98                          _lcd_putchar_end:
    99  0323  c9                    ret
   100                          
   101                          ; transmit character in A to the data port,
   102                          ; return in A the DDRAM address where the character was sent
   103                          lcd_putdata:
   104  0324  c5                    push bc
   105                              ; save the transmit character
   106  0325  47                    ld b,a
   107                          _lcd_putdata_loop:
   108                              ; get the LCD status
   109  0326  db04                  in a,(LCD_CTRL)
   110                              ; busy ?
   111  0328  cb7f                  bit 7,a
   112                              ; yes
   113  032a  20fa                  jr nz,_lcd_putdata_loop
   114                              ; no, reset the 'busy' bit and preserve the DDRAM address
   115  032c  e67f                  and %01111111
   116  032e  4f                    ld c,a
   117                              ; restore the transmit character and send it
   118  032f  78                    ld a,b
   119  0330  d305                  out (LCD_DATA),a
   120                              ; restore the DDRAM address
   121  0332  79                    ld a,c
   122  0333  c1                    pop bc
   123  0334  c9                    ret
   124                          
   125                          lcd_scroll:
   126  0335  c5                    push bc
   127  0336  d5                    push de
   128  0337  16c0                  ld d,LCD_SET_DDRAM_ADDR+LCD_LINE_1_ADDR
   129  0339  1e80                  ld e,LCD_SET_DDRAM_ADDR+LCD_LINE_0_ADDR
   130  033b  cd5403                call _lcd_scroll_line
   131  033e  1694                  ld d,LCD_SET_DDRAM_ADDR+LCD_LINE_2_ADDR
   132  0340  1ec0                  ld e,LCD_SET_DDRAM_ADDR+LCD_LINE_1_ADDR
   133  0342  cd5403                call _lcd_scroll_line
   134  0345  16d4                  ld d,LCD_SET_DDRAM_ADDR+LCD_LINE_3_ADDR
   135  0347  1e94                  ld e,LCD_SET_DDRAM_ADDR+LCD_LINE_2_ADDR
   136  0349  cd5403                call _lcd_scroll_line
   137  034c  3ed4                  ld a,LCD_SET_DDRAM_ADDR+LCD_LINE_3_ADDR
   138  034e  cd6d03                call _lcd_scroll_clear_line
   139  0351  d1                    pop de
   140  0352  c1                    pop bc
   141  0353  c9                    ret
   142                          _lcd_scroll_line:
   143                              ; b = character counter
   144                              ; c = stash char
   145                              ; d = source line to copy from
   146                              ; e = destination line to copy to
   147  0354  0614                  ld b,LCD_LINE_LEN
   148                          _lcd_scroll_line_loop:
   149                              ; load source
   150  0356  7a                    ld a,d
   151                              ; character counter is an offset
   152  0357  80                    add b
   153                              ; zero based index so -1
   154  0358  3d                    dec a
   155  0359  cdb602                call lcd_putcmd
   156  035c  cdc302                call lcd_getchar
   157                              ; stash the value
   158  035f  4f                    ld c,a
   159                              ; load destination
   160  0360  7b                    ld a,e
   161                              ; character counter is an offset
   162  0361  80                    add b
   163                              ; zero based index so -1
   164  0362  3d                    dec a
   165  0363  cdb602                call lcd_putcmd
   166                              ; recover the stashed value
   167  0366  79                    ld a,c
   168  0367  cd2403                call lcd_putdata
   169  036a  10ea                  djnz _lcd_scroll_line_loop
   170  036c  c9                    ret
   171                          _lcd_scroll_clear_line:
   172                              ; a = destination line to clear
   173                              ; b = character counter
   174  036d  0614                  ld b,LCD_LINE_LEN
   175  036f  cdb602                call lcd_putcmd
   176                          _lcd_scroll_clear_line_loop:
   177  0372  3e20                  ld a,' '
   178  0374  cd2403                call lcd_putdata
   179  0377  10f9                  djnz _lcd_scroll_clear_line_loop
   180  0379  c9                    ret
   181                          
beanboard-ram.asm:
    37                          include "keyscan.asm"
keyscan.asm:
     1                          DEBOUNCE_DELAY equ 0xf0
     2                          MOD_KEY_SHIFT_L equ %00000010
     3                          MOD_KEY_SHIFT_R equ %00000001
     4                          
     5                          ; initialise keyscan
     6                          keyscan_init:
     7  037a  c5                    push bc
     8  037b  e5                    push hl
     9  037c  0608                  ld b,8
    10  037e  2100f0                ld hl,KEYSCAN_BUFFER
    11                          _keyscan_init_loop:
    12  0381  3600                  ld (hl),0
    13  0383  23                    inc hl
    14  0384  10fb                  djnz _keyscan_init_loop
    15                              ; end
    16  0386  e1                    pop hl
    17  0387  c1                    pop bc
    18  0388  c9                    ret
    19                          
    20                          ; return value in A
    21                          keyscan:
    22  0389  c5                    push bc
    23  038a  d5                    push de
    24  038b  e5                    push hl
    25                              ; initial row bit - only 1 bit is ever set at a time - it is shifted from bit 0 to bit 7
    26  038c  0601                  ld b,0x01
    27                              ; row counter - 0 => 7
    28  038e  0e00                  ld c,0x00
    29                              ; location of previous values
    30  0390  2100f0                ld hl,KEYSCAN_BUFFER
    31  0393  cdc903                call _modifierkeys
    32                              ; initialise map pointer
    33  0396  11fb03                ld de,QWERTY_KEYMAP_L
    34                              ; either shift key down?
    35  0399  e603                  and MOD_KEY_SHIFT_L+MOD_KEY_SHIFT_R
    36  039b  caa103                jp z,_keyscanloop
    37  039e  113b04                ld de,QWERTY_KEYMAP_U
    38                          _keyscanloop:
    39  03a1  cdbc03                call _rowscan
    40                              ; ASCII returned in A, or 0
    41  03a4  cde603                call _colscan
    42  03a7  fe00                  cp 0
    43  03a9  c2b303                jp nz,_delay
    44                              ; move the pointer of previous values to the next row slot
    45  03ac  23                    inc hl
    46                              ; increment row counter
    47  03ad  0c                    inc c
    48                              ; clear the carry flag
    49  03ae  b7                    or a
    50                              ; shift row bit left - when we've done all 8, it will move to the carry flag
    51  03af  cb10                  rl b
    52                              ; loop if not done all rows
    53  03b1  30ee                  jr nc,_keyscanloop
    54                              ; key debounce
    55                          _delay:
    56                              ; set a to the length of the delay
    57  03b3  06f0                  ld b,DEBOUNCE_DELAY
    58                          _delayloop:
    59                              ; wait a few cycles
    60  03b5  00                    nop
    61                              ; no - loop again
    62  03b6  10fd                  djnz _delayloop
    63                          ; end
    64  03b8  e1                    pop hl
    65  03b9  d1                    pop de
    66  03ba  c1                    pop bc
    67  03bb  c9                    ret
    68                          
    69                          ; get row bitmap representing new keystrokes:
    70                          ; B contains row bit,
    71                          ; C contains row count,
    72                          ; HL contains a pointer to the old value.
    73                          ; return value in A
    74                          _rowscan:
    75                              ; preserve registers
    76  03bc  d5                    push de
    77                              ; fetch previous value for comparison
    78  03bd  7e                    ld a,(hl)
    79                              ; invert A - we want to check keys becoming closed - so zeroed bits on the previous value are significant
    80  03be  2f                    cpl
    81                              ; store inverted previous value
    82  03bf  57                    ld d,a
    83                              ; get the current row bit
    84  03c0  78                    ld a,b
    85                              ; output row strobe
    86  03c1  d302                  out (KEYSCAN_OUT),a
    87                              ; get column values
    88  03c3  db03                  in a,(KEYSCAN_IN)
    89                              ; store the new value
    90  03c5  77                    ld (hl),a
    91                              ; newVal AND ~oldVal means bits are set only when the previous bit value was 0
    92  03c6  a2                    and d
    93                              ; restore registers
    94  03c7  d1                    pop de
    95  03c8  c9                    ret
    96                          
    97                          ; get bitmap representing modifier keys:
    98                          ; return value in A
    99                          _modifierkeys:
   100  03c9  3e40                  ld a,%01000000 ; row 7
   101                              ; output row strobe
   102  03cb  d302                  out (KEYSCAN_OUT),a
   103                              ; get column values
   104  03cd  db03                  in a,(KEYSCAN_IN)
   105  03cf  e601                  and %00000001 ; row 7, bit 1 is LEFT SHIFT
   106                              ; left shift modifier
   107  03d1  200d                  jr nz,_modifier_l_shift
   108  03d3  3e80                  ld a,%10000000 ; row 8
   109                              ; output row strobe
   110  03d5  d302                  out (KEYSCAN_OUT),a
   111                              ; get column values
   112  03d7  db03                  in a,(KEYSCAN_IN)
   113  03d9  e610                  and %00010000 ; row 8, bit 5 is RIGHT SHIFT
   114                              ; left shift modifier
   115  03db  2006                  jr nz,_modifier_r_shift
   116                              ; no modifiers
   117  03dd  3e00                  ld a,0
   118  03df  c9                    ret
   119                          _modifier_l_shift:
   120  03e0  3e02                  ld a,MOD_KEY_SHIFT_L
   121  03e2  c9                    ret
   122                          _modifier_r_shift:
   123  03e3  3e01                  ld a,MOD_KEY_SHIFT_R
   124  03e5  c9                    ret
   125                          
   126                          ; A contains row bitmap representing new keystrokes,
   127                          ; DE contains a pointer to the ASCII map for the row - which is incremented in the subroutine
   128                          ; first printable character returned in A
   129                          _colscan:
   130                              ; preserve registers
   131  03e6  c5                    push bc
   132                              ; initialise col bit mask - only 1 bit is ever set at a time - it is shifted from bit 0 to bit 7
   133  03e7  0e01                  ld c,0x01
   134                              ; stash the bitmap
   135  03e9  47                    ld b,a
   136                          _colscanloop:
   137                              ; reload the bitmap
   138  03ea  78                    ld a,b
   139                              ; mask the bitmap - use the column mask (C) over the bitmap value in A
   140  03eb  a1                    and c
   141                              ; if zero then no keypress
   142  03ec  2805                  jr z,_colscanloopnext
   143  03ee  1a                    ld a,(de)
   144                              ; ASCII is 0?
   145  03ef  fe00                  cp 0
   146  03f1  2006                  jr nz,_colscanend
   147                          _colscanloopnext:
   148                              ; increment character map pointer
   149  03f3  13                    inc de
   150                              ; clear the carry flag
   151  03f4  b7                    or a
   152                              ; shift row bit left - when we've done all 8, it will move to the carry flag
   153  03f5  cb11                  rl c
   154                              ; loop if not done all rows
   155  03f7  30f1                  jr nc,_colscanloop
   156                          _colscanend:
   157                              ; restore registers
   158  03f9  c1                    pop bc
   159  03fa  c9                    ret
   160                          
   161                          ; define values for control keys
   162                          ; modifiers have zero value
   163                          QWERTY_SHIFT_L equ 0
   164                          QWERTY_SHIFT_R equ 0
   165                          QWERTY_FN equ 0
   166                          QWERTY_CTRL equ 0
   167                          QWERTY_ALT equ 0
   168                          QWERTY_CMD equ 0
   169                          QWERTY_CURS_UP equ 1
   170                          QWERTY_CURS_DOWN equ 2
   171                          QWERTY_CURS_LEFT equ 3
   172                          QWERTY_CURS_RIGHT equ 4
   173                          QWERTY_CAPS equ 5
   174                          QWERTY_UNDEFINED equ 12
   175                          
   176                          QWERTY_KEYMAP_L:
   177  03fb  1b31323334353637      db ESC_E,'1','2','3','4','5','6','7'
   178  0403  3839302d3d080102      db '8','9','0','-','=',ESC_B,QWERTY_CURS_UP,QWERTY_CURS_DOWN
   179  040b  0971776572747975      db ESC_T,'q','w','e','r','t','y','u'
   180  0413  696f705b5d0a0304      db 'i','o','p','[',']',ESC_N,QWERTY_CURS_LEFT,QWERTY_CURS_RIGHT
   181  041b  056173646667686a      db QWERTY_CAPS,'a','s','d','f','g','h','j'
   182  0423  6b6c3b275c000000      db 'k','l',';',QUOTE,SLASH,QWERTY_FN,QWERTY_CTRL,QWERTY_ALT
   183  042b  00607a786376626e      db QWERTY_SHIFT_L,'`','z','x','c','v','b','n'
   184  0433  6d2c2e2f0000200c      db 'm',',','.','/',QWERTY_SHIFT_R,QWERTY_CMD,' ',QWERTY_UNDEFINED
   185                          QWERTY_KEYMAP_U:
   186  043b  1b21402324255e26      db ESC_E,'!','@','#','$','%','^','&'
   187  0443  2a28295f2b080102      db '*','(',')','_','+',ESC_B,QWERTY_CURS_UP,QWERTY_CURS_DOWN
   188  044b  0951574552545955      db ESC_T,'Q','W','E','R','T','Y','U'
   189  0453  494f507b7d0a0304      db 'I','O','P','{','}',ESC_N,QWERTY_CURS_LEFT,QWERTY_CURS_RIGHT
   190  045b  054153444647484a      db QWERTY_CAPS,'A','S','D','F','G','H','J'
   191  0463  4b4c3a227c000000      db 'K','L',':','"','|',QWERTY_FN,QWERTY_CTRL,QWERTY_ALT
   192  046b  007e5a584356424e      db QWERTY_SHIFT_L,'~','Z','X','C','V','B','N'
   193  0473  4d3c3e3f0000200c      db 'M','<','>','?',QWERTY_SHIFT_R,QWERTY_CMD,' ',QWERTY_UNDEFINED
   194                          
beanboard-ram.asm:
    38                          
