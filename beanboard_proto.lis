beanboard_proto.asm:
     1                          ; MARVIN build for BeanZee with BeanBoard
     2                          ; https://github.com/PainfulDiodes/BeanZee
     3                          ; https://github.com/PainfulDiodes/BeanBoard
     4                          
     5                          BEANBOARD EQU 1
     6                          
     7                          IFDEF ORGDEF
     8                              ORG ORGDEF
     9                          ELSE
    10                              ORG 0x0000
    11                          ENDIF
    12                          
    13                          ; start of user RAM
    14                          RAMSTART equ 0x8000
    15                          ; input buffer - start of system RAM
    16                          CMD_BUFFER equ 0xf010
    17                          ; this should really be 0x0000 as the CPU will dec SP before PUSH
    18                          STACK equ 0xffff
    19                          ; 8-byte keyscan buffer
    20                          KEYSCAN_BUFFER equ 0xf000
    21                          
    22                          UM245R_CTRL equ 0 ; serial control port
    23                          UM245R_DATA equ 1 ; serial data port
    24                          KEYSCAN_OUT equ 2 ; either 2 or 3 will work
    25                          KEYSCAN_IN  equ 3 ; either 2 or 3 will work
    26                          LCD_CTRL    equ 4 ; LCD control port
    27                          LCD_DATA    equ 5 ; LCD data port
    28                          
    29  0000  31ffff                ld sp, STACK
    30  0003  cd6002                call lcd_init
    31  0006  cd7003                call keyscan_init
    32  0009  c39000                jp start
    33                          
    34                          include "asm/escapestring.inc"
asm/escapestring.inc:
     1                          ; escape character constants for assembler compatibility
     2                          ; sjasmplus requires double quotes around escape sequences: "\n" and would not interpret '\n' but truncate
     3                          ; z88dk-z80asm requires single quotes around so would correctly interpret '\n' but reject "\n"
     4                          
     5                          ESC_B equ 0x08 ; \b
     6                          ESC_T equ 0x09 ; \t
     7                          ESC_N equ 0x0a ; \n
     8                          ESC_R equ 0x0d ; \r
     9                          ESC_E equ 0x1b ; \e
    10                          SLASH equ 0x5c ; \\
    11                          QUOTE equ 0x27 ; \'
    12                          
beanboard_proto.asm:
    35                          include "asm/HD44780LCD.inc"
asm/HD44780LCD.inc:
     1                          ; LCD commands
     2                          LCD_CLEAR_DISPLAY equ 0x01
     3                          LCD_RETURN_HOME equ 0x02
     4                          LCD_ENTRY_MODE_SET equ 0x04
     5                          LCD_DISPLAY_ON_OFF_CONTROL equ 0x08
     6                          LCD_CURSOR_DISPLAY_SHIFT equ 0x10
     7                          LCD_FUNCTION_SET equ 0x20
     8                          LCD_SET_CGRAM_ADDR equ 0x40
     9                          LCD_SET_DDRAM_ADDR equ 0x80
    10                          
    11                          ; LCD_ENTRY_MODE_SET options
    12                          LCD_ENTRY_INC equ 0x02 ; left
    13                          LCD_ENTRY_DEC equ 0x00 ; right
    14                          LCD_ENTRY_SHIFT equ 0x01
    15                          LCD_ENTRY_NO_SHIFT equ 0x00
    16                          
    17                          ; LCD_DISPLAY_ON_OFF_CONTROL options
    18                          LCD_DISPLAY_ON equ 0x04
    19                          LCD_DISPLAY_OFF equ 0x00
    20                          LCD_CURSOR_ON equ 0x02
    21                          LCD_CURSOR_OFF equ 0x00
    22                          LCD_BLINK_ON equ 0x01
    23                          LCD_BLINK_OFF equ 0x00
    24                          
    25                          ; LCD_CURSOR_DISPLAY_SHIFT options
    26                          LCD_SHIFT_DISPLAY equ 0x08
    27                          LCD_SHIFT_CURSOR equ 0x00
    28                          LCD_SHIFT_RIGHT equ 0x04
    29                          LCD_SHIFT_LEFT equ 0x00
    30                          
    31                          ; LCD_FUNCTION_SET options
    32                          LCD_DATA_LEN_8 equ 0x10
    33                          LCD_DATA_LEN_4 equ 0x00
    34                          LCD_DISP_LINES_2 equ 0x08
    35                          LCD_DISP_LINES_1 equ 0x00
    36                          LCD_FONT_10 equ 0x04
    37                          LCD_FONT_8 equ 0x00
    38                          
    39                          LCD_LINE_LEN equ 0x14
    40                          LCD_NUM_LINES equ 4
    41                          LCD_BUFFER_LEN equ LCD_LINE_LEN*LCD_NUM_LINES
    42                          
    43                          ; LCD_SET_DDRAM_ADDR options
    44                          LCD_LINE_0_ADDR equ 0x00
    45                          LCD_LINE_1_ADDR equ 0x40
    46                          LCD_LINE_2_ADDR equ 0x00+LCD_LINE_LEN
    47                          LCD_LINE_3_ADDR equ 0x40+LCD_LINE_LEN
    48                          LCD_EOL_0 equ 0x00+LCD_LINE_LEN-1
    49                          LCD_EOL_1 equ 0x40+LCD_LINE_LEN-1
    50                          LCD_EOL_2 equ 0x00+LCD_LINE_LEN*2-1
    51                          LCD_EOL_3 equ 0x40+LCD_LINE_LEN*2-1
    52                          
beanboard_proto.asm:
    36                          include "asm/console.asm"
asm/console.asm:
     1  000c  00000000          ALIGN 0x10
     2                          
     3                          ; wait for a character and return in A
     4                          getchar:
     5  0010  cd2000                call readchar
     6  0013  fe00                  cp 0
     7  0015  c0                    ret nz
     8  0016  18f8                  jr getchar
     9                          
    10  0018  0000000000000000  ALIGN 0x10
    11                          
    12                          ; read a character from the console and return it,
    13                          ; or 0 if there is no character
    14                          readchar:
    15                          IF BEANBOARD
    16                              ; check keyboard
    17  0020  cd8003                call keyscan
    18                              ; is there a character?
    19  0023  fe00                  cp 0
    20                              ; yes: return it
    21  0025  c0                    ret nz
    22                              ; no:
    23                          ENDIF
    24                              ; check usb
    25  0026  cd5000                call usb_readchar
    26                              ; return the result - 0 if no char
    27  0029  c9                    ret
    28                          
    29  002a  000000000000      ALIGN 0x10
    30                          
    31                          putchar:
    32                          IF BEANBOARD
    33                              ; A is not guaranteed to be preserved in these calls,
    34                              ; so preserve across the first call
    35  0030  f5                    push af
    36  0031  cda002                call lcd_putchar
    37  0034  f1                    pop af
    38                          ENDIF
    39  0035  cd7000                call usb_putchar
    40  0038  c9                    ret
    41                          
    42  0039  00000000000000    ALIGN 0x10
    43                          
    44                          ; print a zero-terminated string, pointed to by hl
    45                          puts:
    46  0040  e5                    push hl
    47                          _puts_loop:
    48                              ; get character from string
    49  0041  7e                    ld a,(hl)
    50                              ; is it zero?
    51  0042  fe00                  cp 0
    52                              ; yes
    53  0044  2807                  jr z, _puts_end
    54                              ; no: send character
    55  0046  cd3000                call putchar
    56                              ; next character position
    57  0049  23                    inc hl
    58                              ; loop for next character
    59  004a  c34100                jp _puts_loop
    60                          _puts_end:
    61  004d  e1                    pop hl
    62  004e  c9                    ret
    63                          
beanboard_proto.asm:
    37                          include "asm/UM245R.asm"
asm/UM245R.asm:
     1                          ; It is assumed that UM245R status signals are gated to the data bus as an IO port where:
     2                          ; /TXE = bit 0
     3                          ; /RXF = bit 1
     4                          ; As per:
     5                          ; https://github.com/PainfulDiodes/z80-breadboard-computer
     6                          ;
     7                          ; line endings are translated:
     8                          ; incoming line endings from the terminal are expected to be \r
     9                          ; and are tranlslated to \n
    10                          ; (\r\n would count as 2 line endings)
    11                          ; and outgoing line endings are sent as \r\n
    12                          ; externally this is consistent with VT100/ANSI terminal behaviour
    13                          ; and internally line endings are always \n
    14                          
    15  004f  00                ALIGN 0x10
    16                          
    17                          ; get character and return in A
    18                          usb_readchar:
    19                              ; get the USB status
    20  0050  db00                  in a,(UM245R_CTRL)
    21                              ; data to read? (active low)
    22  0052  cb4f                  bit 1,a
    23                              ; no, the buffer is empty
    24  0054  2008                  jr nz,_usb_no_char
    25                              ; yes, read the received char
    26  0056  db01                  in a,(UM245R_DATA)
    27                              ; is CR?
    28  0058  fe0d                  cp ESC_R
    29                              ; no:
    30  005a  c0                    ret nz
    31                              ; yes: convert CR to LF
    32  005b  3e0a                  ld a, ESC_N
    33  005d  c9                    ret
    34                          _usb_no_char:
    35  005e  3e00                  ld a,0
    36  0060  c9                    ret
    37                          
    38  0061  0000000000000000  ALIGN 0x10
              00000000000000    
    39                          
    40                          usb_putchar:
    41                              ; newline?
    42  0070  fe0a                  cp ESC_N
    43                              ; no: just send the char
    44  0072  2007                  jr nz,_do_usb_put
    45  0074  3e0d                  ld a, ESC_R
    46  0076  cd7f00                call _usb_put
    47  0079  3e0a                  ld a, ESC_N
    48                          _do_usb_put:
    49  007b  cd7f00                call _usb_put
    50  007e  c9                    ret
    51                          
    52                          ; transmit character in A
    53                          _usb_put:
    54  007f  c5                    push bc
    55                              ; stash the transmit character
    56  0080  47                    ld b,a
    57                          _usb_put_loop:
    58                              ; get the USB status
    59  0081  db00                  in a,(UM245R_CTRL)
    60                              ; ready to transmit? (active low)
    61  0083  cb47                  bit 0,a
    62                              ; no: bit is high
    63  0085  20fa                  jr nz,_usb_put_loop
    64                              ; yes: restore the stashed transmit character
    65  0087  78                    ld a,b
    66                              ; transmit the character
    67  0088  d301                  out (UM245R_DATA),a
    68  008a  c1                    pop bc
    69  008b  c9                    ret
    70                          
beanboard_proto.asm:
    38                          include "asm/marvin.asm"
asm/marvin.asm:
     1                          ; ****************************************************
     2                          ; *  Marvin - a Z80 homebrew monitor program
     3                          ; * (c) Stephen Willcock 2024
     4                          ; * https://github.com/PainfulDiodes
     5                          ; ****************************************************
     6                          
     7                          ; MAIN PROGRAM LOOP
     8                          
     9  008c  00000000          ALIGN 0x10
    10                          
    11                          start:
    12                              ; point DE to zero - this is the default address argument for commands
    13  0090  110000                ld de,0x0000
    14                          
    15  0093  219101                ld hl,welcome_msg
    16  0096  cd4000                call puts
    17                          
    18  0099  00000000000000    ALIGN 0x10
    19                          
    20                          prompt:
    21                              ; point HL to the beginning of the input buffer
    22  00a0  2110f0                ld hl,CMD_BUFFER
    23  00a3  3e3e                  ld a,'>'
    24  00a5  cd3000                call putchar
    25                          
    26                          _get_cmd:
    27                              ; get character from console
    28  00a8  cd1000                call getchar
    29                              ; echo the character to console
    30  00ab  cd3000                call putchar
    31                              ; is CR?
    32  00ae  fe0d                  cp ESC_R
    33                              ; yes: skip this
    34  00b0  28f6                  jr z,_get_cmd
    35                              ; is tab?
    36  00b2  fe09                  cp ESC_T
    37                              ; yes: skip this
    38  00b4  28f2                  jr z,_get_cmd
    39                              ; is space?
    40  00b6  fe20                  cp ' '
    41                              ; yes - skip this
    42  00b8  28ee                  jr z,_get_cmd
    43                              ; escape?
    44  00ba  fe1b                  cp ESC_E
    45                              ; yes
    46  00bc  2808                  jr z, _get_cmd_esc
    47                              ; end of line?
    48  00be  fe0a                  cp ESC_N
    49                              ; yes
    50  00c0  280b                  jr z, _get_cmd_end
    51                              ; no: add character to the buffer
    52  00c2  77                    ld(hl),a
    53                              ; move pointer to next buffer location - we're not checking for overrun
    54  00c3  23                    inc hl
    55                              ; next character
    56  00c4  18e2                  jr _get_cmd
    57                              ; do escape
    58                          _get_cmd_esc:
    59                              ; new line
    60  00c6  3e0a                  ld a,ESC_N
    61  00c8  cd3000                call putchar
    62                              ; back to prompt
    63  00cb  18d3                  jr prompt
    64                          _get_cmd_end:
    65                              ; string terminator
    66  00cd  3e00                  ld a,0
    67                              ; add terminator to end of buffer
    68  00cf  77                    ld(hl),a
    69                          ; process command from buffer
    70                              ; point to start of buffer
    71  00d0  2110f0                ld hl,CMD_BUFFER
    72                              ; load character from buffer
    73  00d3  7e                    ld a,(hl)
    74                              ; end of string?
    75  00d4  fe00                  cp 0
    76                              ; yes - empty line - go back to prompt
    77  00d6  28c8                  jr z,prompt
    78                              ; advance the buffer pointer
    79  00d8  23                    inc hl
    80  00d9  fe72                  cp 'r'
    81  00db  2815                  jr z,_cmd_read
    82  00dd  fe77                  cp 'w'
    83  00df  2847                  jr z,_cmd_write
    84  00e1  fe78                  cp 'x'
    85  00e3  2868                  jr z,_cmd_execute
    86                              ; ':' = load from intel hex format
    87  00e5  fe3a                  cp ':'
    88  00e7  2879                  jr z,_cmd_load
    89                              ; otherwise error
    90  00e9  21bd01                ld hl,bad_cmd_msg
    91  00ec  cd4000                call puts
    92                              ; loop back to the prompt
    93  00ef  c3a000                jp prompt
    94                          
    95                          ; COMMANDS
    96                          
    97                          ; READ
    98                          ; read bytes from memory and send hex values to console
    99                          _cmd_read:
   100                              ; load character from buffer
   101  00f2  7e                    ld a,(hl)
   102                              ; end of string?
   103  00f3  fe00                  cp 0
   104                              ; yes: no address argument, so skip to read row
   105  00f5  2808                  jr z, _cmd_read_row
   106                              ; parse first pair of characters
   107  00f7  cde001                call hex_byte_val
   108                              ; load into upper byte of memory pointer
   109  00fa  57                    ld d,a
   110                              ; parse second pair of characters
   111  00fb  cde001                call hex_byte_val
   112                              ; load into lower byte of memory pointer
   113  00fe  5f                    ld e,a
   114                          _cmd_read_row:
   115                              ; initialise byte counter - each row will have this many bytes
   116  00ff  0e10                  ld c, 0x10
   117                              ; print DE content: the read address
   118  0101  7a                    ld a,d
   119  0102  cd3002                call putchar_hex
   120  0105  7b                    ld a,e
   121  0106  cd3002                call putchar_hex
   122                              ; separator between address and data
   123  0109  3e3a                  ld a,':'
   124  010b  cd3000                call putchar
   125  010e  3e20                  ld a,' '
   126  0110  cd3000                call putchar
   127                              ; get a byte
   128                          _cmd_read_byte:
   129  0113  1a                    ld a,(de)
   130                              ; and print it
   131  0114  cd3002                call putchar_hex
   132                              ; add space between bytes
   133  0117  3e20                  ld a,' '
   134  0119  cd3000                call putchar
   135                              ; next address
   136  011c  13                    inc de
   137                              ; reduce byte counter
   138                              ; TODO djnz ?
   139  011d  0d                    dec c
   140                              ; repeat if the counter is not 0
   141  011e  20f3                  jr nz, _cmd_read_byte
   142                              ; otherwise, new line
   143  0120  3e0a                  ld a,ESC_N
   144  0122  cd3000                call putchar
   145                              ; and back to prompt
   146  0125  c3a000                jp prompt
   147                          
   148                          ; WRITE
   149                          
   150                          ; write bytes to memory interpreting hex values from console
   151                          _cmd_write:
   152                              ; load character from buffer
   153  0128  7e                    ld a,(hl)
   154                              ; end of string?
   155  0129  fe00                  cp 0
   156                              ; yes: no data
   157  012b  2817                  jr z, _cmd_write_null
   158                              ; parse first pair of characters - address high
   159  012d  cde001                call hex_byte_val
   160                              ; load into upper byte of memory pointer
   161  0130  57                    ld d,a
   162                              ; parse second pair of characters - address low
   163  0131  cde001                call hex_byte_val
   164                              ; load into lower byte of memory pointer
   165  0134  5f                    ld e,a
   166                          _cmd_write_data:
   167                              ; load character from buffer
   168  0135  7e                    ld a,(hl)
   169                              ; end of string?
   170  0136  fe00                  cp 0
   171                              ; yes: we're done
   172  0138  2807                  jr z, _cmd_write_end
   173                              ; parse data byte
   174  013a  cde001                call hex_byte_val
   175                              ; write byte to memory
   176  013d  12                    ld (de),a
   177                              ; advance destination pointer
   178  013e  13                    inc de
   179  013f  18f4                  jr _cmd_write_data
   180                          _cmd_write_end:
   181  0141  c3a000                jp prompt
   182                              ; w with no data
   183                          _cmd_write_null:
   184  0144  21ca01                ld hl,cmd_w_null_msg
   185  0147  cd4000                call puts
   186                              ; and back to prompt
   187  014a  c3a000                jp prompt
   188                          
   189                          ; EXECUTE
   190                          
   191                          ; start executing from given address
   192                          _cmd_execute:
   193                              ; load character from buffer
   194  014d  7e                    ld a,(hl)
   195                              ; end of string?
   196  014e  fe00                  cp 0
   197                              ; yes - no data
   198  0150  ca5e01                jp z, _cmd_exec_df
   199                              ; parse first pair of characters - address high
   200  0153  cde001                call hex_byte_val
   201                              ; load into upper byte of memory pointer
   202  0156  57                    ld d,a
   203                              ; parse second pair of characters - address low
   204  0157  cde001                call hex_byte_val
   205                              ; load into lower byte of memory pointer
   206  015a  5f                    ld e,a
   207  015b  626b                  ld hl,de
   208                              ; execute from address
   209  015d  e9                    jp (hl)
   210                              ; start executing from default address
   211                          _cmd_exec_df:
   212  015e  210080                ld hl,RAMSTART
   213                              ; execute from address
   214  0161  e9                    jp (hl)
   215                          
   216                          ; LOAD
   217                          
   218                          ; load from INTEL HEX - records are read from the buffer
   219                          _cmd_load:
   220                              ; load character from buffer
   221  0162  7e                    ld a,(hl)
   222                              ; end of string?
   223  0163  fe00                  cp 0
   224                              ; yes: no data - quit
   225  0165  ca8e01                jp z, _cmd_load_end
   226                              ; parse first pair of characters - byte count
   227  0168  cde001                call hex_byte_val
   228  016b  fe00                  cp 0
   229                              ; yes - zero byte count - quit
   230  016d  ca8e01                jp z, _cmd_load_end
   231                              ; load byte count into C
   232  0170  4f                    ld c,a
   233                              ; parse address high
   234  0171  cde001                call hex_byte_val
   235                              ; load into upper byte of memory pointer
   236  0174  57                    ld d,a
   237                              ; parse address low
   238  0175  cde001                call hex_byte_val
   239                              ; load into lower byte of memory pointer
   240  0178  5f                    ld e,a
   241                              ; parse record type
   242  0179  cde001                call hex_byte_val
   243                              ; record type zero?
   244  017c  fe00                  cp 0
   245                              ; no: quit
   246  017e  c28e01                jp nz, _cmd_load_end
   247                          _cmd_load_data:
   248                              ; load character from buffer
   249  0181  7e                    ld a,(hl)
   250                              ; end of string?
   251  0182  fe00                  cp 0
   252                              ; yes: we're done
   253  0184  2808                  jr z, _cmd_load_end
   254                              ; no:
   255                              ; parse data byte
   256  0186  cde001                call hex_byte_val
   257                              ; write byte to memory
   258  0189  12                    ld (de),a
   259                              ; advance destination pointer
   260  018a  13                    inc de
   261                              ; decrement byte counter
   262                              ; TODO djnz
   263  018b  0d                    dec c
   264                              ; if byte counter not zero then go again
   265  018c  20f3                  jr nz,_cmd_load_data
   266                          _cmd_load_end:
   267  018e  c3a000                jp prompt
   268                          
beanboard_proto.asm:
    39                          include "asm/messages_small.asm"
asm/messages_small.asm:
     1                          welcome_msg:
     2  0191  5061696e66756c44                  db "PainfulDiodes\n"
              696f6465730a      
     3  019f  4d415256494e205a                  db "MARVIN Z80 monitor\n"
              3830206d6f6e6974  
              6f720a            
     4  01b2  76312e312e626574                  db "v1.1.beta\n",0
              610a00            
     5                          
     6                          
     7                          bad_cmd_msg:
     8  01bd  42616420636f6d6d                  db "Bad command\n",0
              616e640a00        
     9                          
    10                          cmd_w_null_msg:
    11  01ca  4e6f20646174610a                  db "No data\n",0
              00                
    12                          
beanboard_proto.asm:
    40                          include "asm/strings.asm"
asm/strings.asm:
     1                          ; string subroutines
     2                          
     3  01d3  0000000000000000  ALIGN 0x10
              0000000000        
     4                          
     5                          ; read 2 ASCII hex chars from memory by HL pointer, return converted value in A and advance HL pointer
     6                          hex_byte_val:
     7                              ; preserve BC
     8  01e0  c5                    push bc
     9                              ; load 1st character from memory
    10  01e1  7e                    ld a,(hl)
    11                              ; end of string?
    12  01e2  fe00                  cp 0
    13                              ; yes: no value - return zero
    14  01e4  2819                  jr z,_hex_byte_val_zero
    15                              ; no:
    16                              ; advance the buffer pointer
    17  01e6  23                    inc hl
    18                              ; convert first hex digit
    19  01e7  cd1002                call hex_val
    20                              ; shift left 4 bits to put value into top nibble
    21  01ea  cb27                  sla a
    22  01ec  cb27                  sla a
    23  01ee  cb27                  sla a
    24  01f0  cb27                  sla a
    25                              ; cache the result
    26  01f2  47                    ld b,a
    27                              ; load 2nd character from memory
    28  01f3  7e                    ld a,(hl)
    29                              ; end of string?
    30  01f4  fe00                  cp 0
    31                              ; yes: incomplete byte - return zero
    32  01f6  2807                  jr z,_hex_byte_val_zero
    33                              ; advance the buffer pointer
    34  01f8  23                    inc hl
    35                              ; and convert 2nd hex digit
    36  01f9  cd1002                call hex_val
    37                              ; add first and second digits
    38  01fc  80                    add a,b
    39                              ; restore BC
    40  01fd  c1                    pop bc
    41  01fe  c9                    ret
    42                          _hex_byte_val_zero:
    43                              ; zero return value
    44  01ff  3e00                  ld a,0
    45                              ; restore BC
    46  0201  c1                    pop bc
    47  0202  c9                    ret
    48                          
    49  0203  0000000000000000  ALIGN 0x10
              0000000000        
    50                          
    51                          ; convert an ASCII hex char in A to a number value (lower 4 bits)
    52                          hex_val:
    53                              ; is it lowercase alphabetic?
    54  0210  fe61                  cp 'a'
    55                              ; no: uppercase/numeric
    56  0212  3803                  jr c,_hex_val_u_n
    57                              ; yes: alphabetic
    58  0214  d657                  sub 'a'-0x0a
    59  0216  c9                    ret
    60                          _hex_val_u_n:
    61                              ; is it uppercase alphabetic?
    62  0217  fe41                  cp 'A'
    63                              ; no: numeric
    64  0219  3803                  jr c,_hex_val_n
    65                              ; y:
    66  021b  d637                  sub 'A'-0x0a
    67  021d  c9                    ret
    68                          _hex_val_n:
    69                              ; numeric
    70  021e  d630                  sub '0'
    71  0220  c9                    ret
    72                          
    73  0221  0000000000000000  ALIGN 0x10
              00000000000000    
    74                          
    75                          ; convert value in A into an ASCII pair and send to console
    76                          putchar_hex:
    77  0230  f5                    push af
    78  0231  c5                    push bc
    79                              ; stash in B
    80  0232  47                    ld b,a
    81                              ; shift A right x4 e.g. transform 10110010 to 00001011
    82  0233  cb3f                  srl a
    83  0235  cb3f                  srl a
    84  0237  cb3f                  srl a
    85  0239  cb3f                  srl a
    86                              ; most significant digit
    87  023b  cd4702                call _putchar_hex_dgt
    88                              ; recover from stash
    89  023e  78                    ld a,b
    90                              ; clear the top 4 bits
    91  023f  e60f                  and 0b00001111
    92                              ; least significant digit
    93  0241  cd4702                call _putchar_hex_dgt
    94  0244  c1                    pop bc
    95  0245  f1                    pop af
    96  0246  c9                    ret
    97                          _putchar_hex_dgt:
    98                              ; is it an alpha or numeric?
    99  0247  fe0a                  cp 0x0a
   100                              ; numeric
   101  0249  3806                  jr c,_putchar_hex_n
   102                              ; alpha
   103                              ; for alpha add the base ascii for 'a' but then sub 10 / 0x0a as hex 'a' = 10d
   104  024b  c657                  add a,'a'-0x0a
   105  024d  cd3000                call putchar
   106  0250  c9                    ret
   107                          _putchar_hex_n:
   108                              ; for numeric add the base ascii for '0'
   109  0251  c630                  add a,'0'
   110  0253  cd3000                call putchar
   111  0256  c9                    ret
   112                          
beanboard_proto.asm:
    41                          include "asm/HD44780LCD.asm"
asm/HD44780LCD.asm:
     1                          LCD_COMMAND_0 equ LCD_FUNCTION_SET+LCD_DATA_LEN_8+LCD_DISP_LINES_2+LCD_FONT_8
     2                          LCD_COMMAND_1 equ LCD_DISPLAY_ON_OFF_CONTROL+LCD_DISPLAY_ON+LCD_CURSOR_ON+LCD_BLINK_ON
     3                          
     4  0257  0000000000000000  ALIGN 0x10
              00                
     5                          
     6                          lcd_init:
     7                          ; preserve registers
     8  0260  f5                    push af
     9                          ; intitialise device
    10  0261  3e38              	ld a,LCD_COMMAND_0
    11  0263  cd8002            	call lcd_putcmd
    12  0266  3e0f              	ld a,LCD_COMMAND_1
    13  0268  cd8002            	call lcd_putcmd
    14  026b  3e01              	ld a,LCD_CLEAR_DISPLAY
    15  026d  cd8002            	call lcd_putcmd
    16  0270  3e00                  ld a,0
    17  0272  cda002                call lcd_putchar
    18                          ; restore registers
    19  0275  f1                    pop af
    20  0276  c9                    ret
    21                          
    22  0277  0000000000000000  ALIGN 0x10
              00                
    23                          
    24                          ; transmit character in A to the control port
    25                          lcd_putcmd:
    26  0280  c5                    push bc
    27                          ; save the transmit character
    28  0281  47                    ld b,a
    29                          _lcd_putcmd_loop:
    30                          ; get the LCD status
    31  0282  db04                  in a,(LCD_CTRL)
    32                          ; busy ?
    33  0284  cb7f                  bit 7,a
    34                          ; yes
    35  0286  20fa                  jr nz,_lcd_putcmd_loop
    36                          ; no, restore the transmit character
    37  0288  78                    ld a,b
    38                          ; transmit the character
    39  0289  d304                  out (LCD_CTRL),a
    40  028b  c1                    pop bc
    41  028c  c9                    ret
    42                          
    43  028d  000000            ALIGN 0x10
    44                          
    45                          ; get character from data port and return in A
    46                          lcd_getchar:
    47                          ; get the LCD status
    48  0290  db04                  in a,(LCD_CTRL)
    49                          ; busy ?
    50  0292  cb7f                  bit 7,a
    51                          ; yes
    52  0294  20fa                  jr nz,lcd_getchar
    53                          ; no, get a character
    54  0296  db05                  in a,(LCD_DATA)
    55  0298  c9                    ret
    56                          
    57  0299  00000000000000    ALIGN 0x10
    58                          
    59                          ; transmit character in A to the data port
    60                          lcd_putchar:
    61                              ; newline char?
    62  02a0  fe0a                  cp ESC_N
    63  02a2  c2c002                jp nz,_lcd_putchar_printable
    64                              ; newline - fill out the line until EOL
    65                          _lcd_putchar_pad:
    66  02a5  3e20                  ld a,' '
    67  02a7  cd0003                call lcd_putdata
    68  02aa  fe13                  cp LCD_EOL_0
    69  02ac  cada02                jp z,_lcd_putchar_eol0
    70  02af  fe53                  cp LCD_EOL_1
    71  02b1  cae102                jp z,_lcd_putchar_eol1
    72  02b4  fe27                  cp LCD_EOL_2
    73  02b6  cae802                jp z,_lcd_putchar_eol2
    74  02b9  fe67                  cp LCD_EOL_3
    75  02bb  caef02                jp z,_lcd_putchar_eol3
    76                              ; loop until EOL
    77  02be  18e5                  jr _lcd_putchar_pad
    78                          _lcd_putchar_printable:
    79  02c0  cd0003                call lcd_putdata
    80                              ; check for overflow - DDRAM address returned in A
    81  02c3  fe13                  cp LCD_EOL_0
    82  02c5  cada02                jp z,_lcd_putchar_eol0
    83  02c8  fe53                  cp LCD_EOL_1
    84  02ca  cae102                jp z,_lcd_putchar_eol1
    85  02cd  fe27                  cp LCD_EOL_2
    86  02cf  cae802                jp z,_lcd_putchar_eol2
    87  02d2  fe67                  cp LCD_EOL_3
    88  02d4  caef02                jp z,_lcd_putchar_eol3
    89  02d7  c3f702                jp _lcd_putchar_end
    90                          _lcd_putchar_eol0:
    91  02da  3ec0                  ld a,LCD_SET_DDRAM_ADDR+LCD_LINE_1_ADDR
    92  02dc  cd8002            	call lcd_putcmd
    93  02df  1816                  jr _lcd_putchar_end
    94                          _lcd_putchar_eol1:
    95  02e1  3e94                  ld a,LCD_SET_DDRAM_ADDR+LCD_LINE_2_ADDR
    96  02e3  cd8002            	call lcd_putcmd
    97  02e6  180f                  jr _lcd_putchar_end
    98                          _lcd_putchar_eol2:
    99  02e8  3ed4                  ld a,LCD_SET_DDRAM_ADDR+LCD_LINE_3_ADDR
   100  02ea  cd8002            	call lcd_putcmd
   101  02ed  1808                  jr _lcd_putchar_end
   102                          _lcd_putchar_eol3:
   103  02ef  cd2003                call lcd_scroll
   104  02f2  3ed4                  ld a,LCD_SET_DDRAM_ADDR+LCD_LINE_3_ADDR
   105  02f4  cd8002            	call lcd_putcmd
   106                          _lcd_putchar_end:
   107  02f7  c9                    ret
   108                          
   109  02f8  0000000000000000  ALIGN 0x10
   110                          
   111                          ; transmit character in A to the data port,
   112                          ; return in A the DDRAM address where the character was sent
   113                          lcd_putdata:
   114  0300  c5                    push bc
   115                              ; save the transmit character
   116  0301  47                    ld b,a
   117                          _lcd_putdata_loop:
   118                              ; get the LCD status
   119  0302  db04                  in a,(LCD_CTRL)
   120                              ; busy ?
   121  0304  cb7f                  bit 7,a
   122                              ; yes
   123  0306  20fa                  jr nz,_lcd_putdata_loop
   124                              ; no, reset the 'busy' bit and preserve the DDRAM address
   125  0308  e67f                  and 0b01111111
   126  030a  4f                    ld c,a
   127                              ; restore the transmit character and send it
   128  030b  78                    ld a,b
   129  030c  d305                  out (LCD_DATA),a
   130                              ; restore the DDRAM address
   131  030e  79                    ld a,c
   132  030f  c1                    pop bc
   133  0310  c9                    ret
   134                          
   135  0311  0000000000000000  ALIGN 0x10
              00000000000000    
   136                          
   137                          lcd_scroll:
   138  0320  c5                    push bc
   139  0321  d5                    push de
   140  0322  16c0                  ld d,LCD_SET_DDRAM_ADDR+LCD_LINE_1_ADDR
   141  0324  1e80                  ld e,LCD_SET_DDRAM_ADDR+LCD_LINE_0_ADDR
   142  0326  cd3f03                call _lcd_scroll_line
   143  0329  1694                  ld d,LCD_SET_DDRAM_ADDR+LCD_LINE_2_ADDR
   144  032b  1ec0                  ld e,LCD_SET_DDRAM_ADDR+LCD_LINE_1_ADDR
   145  032d  cd3f03                call _lcd_scroll_line
   146  0330  16d4                  ld d,LCD_SET_DDRAM_ADDR+LCD_LINE_3_ADDR
   147  0332  1e94                  ld e,LCD_SET_DDRAM_ADDR+LCD_LINE_2_ADDR
   148  0334  cd3f03                call _lcd_scroll_line
   149  0337  3ed4                  ld a,LCD_SET_DDRAM_ADDR+LCD_LINE_3_ADDR
   150  0339  cd5803                call _lcd_scroll_clear_line
   151  033c  d1                    pop de
   152  033d  c1                    pop bc
   153  033e  c9                    ret
   154                          _lcd_scroll_line:
   155                              ; b = character counter
   156                              ; c = stash char
   157                              ; d = source line to copy from
   158                              ; e = destination line to copy to
   159  033f  0614                  ld b,LCD_LINE_LEN
   160                          _lcd_scroll_line_loop:
   161                              ; load source
   162  0341  7a                    ld a,d
   163                              ; character counter is an offset
   164  0342  80                    add b
   165                              ; zero based index so -1
   166  0343  3d                    dec a
   167  0344  cd8002                call lcd_putcmd
   168  0347  cd9002                call lcd_getchar
   169                              ; stash the value
   170  034a  4f                    ld c,a
   171                              ; load destination
   172  034b  7b                    ld a,e
   173                              ; character counter is an offset
   174  034c  80                    add b
   175                              ; zero based index so -1
   176  034d  3d                    dec a
   177  034e  cd8002                call lcd_putcmd
   178                              ; recover the stashed value
   179  0351  79                    ld a,c
   180  0352  cd0003                call lcd_putdata
   181  0355  10ea                  djnz _lcd_scroll_line_loop
   182  0357  c9                    ret
   183                          _lcd_scroll_clear_line:
   184                              ; a = destination line to clear
   185                              ; b = character counter
   186  0358  0614                  ld b,LCD_LINE_LEN
   187  035a  cd8002                call lcd_putcmd
   188                          _lcd_scroll_clear_line_loop:
   189  035d  3e20                  ld a,' '
   190  035f  cd0003                call lcd_putdata
   191  0362  10f9                  djnz _lcd_scroll_clear_line_loop
   192  0364  c9                    ret
   193                          
beanboard_proto.asm:
    42                          include "asm/keyscan_proto.asm"
asm/keyscan_proto.asm:
     1                          DEBOUNCE_DELAY equ 0xf0
     2                          MOD_KEY_SHIFT_L equ 0b00000010
     3                          MOD_KEY_SHIFT_R equ 0b00000001
     4                          
     5  0365  0000000000000000  ALIGN 0x10
              000000            
     6                          
     7                          ; initialise keyscan
     8                          keyscan_init:
     9  0370  c5                    push bc
    10  0371  e5                    push hl
    11  0372  0608                  ld b,8
    12  0374  2100f0                ld hl,KEYSCAN_BUFFER
    13                          _keyscan_init_loop:
    14  0377  3600                  ld (hl),0
    15  0379  23                    inc hl
    16  037a  10fb                  djnz _keyscan_init_loop
    17                              ; end
    18  037c  e1                    pop hl
    19  037d  c1                    pop bc
    20  037e  c9                    ret
    21                          
    22  037f  00                ALIGN 0x10
    23                          
    24                          ; return value in A
    25                          keyscan:
    26  0380  c5                    push bc
    27  0381  d5                    push de
    28  0382  e5                    push hl
    29                              ; initial row bit - only 1 bit is ever set at a time - it is shifted from bit 0 to bit 7
    30  0383  0601                  ld b,0x01
    31                              ; row counter - 0 => 7
    32  0385  0e00                  ld c,0x00
    33                              ; location of previous values
    34  0387  2100f0                ld hl,KEYSCAN_BUFFER
    35  038a  cdc003                call _modifierkeys
    36                              ; initialise map pointer
    37  038d  11f203                ld de,QWERTY_KEYMAP_L
    38                              ; either shift key down?
    39  0390  e603                  and MOD_KEY_SHIFT_L+MOD_KEY_SHIFT_R
    40  0392  ca9803                jp z,_keyscanloop
    41  0395  113204                ld de,QWERTY_KEYMAP_U
    42                          _keyscanloop:
    43  0398  cdb303                call _rowscan
    44                              ; ASCII returned in A, or 0
    45  039b  cddd03                call _colscan
    46  039e  fe00                  cp 0
    47  03a0  c2aa03                jp nz,_delay
    48                              ; move the pointer of previous values to the next row slot
    49  03a3  23                    inc hl
    50                              ; increment row counter
    51  03a4  0c                    inc c
    52                              ; clear the carry flag
    53  03a5  b7                    or a
    54                              ; shift row bit left - when we've done all 8, it will move to the carry flag
    55  03a6  cb10                  rl b
    56                              ; loop if not done all rows
    57  03a8  30ee                  jr nc,_keyscanloop
    58                              ; key debounce
    59                          _delay:
    60                              ; set a to the length of the delay
    61  03aa  06f0                  ld b,DEBOUNCE_DELAY
    62                          _delayloop:
    63                              ; wait a few cycles
    64  03ac  00                    nop
    65                              ; no - loop again
    66  03ad  10fd                  djnz _delayloop
    67                          ; end
    68  03af  e1                    pop hl
    69  03b0  d1                    pop de
    70  03b1  c1                    pop bc
    71  03b2  c9                    ret
    72                          
    73                          ; get row bitmap representing new keystrokes:
    74                          ; B contains row bit,
    75                          ; C contains row count,
    76                          ; HL contains a pointer to the old value.
    77                          ; return value in A
    78                          _rowscan:
    79                              ; preserve registers
    80  03b3  d5                    push de
    81                              ; fetch previous value for comparison
    82  03b4  7e                    ld a,(hl)
    83                              ; invert A - we want to check keys becoming closed - so zeroed bits on the previous value are significant
    84  03b5  2f                    cpl
    85                              ; store inverted previous value
    86  03b6  57                    ld d,a
    87                              ; get the current row bit
    88  03b7  78                    ld a,b
    89                              ; output row strobe
    90  03b8  d302                  out (KEYSCAN_OUT),a
    91                              ; get column values
    92  03ba  db03                  in a,(KEYSCAN_IN)
    93                              ; store the new value
    94  03bc  77                    ld (hl),a
    95                              ; newVal AND ~oldVal means bits are set only when the previous bit value was 0
    96  03bd  a2                    and d
    97                              ; restore registers
    98  03be  d1                    pop de
    99  03bf  c9                    ret
   100                          
   101                          ; get bitmap representing modifier keys:
   102                          ; return value in A
   103                          _modifierkeys:
   104  03c0  3e40                  ld a,0b01000000 ; row 7
   105                              ; output row strobe
   106  03c2  d302                  out (KEYSCAN_OUT),a
   107                              ; get column values
   108  03c4  db03                  in a,(KEYSCAN_IN)
   109  03c6  e601                  and 0b00000001 ; row 7, bit 1 is LEFT SHIFT
   110                              ; left shift modifier
   111  03c8  200d                  jr nz,_modifier_l_shift
   112  03ca  3e80                  ld a,0b10000000 ; row 8
   113                              ; output row strobe
   114  03cc  d302                  out (KEYSCAN_OUT),a
   115                              ; get column values
   116  03ce  db03                  in a,(KEYSCAN_IN)
   117  03d0  e610                  and 0b00010000 ; row 8, bit 5 is RIGHT SHIFT
   118                              ; left shift modifier
   119  03d2  2006                  jr nz,_modifier_r_shift
   120                              ; no modifiers
   121  03d4  3e00                  ld a,0
   122  03d6  c9                    ret
   123                          _modifier_l_shift:
   124  03d7  3e02                  ld a,MOD_KEY_SHIFT_L
   125  03d9  c9                    ret
   126                          _modifier_r_shift:
   127  03da  3e01                  ld a,MOD_KEY_SHIFT_R
   128  03dc  c9                    ret
   129                          
   130                          ; A contains row bitmap representing new keystrokes,
   131                          ; DE contains a pointer to the ASCII map for the row - which is incremented in the subroutine
   132                          ; first printable character returned in A
   133                          _colscan:
   134                              ; preserve registers
   135  03dd  c5                    push bc
   136                              ; initialise col bit mask - only 1 bit is ever set at a time - it is shifted from bit 0 to bit 7
   137  03de  0e01                  ld c,0x01
   138                              ; stash the bitmap
   139  03e0  47                    ld b,a
   140                          _colscanloop:
   141                              ; reload the bitmap
   142  03e1  78                    ld a,b
   143                              ; mask the bitmap - use the column mask (C) over the bitmap value in A
   144  03e2  a1                    and c
   145                              ; if zero then no keypress
   146  03e3  2805                  jr z,_colscanloopnext
   147  03e5  1a                    ld a,(de)
   148                              ; ASCII is 0?
   149  03e6  fe00                  cp 0
   150  03e8  2006                  jr nz,_colscanend
   151                          _colscanloopnext:
   152                              ; increment character map pointer
   153  03ea  13                    inc de
   154                              ; clear the carry flag
   155  03eb  b7                    or a
   156                              ; shift row bit left - when we've done all 8, it will move to the carry flag
   157  03ec  cb11                  rl c
   158                              ; loop if not done all rows
   159  03ee  30f1                  jr nc,_colscanloop
   160                          _colscanend:
   161                              ; restore registers
   162  03f0  c1                    pop bc
   163  03f1  c9                    ret
   164                          
   165                          ; define values for control keys
   166                          ; modifiers have zero value
   167                          QWERTY_SHIFT_L equ 0
   168                          QWERTY_SHIFT_R equ 0
   169                          QWERTY_FN equ 0
   170                          QWERTY_CTRL equ 0
   171                          QWERTY_ALT equ 0
   172                          QWERTY_CMD equ 0
   173                          QWERTY_CURS_UP equ 1
   174                          QWERTY_CURS_DOWN equ 2
   175                          QWERTY_CURS_LEFT equ 3
   176                          QWERTY_CURS_RIGHT equ 4
   177                          QWERTY_CAPS equ 5
   178                          QWERTY_UNDEFINED equ 12
   179                          
   180                          QWERTY_KEYMAP_L:
   181  03f2  1b31323334353637      db ESC_E,'1','2','3','4','5','6','7'
   182  03fa  3839302d3d080102      db '8','9','0','-','=',ESC_B,QWERTY_CURS_UP,QWERTY_CURS_DOWN
   183  0402  0971776572747975      db ESC_T,'q','w','e','r','t','y','u'
   184  040a  696f705b5d0a0304      db 'i','o','p','[',']',ESC_N,QWERTY_CURS_LEFT,QWERTY_CURS_RIGHT
   185  0412  056173646667686a      db QWERTY_CAPS,'a','s','d','f','g','h','j'
   186  041a  6b6c3b275c000000      db 'k','l',';',QUOTE,SLASH,QWERTY_FN,QWERTY_CTRL,QWERTY_ALT
   187  0422  00607a786376626e      db QWERTY_SHIFT_L,'`','z','x','c','v','b','n'
   188  042a  6d2c2e2f0000200c      db 'm',',','.','/',QWERTY_SHIFT_R,QWERTY_CMD,' ',QWERTY_UNDEFINED
   189                          QWERTY_KEYMAP_U:
   190  0432  1b21402324255e26      db ESC_E,'!','@','#','$','%','^','&'
   191  043a  2a28295f2b080102      db '*','(',')','_','+',ESC_B,QWERTY_CURS_UP,QWERTY_CURS_DOWN
   192  0442  0951574552545955      db ESC_T,'Q','W','E','R','T','Y','U'
   193  044a  494f507b7d0a0304      db 'I','O','P','{','}',ESC_N,QWERTY_CURS_LEFT,QWERTY_CURS_RIGHT
   194  0452  054153444647484a      db QWERTY_CAPS,'A','S','D','F','G','H','J'
   195  045a  4b4c3a227c000000      db 'K','L',':','"','|',QWERTY_FN,QWERTY_CTRL,QWERTY_ALT
   196  0462  007e5a584356424e      db QWERTY_SHIFT_L,'~','Z','X','C','V','B','N'
   197  046a  4d3c3e3f0000200c      db 'M','<','>','?',QWERTY_SHIFT_R,QWERTY_CMD,' ',QWERTY_UNDEFINED
   198                          
beanboard_proto.asm:
    43                          
