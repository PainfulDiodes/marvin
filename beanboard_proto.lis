beanboard_proto.asm:
     1                          ; MARVIN build for BeanZee with BeanBoard
     2                          ; https://github.com/PainfulDiodes/BeanZee
     3                          ; https://github.com/PainfulDiodes/BeanBoard
     4                          
     5                          BEANBOARD EQU 1
     6                          
     7                          IFDEF ORGDEF
     8                              ORG ORGDEF
     9                          ELSE
    10                              ORG 0x0000
    11                          ENDIF
    12                          
    13                          ; start of user RAM
    14                          RAMSTART equ 0x8000
    15                          ; input buffer - start of system RAM
    16                          CMD_BUFFER equ 0xf010
    17                          ; this should really be 0x0000 as the CPU will dec SP before PUSH
    18                          STACK equ 0xffff
    19                          ; 8-byte keyscan buffer
    20                          KEYSCAN_BUFFER equ 0xf000
    21                          
    22                          UM245R_CTRL equ 0 ; serial control port
    23                          UM245R_DATA equ 1 ; serial data port
    24                          KEYSCAN_OUT equ 2 ; either 2 or 3 will work
    25                          KEYSCAN_IN  equ 3 ; either 2 or 3 will work
    26                          LCD_CTRL    equ 4 ; LCD control port
    27                          LCD_DATA    equ 5 ; LCD data port
    28                          
    29  0000  31ffff                ld sp, STACK
    30  0003  cd1702                call lcd_init
    31  0006  cdf202                call keyscan_init
    32  0009  c38000                jp start
    33                          
    34                          include "asm/escapestring.inc"
asm/escapestring.inc:
     1                          ; escape character constants for assembler compatibility
     2                          ; sjasmplus requires double quotes around escape sequences: "\n" and would not interpret '\n' but truncate
     3                          ; z88dk-z80asm requires single quotes around so would correctly interpret '\n' but reject "\n"
     4                          
     5                          ESC_B equ 0x08 ; \b
     6                          ESC_T equ 0x09 ; \t
     7                          ESC_N equ 0x0a ; \n
     8                          ESC_R equ 0x0d ; \r
     9                          ESC_E equ 0x1b ; \e
    10                          SLASH equ 0x5c ; \\
    11                          QUOTE equ 0x27 ; \'
    12                          
beanboard_proto.asm:
    35                          include "asm/HD44780LCD.inc"
asm/HD44780LCD.inc:
     1                          ; LCD commands
     2                          LCD_CLEAR_DISPLAY equ 0x01
     3                          LCD_RETURN_HOME equ 0x02
     4                          LCD_ENTRY_MODE_SET equ 0x04
     5                          LCD_DISPLAY_ON_OFF_CONTROL equ 0x08
     6                          LCD_CURSOR_DISPLAY_SHIFT equ 0x10
     7                          LCD_FUNCTION_SET equ 0x20
     8                          LCD_SET_CGRAM_ADDR equ 0x40
     9                          LCD_SET_DDRAM_ADDR equ 0x80
    10                          
    11                          ; LCD_ENTRY_MODE_SET options
    12                          LCD_ENTRY_INC equ 0x02 ; left
    13                          LCD_ENTRY_DEC equ 0x00 ; right
    14                          LCD_ENTRY_SHIFT equ 0x01
    15                          LCD_ENTRY_NO_SHIFT equ 0x00
    16                          
    17                          ; LCD_DISPLAY_ON_OFF_CONTROL options
    18                          LCD_DISPLAY_ON equ 0x04
    19                          LCD_DISPLAY_OFF equ 0x00
    20                          LCD_CURSOR_ON equ 0x02
    21                          LCD_CURSOR_OFF equ 0x00
    22                          LCD_BLINK_ON equ 0x01
    23                          LCD_BLINK_OFF equ 0x00
    24                          
    25                          ; LCD_CURSOR_DISPLAY_SHIFT options
    26                          LCD_SHIFT_DISPLAY equ 0x08
    27                          LCD_SHIFT_CURSOR equ 0x00
    28                          LCD_SHIFT_RIGHT equ 0x04
    29                          LCD_SHIFT_LEFT equ 0x00
    30                          
    31                          ; LCD_FUNCTION_SET options
    32                          LCD_DATA_LEN_8 equ 0x10
    33                          LCD_DATA_LEN_4 equ 0x00
    34                          LCD_DISP_LINES_2 equ 0x08
    35                          LCD_DISP_LINES_1 equ 0x00
    36                          LCD_FONT_10 equ 0x04
    37                          LCD_FONT_8 equ 0x00
    38                          
    39                          LCD_LINE_LEN equ 0x14
    40                          LCD_NUM_LINES equ 4
    41                          LCD_BUFFER_LEN equ LCD_LINE_LEN*LCD_NUM_LINES
    42                          
    43                          ; LCD_SET_DDRAM_ADDR options
    44                          LCD_LINE_0_ADDR equ 0x00
    45                          LCD_LINE_1_ADDR equ 0x40
    46                          LCD_LINE_2_ADDR equ 0x00+LCD_LINE_LEN
    47                          LCD_LINE_3_ADDR equ 0x40+LCD_LINE_LEN
    48                          LCD_EOL_0 equ 0x00+LCD_LINE_LEN-1
    49                          LCD_EOL_1 equ 0x40+LCD_LINE_LEN-1
    50                          LCD_EOL_2 equ 0x00+LCD_LINE_LEN*2-1
    51                          LCD_EOL_3 equ 0x40+LCD_LINE_LEN*2-1
    52                          
beanboard_proto.asm:
    36                          include "asm/console.asm"
asm/console.asm:
     1  000c  00000000          ALIGN 0x10
     2                          
     3                          ; wait for a character and return in A
     4                          getchar:
     5  0010  cd2000                call readchar
     6  0013  fe00                  cp 0
     7  0015  c0                    ret nz
     8  0016  18f8                  jr getchar
     9                          
    10  0018  0000000000000000  ALIGN 0x10
    11                          
    12                          ; read a character from the console and return it,
    13                          ; or 0 if there is no character
    14                          readchar:
    15                          IF BEANBOARD
    16                              ; check keyboard
    17  0020  cd0103                call keyscan
    18                              ; is there a character?
    19  0023  fe00                  cp 0
    20                              ; yes: return it
    21  0025  c0                    ret nz
    22                              ; no:
    23                          ENDIF
    24                              ; check usb
    25  0026  cd4f00                call usb_readchar
    26                              ; return the result - 0 if no char
    27  0029  c9                    ret
    28                          
    29  002a  000000000000      ALIGN 0x10
    30                          
    31                          putchar:
    32                          IF BEANBOARD
    33                              ; A is not guaranteed to be preserved in these calls,
    34                              ; so preserve across the first call
    35  0030  f5                    push af
    36  0031  cd4402                call lcd_putchar
    37  0034  f1                    pop af
    38                          ENDIF
    39  0035  cd6000                call usb_putchar
    40  0038  c9                    ret
    41                          
    42  0039  00000000000000    ALIGN 0x10
    43                          
    44                          ; print a zero-terminated string, pointed to by hl
    45                          puts:
    46  0040  e5                    push hl
    47                          _puts_loop:
    48                              ; get character from string
    49  0041  7e                    ld a,(hl)
    50                              ; is it zero?
    51  0042  fe00                  cp 0
    52                              ; yes
    53  0044  2807                  jr z, _puts_end
    54                              ; no: send character
    55  0046  cd3000                call putchar
    56                              ; next character position
    57  0049  23                    inc hl
    58                              ; loop for next character
    59  004a  c34100                jp _puts_loop
    60                          _puts_end:
    61  004d  e1                    pop hl
    62  004e  c9                    ret
    63                          
beanboard_proto.asm:
    37                          include "asm/UM245R.asm"
asm/UM245R.asm:
     1                          ; It is assumed that UM245R status signals are gated to the data bus as an IO port where:
     2                          ; /TXE = bit 0
     3                          ; /RXF = bit 1
     4                          ; As per:
     5                          ; https://github.com/PainfulDiodes/z80-breadboard-computer
     6                          ;
     7                          ; line endings are translated:
     8                          ; incoming line endings from the terminal are expected to be \r
     9                          ; and are tranlslated to \n
    10                          ; (\r\n would count as 2 line endings)
    11                          ; and outgoing line endings are sent as \r\n
    12                          ; externally this is consistent with VT100/ANSI terminal behaviour
    13                          ; and internally line endings are always \n
    14                          
    15                          ; get character and return in A
    16                          usb_readchar:
    17                              ; get the USB status
    18  004f  db00                  in a,(UM245R_CTRL)
    19                              ; data to read? (active low)
    20  0051  cb4f                  bit 1,a
    21                              ; no, the buffer is empty
    22  0053  2008                  jr nz,_usb_no_char
    23                              ; yes, read the received char
    24  0055  db01                  in a,(UM245R_DATA)
    25                              ; is CR?
    26  0057  fe0d                  cp ESC_R
    27                              ; no:
    28  0059  c0                    ret nz
    29                              ; yes: convert CR to LF
    30  005a  3e0a                  ld a, ESC_N
    31  005c  c9                    ret
    32                          _usb_no_char:
    33  005d  3e00                  ld a,0
    34  005f  c9                    ret
    35                          
    36                          usb_putchar:
    37                              ; newline?
    38  0060  fe0a                  cp ESC_N
    39                              ; no: just send the char
    40  0062  2007                  jr nz,_do_usb_put
    41  0064  3e0d                  ld a, ESC_R
    42  0066  cd6f00                call _usb_put
    43  0069  3e0a                  ld a, ESC_N
    44                          _do_usb_put:
    45  006b  cd6f00                call _usb_put
    46  006e  c9                    ret
    47                          
    48                          ; transmit character in A
    49                          _usb_put:
    50  006f  c5                    push bc
    51                              ; stash the transmit character
    52  0070  47                    ld b,a
    53                          _usb_put_loop:
    54                              ; get the USB status
    55  0071  db00                  in a,(UM245R_CTRL)
    56                              ; ready to transmit? (active low)
    57  0073  cb47                  bit 0,a
    58                              ; no: bit is high
    59  0075  20fa                  jr nz,_usb_put_loop
    60                              ; yes: restore the stashed transmit character
    61  0077  78                    ld a,b
    62                              ; transmit the character
    63  0078  d301                  out (UM245R_DATA),a
    64  007a  c1                    pop bc
    65  007b  c9                    ret
    66                          
beanboard_proto.asm:
    38                          include "asm/marvin.asm"
asm/marvin.asm:
     1                          ; ****************************************************
     2                          ; *  Marvin - a Z80 homebrew monitor program
     3                          ; * (c) Stephen Willcock 2024
     4                          ; * https://github.com/PainfulDiodes
     5                          ; ****************************************************
     6                          
     7                          ; MAIN PROGRAM LOOP
     8                          
     9  007c  00000000          ALIGN 0x10
    10                          
    11                          start:
    12                              ; point DE to zero - this is the default address argument for commands
    13  0080  110000                ld de,0x0000
    14                          
    15  0083  217a01                ld hl,welcome_msg
    16  0086  cd4000                call puts
    17                          
    18                          prompt:
    19                              ; point HL to the beginning of the input buffer
    20  0089  2110f0                ld hl,CMD_BUFFER
    21  008c  3e3e                  ld a,'>'
    22  008e  cd3000                call putchar
    23                          
    24                          _get_cmd:
    25                              ; get character from console
    26  0091  cd1000                call getchar
    27                              ; echo the character to console
    28  0094  cd3000                call putchar
    29                              ; is CR?
    30  0097  fe0d                  cp ESC_R
    31                              ; yes: skip this
    32  0099  28f6                  jr z,_get_cmd
    33                              ; is tab?
    34  009b  fe09                  cp ESC_T
    35                              ; yes: skip this
    36  009d  28f2                  jr z,_get_cmd
    37                              ; is space?
    38  009f  fe20                  cp ' '
    39                              ; yes - skip this
    40  00a1  28ee                  jr z,_get_cmd
    41                              ; escape?
    42  00a3  fe1b                  cp ESC_E
    43                              ; yes
    44  00a5  2808                  jr z, _get_cmd_esc
    45                              ; end of line?
    46  00a7  fe0a                  cp ESC_N
    47                              ; yes
    48  00a9  280b                  jr z, _get_cmd_end
    49                              ; no: add character to the buffer
    50  00ab  77                    ld(hl),a
    51                              ; move pointer to next buffer location - we're not checking for overrun
    52  00ac  23                    inc hl
    53                              ; next character
    54  00ad  18e2                  jr _get_cmd
    55                              ; do escape
    56                          _get_cmd_esc:
    57                              ; new line
    58  00af  3e0a                  ld a,ESC_N
    59  00b1  cd3000                call putchar
    60                              ; back to prompt
    61  00b4  18d3                  jr prompt
    62                          _get_cmd_end:
    63                              ; string terminator
    64  00b6  3e00                  ld a,0
    65                              ; add terminator to end of buffer
    66  00b8  77                    ld(hl),a
    67                          ; process command from buffer
    68                              ; point to start of buffer
    69  00b9  2110f0                ld hl,CMD_BUFFER
    70                              ; load character from buffer
    71  00bc  7e                    ld a,(hl)
    72                              ; end of string?
    73  00bd  fe00                  cp 0
    74                              ; yes - empty line - go back to prompt
    75  00bf  28c8                  jr z,prompt
    76                              ; advance the buffer pointer
    77  00c1  23                    inc hl
    78  00c2  fe72                  cp 'r'
    79  00c4  2815                  jr z,_cmd_read
    80  00c6  fe77                  cp 'w'
    81  00c8  2847                  jr z,_cmd_write
    82  00ca  fe78                  cp 'x'
    83  00cc  2868                  jr z,_cmd_execute
    84                              ; ':' = load from intel hex format
    85  00ce  fe3a                  cp ':'
    86  00d0  2879                  jr z,_cmd_load
    87                              ; otherwise error
    88  00d2  21a601                ld hl,bad_cmd_msg
    89  00d5  cd4000                call puts
    90                              ; loop back to the prompt
    91  00d8  c38900                jp prompt
    92                          
    93                          ; COMMANDS
    94                          
    95                          ; READ
    96                          ; read bytes from memory and send hex values to console
    97                          _cmd_read:
    98                              ; load character from buffer
    99  00db  7e                    ld a,(hl)
   100                              ; end of string?
   101  00dc  fe00                  cp 0
   102                              ; yes: no address argument, so skip to read row
   103  00de  2808                  jr z, _cmd_read_row
   104                              ; parse first pair of characters
   105  00e0  cdbc01                call hex_byte_val
   106                              ; load into upper byte of memory pointer
   107  00e3  57                    ld d,a
   108                              ; parse second pair of characters
   109  00e4  cdbc01                call hex_byte_val
   110                              ; load into lower byte of memory pointer
   111  00e7  5f                    ld e,a
   112                          _cmd_read_row:
   113                              ; initialise byte counter - each row will have this many bytes
   114  00e8  0e10                  ld c, 0x10
   115                              ; print DE content: the read address
   116  00ea  7a                    ld a,d
   117  00eb  cdf001                call putchar_hex
   118  00ee  7b                    ld a,e
   119  00ef  cdf001                call putchar_hex
   120                              ; separator between address and data
   121  00f2  3e3a                  ld a,':'
   122  00f4  cd3000                call putchar
   123  00f7  3e20                  ld a,' '
   124  00f9  cd3000                call putchar
   125                              ; get a byte
   126                          _cmd_read_byte:
   127  00fc  1a                    ld a,(de)
   128                              ; and print it
   129  00fd  cdf001                call putchar_hex
   130                              ; add space between bytes
   131  0100  3e20                  ld a,' '
   132  0102  cd3000                call putchar
   133                              ; next address
   134  0105  13                    inc de
   135                              ; reduce byte counter
   136                              ; TODO djnz ?
   137  0106  0d                    dec c
   138                              ; repeat if the counter is not 0
   139  0107  20f3                  jr nz, _cmd_read_byte
   140                              ; otherwise, new line
   141  0109  3e0a                  ld a,ESC_N
   142  010b  cd3000                call putchar
   143                              ; and back to prompt
   144  010e  c38900                jp prompt
   145                          
   146                          ; WRITE
   147                          
   148                          ; write bytes to memory interpreting hex values from console
   149                          _cmd_write:
   150                              ; load character from buffer
   151  0111  7e                    ld a,(hl)
   152                              ; end of string?
   153  0112  fe00                  cp 0
   154                              ; yes: no data
   155  0114  2817                  jr z, _cmd_write_null
   156                              ; parse first pair of characters - address high
   157  0116  cdbc01                call hex_byte_val
   158                              ; load into upper byte of memory pointer
   159  0119  57                    ld d,a
   160                              ; parse second pair of characters - address low
   161  011a  cdbc01                call hex_byte_val
   162                              ; load into lower byte of memory pointer
   163  011d  5f                    ld e,a
   164                          _cmd_write_data:
   165                              ; load character from buffer
   166  011e  7e                    ld a,(hl)
   167                              ; end of string?
   168  011f  fe00                  cp 0
   169                              ; yes: we're done
   170  0121  2807                  jr z, _cmd_write_end
   171                              ; parse data byte
   172  0123  cdbc01                call hex_byte_val
   173                              ; write byte to memory
   174  0126  12                    ld (de),a
   175                              ; advance destination pointer
   176  0127  13                    inc de
   177  0128  18f4                  jr _cmd_write_data
   178                          _cmd_write_end:
   179  012a  c38900                jp prompt
   180                              ; w with no data
   181                          _cmd_write_null:
   182  012d  21b301                ld hl,cmd_w_null_msg
   183  0130  cd4000                call puts
   184                              ; and back to prompt
   185  0133  c38900                jp prompt
   186                          
   187                          ; EXECUTE
   188                          
   189                          ; start executing from given address
   190                          _cmd_execute:
   191                              ; load character from buffer
   192  0136  7e                    ld a,(hl)
   193                              ; end of string?
   194  0137  fe00                  cp 0
   195                              ; yes - no data
   196  0139  ca4701                jp z, _cmd_exec_df
   197                              ; parse first pair of characters - address high
   198  013c  cdbc01                call hex_byte_val
   199                              ; load into upper byte of memory pointer
   200  013f  57                    ld d,a
   201                              ; parse second pair of characters - address low
   202  0140  cdbc01                call hex_byte_val
   203                              ; load into lower byte of memory pointer
   204  0143  5f                    ld e,a
   205  0144  626b                  ld hl,de
   206                              ; execute from address
   207  0146  e9                    jp (hl)
   208                              ; start executing from default address
   209                          _cmd_exec_df:
   210  0147  210080                ld hl,RAMSTART
   211                              ; execute from address
   212  014a  e9                    jp (hl)
   213                          
   214                          ; LOAD
   215                          
   216                          ; load from INTEL HEX - records are read from the buffer
   217                          _cmd_load:
   218                              ; load character from buffer
   219  014b  7e                    ld a,(hl)
   220                              ; end of string?
   221  014c  fe00                  cp 0
   222                              ; yes: no data - quit
   223  014e  ca7701                jp z, _cmd_load_end
   224                              ; parse first pair of characters - byte count
   225  0151  cdbc01                call hex_byte_val
   226  0154  fe00                  cp 0
   227                              ; yes - zero byte count - quit
   228  0156  ca7701                jp z, _cmd_load_end
   229                              ; load byte count into C
   230  0159  4f                    ld c,a
   231                              ; parse address high
   232  015a  cdbc01                call hex_byte_val
   233                              ; load into upper byte of memory pointer
   234  015d  57                    ld d,a
   235                              ; parse address low
   236  015e  cdbc01                call hex_byte_val
   237                              ; load into lower byte of memory pointer
   238  0161  5f                    ld e,a
   239                              ; parse record type
   240  0162  cdbc01                call hex_byte_val
   241                              ; record type zero?
   242  0165  fe00                  cp 0
   243                              ; no: quit
   244  0167  c27701                jp nz, _cmd_load_end
   245                          _cmd_load_data:
   246                              ; load character from buffer
   247  016a  7e                    ld a,(hl)
   248                              ; end of string?
   249  016b  fe00                  cp 0
   250                              ; yes: we're done
   251  016d  2808                  jr z, _cmd_load_end
   252                              ; no:
   253                              ; parse data byte
   254  016f  cdbc01                call hex_byte_val
   255                              ; write byte to memory
   256  0172  12                    ld (de),a
   257                              ; advance destination pointer
   258  0173  13                    inc de
   259                              ; decrement byte counter
   260                              ; TODO djnz
   261  0174  0d                    dec c
   262                              ; if byte counter not zero then go again
   263  0175  20f3                  jr nz,_cmd_load_data
   264                          _cmd_load_end:
   265  0177  c38900                jp prompt
   266                          
beanboard_proto.asm:
    39                          include "asm/messages_small.asm"
asm/messages_small.asm:
     1                          welcome_msg:
     2  017a  5061696e66756c44                  db "PainfulDiodes\n"
              696f6465730a      
     3  0188  4d415256494e205a                  db "MARVIN Z80 monitor\n"
              3830206d6f6e6974  
              6f720a            
     4  019b  76312e312e626574                  db "v1.1.beta\n",0
              610a00            
     5                          
     6                          
     7                          bad_cmd_msg:
     8  01a6  42616420636f6d6d                  db "Bad command\n",0
              616e640a00        
     9                          
    10                          cmd_w_null_msg:
    11  01b3  4e6f20646174610a                  db "No data\n",0
              00                
    12                          
beanboard_proto.asm:
    40                          include "asm/strings.asm"
asm/strings.asm:
     1                          ; string subroutines
     2                          
     3                          ; read 2 ASCII hex chars from memory by HL pointer, return converted value in A and advance HL pointer
     4                          hex_byte_val:
     5                              ; preserve BC
     6  01bc  c5                    push bc
     7                              ; load 1st character from memory
     8  01bd  7e                    ld a,(hl)
     9                              ; end of string?
    10  01be  fe00                  cp 0
    11                              ; yes: no value - return zero
    12  01c0  2819                  jr z,_hex_byte_val_zero
    13                              ; no:
    14                              ; advance the buffer pointer
    15  01c2  23                    inc hl
    16                              ; convert first hex digit
    17  01c3  cddf01                call hex_val
    18                              ; shift left 4 bits to put value into top nibble
    19  01c6  cb27                  sla a
    20  01c8  cb27                  sla a
    21  01ca  cb27                  sla a
    22  01cc  cb27                  sla a
    23                              ; cache the result
    24  01ce  47                    ld b,a
    25                              ; load 2nd character from memory
    26  01cf  7e                    ld a,(hl)
    27                              ; end of string?
    28  01d0  fe00                  cp 0
    29                              ; yes: incomplete byte - return zero
    30  01d2  2807                  jr z,_hex_byte_val_zero
    31                              ; advance the buffer pointer
    32  01d4  23                    inc hl
    33                              ; and convert 2nd hex digit
    34  01d5  cddf01                call hex_val
    35                              ; add first and second digits
    36  01d8  80                    add a,b
    37                              ; restore BC
    38  01d9  c1                    pop bc
    39  01da  c9                    ret
    40                          _hex_byte_val_zero:
    41                              ; zero return value
    42  01db  3e00                  ld a,0
    43                              ; restore BC
    44  01dd  c1                    pop bc
    45  01de  c9                    ret
    46                          
    47                          ; convert an ASCII hex char in A to a number value (lower 4 bits)
    48                          hex_val:
    49                              ; is it lowercase alphabetic?
    50  01df  fe61                  cp 'a'
    51                              ; no: uppercase/numeric
    52  01e1  3803                  jr c,_hex_val_u_n
    53                              ; yes: alphabetic
    54  01e3  d657                  sub 'a'-0x0a
    55  01e5  c9                    ret
    56                          _hex_val_u_n:
    57                              ; is it uppercase alphabetic?
    58  01e6  fe41                  cp 'A'
    59                              ; no: numeric
    60  01e8  3803                  jr c,_hex_val_n
    61                              ; y:
    62  01ea  d637                  sub 'A'-0x0a
    63  01ec  c9                    ret
    64                          _hex_val_n:
    65                              ; numeric
    66  01ed  d630                  sub '0'
    67  01ef  c9                    ret
    68                          
    69                          ; convert value in A into an ASCII pair and send to console
    70                          putchar_hex:
    71  01f0  f5                    push af
    72  01f1  c5                    push bc
    73                              ; stash in B
    74  01f2  47                    ld b,a
    75                              ; shift A right x4 e.g. transform 10110010 to 00001011
    76  01f3  cb3f                  srl a
    77  01f5  cb3f                  srl a
    78  01f7  cb3f                  srl a
    79  01f9  cb3f                  srl a
    80                              ; most significant digit
    81  01fb  cd0702                call _putchar_hex_dgt
    82                              ; recover from stash
    83  01fe  78                    ld a,b
    84                              ; clear the top 4 bits
    85  01ff  e60f                  and 0b00001111
    86                              ; least significant digit
    87  0201  cd0702                call _putchar_hex_dgt
    88  0204  c1                    pop bc
    89  0205  f1                    pop af
    90  0206  c9                    ret
    91                          _putchar_hex_dgt:
    92                              ; is it an alpha or numeric?
    93  0207  fe0a                  cp 0x0a
    94                              ; numeric
    95  0209  3806                  jr c,_putchar_hex_n
    96                              ; alpha
    97                              ; for alpha add the base ascii for 'a' but then sub 10 / 0x0a as hex 'a' = 10d
    98  020b  c657                  add a,'a'-0x0a
    99  020d  cd3000                call putchar
   100  0210  c9                    ret
   101                          _putchar_hex_n:
   102                              ; for numeric add the base ascii for '0'
   103  0211  c630                  add a,'0'
   104  0213  cd3000                call putchar
   105  0216  c9                    ret
   106                          
beanboard_proto.asm:
    41                          include "asm/HD44780LCD.asm"
asm/HD44780LCD.asm:
     1                          LCD_COMMAND_0 equ LCD_FUNCTION_SET+LCD_DATA_LEN_8+LCD_DISP_LINES_2+LCD_FONT_8
     2                          LCD_COMMAND_1 equ LCD_DISPLAY_ON_OFF_CONTROL+LCD_DISPLAY_ON+LCD_CURSOR_ON+LCD_BLINK_ON
     3                          
     4                          lcd_init:
     5                          ; preserve registers
     6  0217  f5                    push af
     7                          ; intitialise device
     8  0218  3e38              	ld a,LCD_COMMAND_0
     9  021a  cd2e02            	call lcd_putcmd
    10  021d  3e0f              	ld a,LCD_COMMAND_1
    11  021f  cd2e02            	call lcd_putcmd
    12  0222  3e01              	ld a,LCD_CLEAR_DISPLAY
    13  0224  cd2e02            	call lcd_putcmd
    14  0227  3e00                  ld a,0
    15  0229  cd4402                call lcd_putchar
    16                          ; restore registers
    17  022c  f1                    pop af
    18  022d  c9                    ret
    19                          
    20                          ; transmit character in A to the control port
    21                          lcd_putcmd:
    22  022e  c5                    push bc
    23                          ; save the transmit character
    24  022f  47                    ld b,a
    25                          _lcd_putcmd_loop:
    26                          ; get the LCD status
    27  0230  db04                  in a,(LCD_CTRL)
    28                          ; busy ?
    29  0232  cb7f                  bit 7,a
    30                          ; yes
    31  0234  20fa                  jr nz,_lcd_putcmd_loop
    32                          ; no, restore the transmit character
    33  0236  78                    ld a,b
    34                          ; transmit the character
    35  0237  d304                  out (LCD_CTRL),a
    36  0239  c1                    pop bc
    37  023a  c9                    ret
    38                          
    39                          ; get character from data port and return in A
    40                          lcd_getchar:
    41                          ; get the LCD status
    42  023b  db04                  in a,(LCD_CTRL)
    43                          ; busy ?
    44  023d  cb7f                  bit 7,a
    45                          ; yes
    46  023f  20fa                  jr nz,lcd_getchar
    47                          ; no, get a character
    48  0241  db05                  in a,(LCD_DATA)
    49  0243  c9                    ret
    50                          
    51                          ; transmit character in A to the data port
    52                          lcd_putchar:
    53                              ; newline char?
    54  0244  fe0a                  cp ESC_N
    55  0246  c26402                jp nz,_lcd_putchar_printable
    56                              ; newline - fill out the line until EOL
    57                          _lcd_putchar_pad:
    58  0249  3e20                  ld a,' '
    59  024b  cd9c02                call lcd_putdata
    60  024e  fe13                  cp LCD_EOL_0
    61  0250  ca7e02                jp z,_lcd_putchar_eol0
    62  0253  fe53                  cp LCD_EOL_1
    63  0255  ca8502                jp z,_lcd_putchar_eol1
    64  0258  fe27                  cp LCD_EOL_2
    65  025a  ca8c02                jp z,_lcd_putchar_eol2
    66  025d  fe67                  cp LCD_EOL_3
    67  025f  ca9302                jp z,_lcd_putchar_eol3
    68                              ; loop until EOL
    69  0262  18e5                  jr _lcd_putchar_pad
    70                          _lcd_putchar_printable:
    71  0264  cd9c02                call lcd_putdata
    72                              ; check for overflow - DDRAM address returned in A
    73  0267  fe13                  cp LCD_EOL_0
    74  0269  ca7e02                jp z,_lcd_putchar_eol0
    75  026c  fe53                  cp LCD_EOL_1
    76  026e  ca8502                jp z,_lcd_putchar_eol1
    77  0271  fe27                  cp LCD_EOL_2
    78  0273  ca8c02                jp z,_lcd_putchar_eol2
    79  0276  fe67                  cp LCD_EOL_3
    80  0278  ca9302                jp z,_lcd_putchar_eol3
    81  027b  c39b02                jp _lcd_putchar_end
    82                          _lcd_putchar_eol0:
    83  027e  3ec0                  ld a,LCD_SET_DDRAM_ADDR+LCD_LINE_1_ADDR
    84  0280  cd2e02            	call lcd_putcmd
    85  0283  1816                  jr _lcd_putchar_end
    86                          _lcd_putchar_eol1:
    87  0285  3e94                  ld a,LCD_SET_DDRAM_ADDR+LCD_LINE_2_ADDR
    88  0287  cd2e02            	call lcd_putcmd
    89  028a  180f                  jr _lcd_putchar_end
    90                          _lcd_putchar_eol2:
    91  028c  3ed4                  ld a,LCD_SET_DDRAM_ADDR+LCD_LINE_3_ADDR
    92  028e  cd2e02            	call lcd_putcmd
    93  0291  1808                  jr _lcd_putchar_end
    94                          _lcd_putchar_eol3:
    95  0293  cdad02                call lcd_scroll
    96  0296  3ed4                  ld a,LCD_SET_DDRAM_ADDR+LCD_LINE_3_ADDR
    97  0298  cd2e02            	call lcd_putcmd
    98                          _lcd_putchar_end:
    99  029b  c9                    ret
   100                          
   101                          ; transmit character in A to the data port,
   102                          ; return in A the DDRAM address where the character was sent
   103                          lcd_putdata:
   104  029c  c5                    push bc
   105                              ; save the transmit character
   106  029d  47                    ld b,a
   107                          _lcd_putdata_loop:
   108                              ; get the LCD status
   109  029e  db04                  in a,(LCD_CTRL)
   110                              ; busy ?
   111  02a0  cb7f                  bit 7,a
   112                              ; yes
   113  02a2  20fa                  jr nz,_lcd_putdata_loop
   114                              ; no, reset the 'busy' bit and preserve the DDRAM address
   115  02a4  e67f                  and 0b01111111
   116  02a6  4f                    ld c,a
   117                              ; restore the transmit character and send it
   118  02a7  78                    ld a,b
   119  02a8  d305                  out (LCD_DATA),a
   120                              ; restore the DDRAM address
   121  02aa  79                    ld a,c
   122  02ab  c1                    pop bc
   123  02ac  c9                    ret
   124                          
   125                          lcd_scroll:
   126  02ad  c5                    push bc
   127  02ae  d5                    push de
   128  02af  16c0                  ld d,LCD_SET_DDRAM_ADDR+LCD_LINE_1_ADDR
   129  02b1  1e80                  ld e,LCD_SET_DDRAM_ADDR+LCD_LINE_0_ADDR
   130  02b3  cdcc02                call _lcd_scroll_line
   131  02b6  1694                  ld d,LCD_SET_DDRAM_ADDR+LCD_LINE_2_ADDR
   132  02b8  1ec0                  ld e,LCD_SET_DDRAM_ADDR+LCD_LINE_1_ADDR
   133  02ba  cdcc02                call _lcd_scroll_line
   134  02bd  16d4                  ld d,LCD_SET_DDRAM_ADDR+LCD_LINE_3_ADDR
   135  02bf  1e94                  ld e,LCD_SET_DDRAM_ADDR+LCD_LINE_2_ADDR
   136  02c1  cdcc02                call _lcd_scroll_line
   137  02c4  3ed4                  ld a,LCD_SET_DDRAM_ADDR+LCD_LINE_3_ADDR
   138  02c6  cde502                call _lcd_scroll_clear_line
   139  02c9  d1                    pop de
   140  02ca  c1                    pop bc
   141  02cb  c9                    ret
   142                          _lcd_scroll_line:
   143                              ; b = character counter
   144                              ; c = stash char
   145                              ; d = source line to copy from
   146                              ; e = destination line to copy to
   147  02cc  0614                  ld b,LCD_LINE_LEN
   148                          _lcd_scroll_line_loop:
   149                              ; load source
   150  02ce  7a                    ld a,d
   151                              ; character counter is an offset
   152  02cf  80                    add b
   153                              ; zero based index so -1
   154  02d0  3d                    dec a
   155  02d1  cd2e02                call lcd_putcmd
   156  02d4  cd3b02                call lcd_getchar
   157                              ; stash the value
   158  02d7  4f                    ld c,a
   159                              ; load destination
   160  02d8  7b                    ld a,e
   161                              ; character counter is an offset
   162  02d9  80                    add b
   163                              ; zero based index so -1
   164  02da  3d                    dec a
   165  02db  cd2e02                call lcd_putcmd
   166                              ; recover the stashed value
   167  02de  79                    ld a,c
   168  02df  cd9c02                call lcd_putdata
   169  02e2  10ea                  djnz _lcd_scroll_line_loop
   170  02e4  c9                    ret
   171                          _lcd_scroll_clear_line:
   172                              ; a = destination line to clear
   173                              ; b = character counter
   174  02e5  0614                  ld b,LCD_LINE_LEN
   175  02e7  cd2e02                call lcd_putcmd
   176                          _lcd_scroll_clear_line_loop:
   177  02ea  3e20                  ld a,' '
   178  02ec  cd9c02                call lcd_putdata
   179  02ef  10f9                  djnz _lcd_scroll_clear_line_loop
   180  02f1  c9                    ret
   181                          
beanboard_proto.asm:
    42                          include "asm/keyscan_proto.asm"
asm/keyscan_proto.asm:
     1                          DEBOUNCE_DELAY equ 0xf0
     2                          MOD_KEY_SHIFT_L equ 0b00000010
     3                          MOD_KEY_SHIFT_R equ 0b00000001
     4                          
     5                          ; initialise keyscan
     6                          keyscan_init:
     7  02f2  c5                    push bc
     8  02f3  e5                    push hl
     9  02f4  0608                  ld b,8
    10  02f6  2100f0                ld hl,KEYSCAN_BUFFER
    11                          _keyscan_init_loop:
    12  02f9  3600                  ld (hl),0
    13  02fb  23                    inc hl
    14  02fc  10fb                  djnz _keyscan_init_loop
    15                              ; end
    16  02fe  e1                    pop hl
    17  02ff  c1                    pop bc
    18  0300  c9                    ret
    19                          
    20                          ; return value in A
    21                          keyscan:
    22  0301  c5                    push bc
    23  0302  d5                    push de
    24  0303  e5                    push hl
    25                              ; initial row bit - only 1 bit is ever set at a time - it is shifted from bit 0 to bit 7
    26  0304  0601                  ld b,0x01
    27                              ; row counter - 0 => 7
    28  0306  0e00                  ld c,0x00
    29                              ; location of previous values
    30  0308  2100f0                ld hl,KEYSCAN_BUFFER
    31  030b  cd4103                call _modifierkeys
    32                              ; initialise map pointer
    33  030e  117303                ld de,QWERTY_KEYMAP_L
    34                              ; either shift key down?
    35  0311  e603                  and MOD_KEY_SHIFT_L+MOD_KEY_SHIFT_R
    36  0313  ca1903                jp z,_keyscanloop
    37  0316  11b303                ld de,QWERTY_KEYMAP_U
    38                          _keyscanloop:
    39  0319  cd3403                call _rowscan
    40                              ; ASCII returned in A, or 0
    41  031c  cd5e03                call _colscan
    42  031f  fe00                  cp 0
    43  0321  c22b03                jp nz,_delay
    44                              ; move the pointer of previous values to the next row slot
    45  0324  23                    inc hl
    46                              ; increment row counter
    47  0325  0c                    inc c
    48                              ; clear the carry flag
    49  0326  b7                    or a
    50                              ; shift row bit left - when we've done all 8, it will move to the carry flag
    51  0327  cb10                  rl b
    52                              ; loop if not done all rows
    53  0329  30ee                  jr nc,_keyscanloop
    54                              ; key debounce
    55                          _delay:
    56                              ; set a to the length of the delay
    57  032b  06f0                  ld b,DEBOUNCE_DELAY
    58                          _delayloop:
    59                              ; wait a few cycles
    60  032d  00                    nop
    61                              ; no - loop again
    62  032e  10fd                  djnz _delayloop
    63                          ; end
    64  0330  e1                    pop hl
    65  0331  d1                    pop de
    66  0332  c1                    pop bc
    67  0333  c9                    ret
    68                          
    69                          ; get row bitmap representing new keystrokes:
    70                          ; B contains row bit,
    71                          ; C contains row count,
    72                          ; HL contains a pointer to the old value.
    73                          ; return value in A
    74                          _rowscan:
    75                              ; preserve registers
    76  0334  d5                    push de
    77                              ; fetch previous value for comparison
    78  0335  7e                    ld a,(hl)
    79                              ; invert A - we want to check keys becoming closed - so zeroed bits on the previous value are significant
    80  0336  2f                    cpl
    81                              ; store inverted previous value
    82  0337  57                    ld d,a
    83                              ; get the current row bit
    84  0338  78                    ld a,b
    85                              ; output row strobe
    86  0339  d302                  out (KEYSCAN_OUT),a
    87                              ; get column values
    88  033b  db03                  in a,(KEYSCAN_IN)
    89                              ; store the new value
    90  033d  77                    ld (hl),a
    91                              ; newVal AND ~oldVal means bits are set only when the previous bit value was 0
    92  033e  a2                    and d
    93                              ; restore registers
    94  033f  d1                    pop de
    95  0340  c9                    ret
    96                          
    97                          ; get bitmap representing modifier keys:
    98                          ; return value in A
    99                          _modifierkeys:
   100  0341  3e40                  ld a,0b01000000 ; row 7
   101                              ; output row strobe
   102  0343  d302                  out (KEYSCAN_OUT),a
   103                              ; get column values
   104  0345  db03                  in a,(KEYSCAN_IN)
   105  0347  e601                  and 0b00000001 ; row 7, bit 1 is LEFT SHIFT
   106                              ; left shift modifier
   107  0349  200d                  jr nz,_modifier_l_shift
   108  034b  3e80                  ld a,0b10000000 ; row 8
   109                              ; output row strobe
   110  034d  d302                  out (KEYSCAN_OUT),a
   111                              ; get column values
   112  034f  db03                  in a,(KEYSCAN_IN)
   113  0351  e610                  and 0b00010000 ; row 8, bit 5 is RIGHT SHIFT
   114                              ; left shift modifier
   115  0353  2006                  jr nz,_modifier_r_shift
   116                              ; no modifiers
   117  0355  3e00                  ld a,0
   118  0357  c9                    ret
   119                          _modifier_l_shift:
   120  0358  3e02                  ld a,MOD_KEY_SHIFT_L
   121  035a  c9                    ret
   122                          _modifier_r_shift:
   123  035b  3e01                  ld a,MOD_KEY_SHIFT_R
   124  035d  c9                    ret
   125                          
   126                          ; A contains row bitmap representing new keystrokes,
   127                          ; DE contains a pointer to the ASCII map for the row - which is incremented in the subroutine
   128                          ; first printable character returned in A
   129                          _colscan:
   130                              ; preserve registers
   131  035e  c5                    push bc
   132                              ; initialise col bit mask - only 1 bit is ever set at a time - it is shifted from bit 0 to bit 7
   133  035f  0e01                  ld c,0x01
   134                              ; stash the bitmap
   135  0361  47                    ld b,a
   136                          _colscanloop:
   137                              ; reload the bitmap
   138  0362  78                    ld a,b
   139                              ; mask the bitmap - use the column mask (C) over the bitmap value in A
   140  0363  a1                    and c
   141                              ; if zero then no keypress
   142  0364  2805                  jr z,_colscanloopnext
   143  0366  1a                    ld a,(de)
   144                              ; ASCII is 0?
   145  0367  fe00                  cp 0
   146  0369  2006                  jr nz,_colscanend
   147                          _colscanloopnext:
   148                              ; increment character map pointer
   149  036b  13                    inc de
   150                              ; clear the carry flag
   151  036c  b7                    or a
   152                              ; shift row bit left - when we've done all 8, it will move to the carry flag
   153  036d  cb11                  rl c
   154                              ; loop if not done all rows
   155  036f  30f1                  jr nc,_colscanloop
   156                          _colscanend:
   157                              ; restore registers
   158  0371  c1                    pop bc
   159  0372  c9                    ret
   160                          
   161                          ; define values for control keys
   162                          ; modifiers have zero value
   163                          QWERTY_SHIFT_L equ 0
   164                          QWERTY_SHIFT_R equ 0
   165                          QWERTY_FN equ 0
   166                          QWERTY_CTRL equ 0
   167                          QWERTY_ALT equ 0
   168                          QWERTY_CMD equ 0
   169                          QWERTY_CURS_UP equ 1
   170                          QWERTY_CURS_DOWN equ 2
   171                          QWERTY_CURS_LEFT equ 3
   172                          QWERTY_CURS_RIGHT equ 4
   173                          QWERTY_CAPS equ 5
   174                          QWERTY_UNDEFINED equ 12
   175                          
   176                          QWERTY_KEYMAP_L:
   177  0373  1b31323334353637      db ESC_E,'1','2','3','4','5','6','7'
   178  037b  3839302d3d080102      db '8','9','0','-','=',ESC_B,QWERTY_CURS_UP,QWERTY_CURS_DOWN
   179  0383  0971776572747975      db ESC_T,'q','w','e','r','t','y','u'
   180  038b  696f705b5d0a0304      db 'i','o','p','[',']',ESC_N,QWERTY_CURS_LEFT,QWERTY_CURS_RIGHT
   181  0393  056173646667686a      db QWERTY_CAPS,'a','s','d','f','g','h','j'
   182  039b  6b6c3b275c000000      db 'k','l',';',QUOTE,SLASH,QWERTY_FN,QWERTY_CTRL,QWERTY_ALT
   183  03a3  00607a786376626e      db QWERTY_SHIFT_L,'`','z','x','c','v','b','n'
   184  03ab  6d2c2e2f0000200c      db 'm',',','.','/',QWERTY_SHIFT_R,QWERTY_CMD,' ',QWERTY_UNDEFINED
   185                          QWERTY_KEYMAP_U:
   186  03b3  1b21402324255e26      db ESC_E,'!','@','#','$','%','^','&'
   187  03bb  2a28295f2b080102      db '*','(',')','_','+',ESC_B,QWERTY_CURS_UP,QWERTY_CURS_DOWN
   188  03c3  0951574552545955      db ESC_T,'Q','W','E','R','T','Y','U'
   189  03cb  494f507b7d0a0304      db 'I','O','P','{','}',ESC_N,QWERTY_CURS_LEFT,QWERTY_CURS_RIGHT
   190  03d3  054153444647484a      db QWERTY_CAPS,'A','S','D','F','G','H','J'
   191  03db  4b4c3a227c000000      db 'K','L',':','"','|',QWERTY_FN,QWERTY_CTRL,QWERTY_ALT
   192  03e3  007e5a584356424e      db QWERTY_SHIFT_L,'~','Z','X','C','V','B','N'
   193  03eb  4d3c3e3f0000200c      db 'M','<','>','?',QWERTY_SHIFT_R,QWERTY_CMD,' ',QWERTY_UNDEFINED
   194                          
beanboard_proto.asm:
    43                          
