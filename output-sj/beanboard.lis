# file opened: beanboard.asm
  1   0000              ; MARVIN build for BeanZee with BeanBoard
  2   0000              ; https://github.com/PainfulDiodes/BeanZee
  3   0000              ; https://github.com/PainfulDiodes/BeanBoard
  4   0000
  5   0000              BEANBOARD EQU 1
  6   0000
  7   0000              include "asm/main.inc"
# file opened: asm/main.inc
  1+  0000              ; start of user RAM
  2+  0000              RAMSTART equ 0x8000
  3+  0000
  4+  0000              ; 8-byte status area
  5+  0000              CONSOLE_STATUS equ 0xf000
  6+  0000              ; 8-byte keyscan buffer
  7+  0000              KEY_MATRIX_BUFFER equ 0xf010
  8+  0000              ; command buffer
  9+  0000              CMD_BUFFER equ 0xf020
 10+  0000              ; this should really be 0x0000 as the CPU will dec SP before PUSH
 11+  0000              STACK equ 0xffff
 12+  0000
 13+  0000              UM245R_CTRL equ 0 ; serial control port
 14+  0000              UM245R_DATA equ 1 ; serial data port
 15+  0000              KEYSCAN_OUT equ 2 ; either 2 or 3 will work
 16+  0000              KEYSCAN_IN  equ 3 ; either 2 or 3 will work
 17+  0000              LCD_CTRL    equ 4 ; LCD control port
 18+  0000              LCD_DATA    equ 5 ; LCD data port
 19+  0000              GPIO_OUT    equ 6 ; either 6 or 7 will work
 20+  0000              GPIO_IN     equ 7 ; either 6 or 7 will work
 21+  0000
 22+  0000              CONSOLE_STATUS_USB equ 1
 23+  0000              CONSOLE_STATUS_BEANBOARD equ 2
 24+  0000
# file closed: asm/main.inc
  8   0000              include "asm/escapestring.inc"
# file opened: asm/escapestring.inc
  1+  0000              ; escape character constants for assembler compatibility
  2+  0000              ; sjasmplus requires double quotes around escape sequences: "\n" and would not interpret '\n' but truncate
  3+  0000              ; z88dk-z80asm requires single quotes around so would correctly interpret '\n' but reject "\n"
  4+  0000
  5+  0000              ESC_B equ 0x08 ; \b
  6+  0000              ESC_T equ 0x09 ; \t
  7+  0000              ESC_N equ 0x0a ; \n
  8+  0000              ESC_R equ 0x0d ; \r
  9+  0000              ESC_E equ 0x1b ; \e
 10+  0000              SLASH equ 0x5c ; \\
 11+  0000              QUOTE equ 0x27 ; \'
 12+  0000
# file closed: asm/escapestring.inc
  9   0000              include "asm/HD44780LCD.inc"
# file opened: asm/HD44780LCD.inc
  1+  0000              ; LCD commands
  2+  0000              LCD_CLEAR_DISPLAY equ 0x01
  3+  0000              LCD_RETURN_HOME equ 0x02
  4+  0000              LCD_ENTRY_MODE_SET equ 0x04
  5+  0000              LCD_DISPLAY_ON_OFF_CONTROL equ 0x08
  6+  0000              LCD_CURSOR_DISPLAY_SHIFT equ 0x10
  7+  0000              LCD_FUNCTION_SET equ 0x20
  8+  0000              LCD_SET_CGRAM_ADDR equ 0x40
  9+  0000              LCD_SET_DDRAM_ADDR equ 0x80
 10+  0000
 11+  0000              ; LCD_ENTRY_MODE_SET options
 12+  0000              LCD_ENTRY_INC equ 0x02 ; left
 13+  0000              LCD_ENTRY_DEC equ 0x00 ; right
 14+  0000              LCD_ENTRY_SHIFT equ 0x01
 15+  0000              LCD_ENTRY_NO_SHIFT equ 0x00
 16+  0000
 17+  0000              ; LCD_DISPLAY_ON_OFF_CONTROL options
 18+  0000              LCD_DISPLAY_ON equ 0x04
 19+  0000              LCD_DISPLAY_OFF equ 0x00
 20+  0000              LCD_CURSOR_ON equ 0x02
 21+  0000              LCD_CURSOR_OFF equ 0x00
 22+  0000              LCD_BLINK_ON equ 0x01
 23+  0000              LCD_BLINK_OFF equ 0x00
 24+  0000
 25+  0000              ; LCD_CURSOR_DISPLAY_SHIFT options
 26+  0000              LCD_SHIFT_DISPLAY equ 0x08
 27+  0000              LCD_SHIFT_CURSOR equ 0x00
 28+  0000              LCD_SHIFT_RIGHT equ 0x04
 29+  0000              LCD_SHIFT_LEFT equ 0x00
 30+  0000
 31+  0000              ; LCD_FUNCTION_SET options
 32+  0000              LCD_DATA_LEN_8 equ 0x10
 33+  0000              LCD_DATA_LEN_4 equ 0x00
 34+  0000              LCD_DISP_LINES_2 equ 0x08
 35+  0000              LCD_DISP_LINES_1 equ 0x00
 36+  0000              LCD_FONT_10 equ 0x04
 37+  0000              LCD_FONT_8 equ 0x00
 38+  0000
 39+  0000              LCD_LINE_LEN equ 0x14
 40+  0000              LCD_NUM_LINES equ 4
 41+  0000              LCD_BUFFER_LEN equ LCD_LINE_LEN*LCD_NUM_LINES
 42+  0000
 43+  0000              ; LCD_SET_DDRAM_ADDR options
 44+  0000              LCD_LINE_0_ADDR equ 0x00
 45+  0000              LCD_LINE_1_ADDR equ 0x40
 46+  0000              LCD_LINE_2_ADDR equ 0x00+LCD_LINE_LEN
 47+  0000              LCD_LINE_3_ADDR equ 0x40+LCD_LINE_LEN
 48+  0000              LCD_EOL_0 equ 0x00+LCD_LINE_LEN-1
 49+  0000              LCD_EOL_1 equ 0x40+LCD_LINE_LEN-1
 50+  0000              LCD_EOL_2 equ 0x00+LCD_LINE_LEN*2-1
 51+  0000              LCD_EOL_3 equ 0x40+LCD_LINE_LEN*2-1
 52+  0000
# file closed: asm/HD44780LCD.inc
 10   0000              include "asm/main.asm"
# file opened: asm/main.asm
  1+  0000              ORG 0x0000
  2+  0000 31 FF FF         ld sp, STACK
  3+  0003              IF BEANBOARD
  4+  0003 CD 1B 02         call lcd_init
  5+  0006 CD 74 00         call beanboard_console_init
  6+  0009              ENDIF
  7+  0009 00 00 00...  ALIGN 0x0010 ; fix the warmstart address across targets
  8+  0010              WARMSTART:
  9+  0010 C3 C6 00         jp MARVIN
 10+  0013 00 00 00...  ALIGN 0x0010
 11+  0020              WARMSTART2:
 12+  0020 C3 CF 00         jp PROMPT
 13+  0023
# file closed: asm/main.asm
 11   0023              include "asm/console.asm"
# file opened: asm/console.asm
  1+  0023              ; wait for a character and return in A
  2+  0023              getchar:
  3+  0023 CD 2B 00         call readchar
  4+  0026 FE 00            cp 0
  5+  0028 C0               ret nz
  6+  0029 18 F8            jr getchar
  7+  002B
  8+  002B              IF BEANBOARD
  9+  002B              ; read a character from the console and return in A - return 0 if there is no character
 10+  002B              readchar:
 11+  002B E5               push hl
 12+  002C 21 00 F0         ld hl,CONSOLE_STATUS
 13+  002F 3E 02            ld a,CONSOLE_STATUS_BEANBOARD
 14+  0031 A6               and (hl)
 15+  0032 20 07            jr nz,_readchar_beanboard
 16+  0034 3E 01            ld a,CONSOLE_STATUS_USB
 17+  0036 A6               and (hl)
 18+  0037 20 07            jr nz,_readchar_usb
 19+  0039 18 08            jr _readchar_end
 20+  003B              _readchar_beanboard:
 21+  003B CD D2 02         call key_readchar
 22+  003E 18 03            jr _readchar_end
 23+  0040              _readchar_usb:
 24+  0040 CD 8A 00         call usb_readchar
 25+  0043              _readchar_end:
 26+  0043 E1               pop hl
 27+  0044 C9               ret
 28+  0045              ELSE
 29+  0045 ~            ; read a character from the console and return in A - return 0 if there is no character
 30+  0045 ~            readchar:
 31+  0045 ~                call usb_readchar
 32+  0045 ~                ret
 33+  0045              ENDIF
 34+  0045
 35+  0045              IF BEANBOARD
 36+  0045              ; sent character in A to the console
 37+  0045              putchar:
 38+  0045 E5               push hl
 39+  0046 C5               push bc
 40+  0047 47               ld b,a
 41+  0048 21 00 F0         ld hl,CONSOLE_STATUS
 42+  004B 3E 02            ld a,CONSOLE_STATUS_BEANBOARD
 43+  004D A6               and (hl)
 44+  004E 20 07            jr nz,_putchar_beanboard
 45+  0050 3E 01            ld a,CONSOLE_STATUS_USB
 46+  0052 A6               and (hl)
 47+  0053 20 08            jr nz,_putchar_usb
 48+  0055 18 0A            jr _putchar_end
 49+  0057              _putchar_beanboard:
 50+  0057 78               ld a,b
 51+  0058 CD 48 02         call lcd_putchar
 52+  005B 18 04            jr _putchar_end
 53+  005D              _putchar_usb:
 54+  005D 78               ld a,b
 55+  005E CD 9B 00         call usb_putchar
 56+  0061              _putchar_end:
 57+  0061 78               ld a,b
 58+  0062 C1               pop bc
 59+  0063 E1               pop hl
 60+  0064 C9               ret
 61+  0065              ELSE
 62+  0065 ~            ; sent character in A to the console
 63+  0065 ~            putchar:
 64+  0065 ~                push bc
 65+  0065 ~                ld b,a
 66+  0065 ~                call usb_putchar
 67+  0065 ~                ld a,b
 68+  0065 ~                pop bc
 69+  0065 ~                ret
 70+  0065              ENDIF
 71+  0065
 72+  0065              ; print a zero-terminated string pointed to by hl to the console
 73+  0065              puts:
 74+  0065 E5               push hl
 75+  0066              _puts_loop:
 76+  0066                  ; get character from string
 77+  0066 7E               ld a,(hl)
 78+  0067                  ; is it zero?
 79+  0067 FE 00            cp 0
 80+  0069                  ; yes
 81+  0069 28 07            jr z, _puts_end
 82+  006B                  ; no: send character
 83+  006B CD 45 00         call putchar
 84+  006E                  ; next character position
 85+  006E 23               inc hl
 86+  006F                  ; loop for next character
 87+  006F C3 66 00         jp _puts_loop
 88+  0072              _puts_end:
 89+  0072 E1               pop hl
 90+  0073 C9               ret
 91+  0074
 92+  0074              IF BEANBOARD
 93+  0074              ; determine which console should be active - Reset=beanboard, shift-Reset=USB
 94+  0074              beanboard_console_init:
 95+  0074                  ; check for modifier keys being held down
 96+  0074 CD 1F 03         call modifierkeys
 97+  0077                  ; shift key down?
 98+  0077 E6 01            and MOD_KEY_SHIFT
 99+  0079                  ; yes shift
100+  0079 C2 83 00         jp nz,_beanboard_console_init_usb
101+  007C                  ; no shift
102+  007C 3E 02            ld a,CONSOLE_STATUS_BEANBOARD
103+  007E 21 00 F0         ld hl,CONSOLE_STATUS
104+  0081 77               ld (hl),a
105+  0082 C9               ret
106+  0083              _beanboard_console_init_usb:
107+  0083 3E 01            ld a,CONSOLE_STATUS_USB
108+  0085 21 00 F0         ld hl,CONSOLE_STATUS
109+  0088 77               ld (hl),a
110+  0089 C9               ret
111+  008A              ENDIF
# file closed: asm/console.asm
 12   008A              include "asm/UM245R.asm"
# file opened: asm/UM245R.asm
  1+  008A              ; It is assumed that UM245R status signals are gated to the data bus as an IO port where:
  2+  008A              ; /TXE = bit 0
  3+  008A              ; /RXF = bit 1
  4+  008A              ; As per:
  5+  008A              ; https://github.com/PainfulDiodes/z80-breadboard-computer
  6+  008A              ;
  7+  008A              ; line endings are translated:
  8+  008A              ; incoming line endings from the terminal are expected to be \r
  9+  008A              ; and are tranlslated to \n
 10+  008A              ; (\r\n would count as 2 line endings)
 11+  008A              ; and outgoing line endings are sent as \r\n
 12+  008A              ; externally this is consistent with VT100/ANSI terminal behaviour
 13+  008A              ; and internally line endings are always \n
 14+  008A
 15+  008A              ; get character and return in A
 16+  008A              usb_readchar:
 17+  008A                  ; get the USB status
 18+  008A DB 00            in a,(UM245R_CTRL)
 19+  008C                  ; data to read? (active low)
 20+  008C CB 4F            bit 1,a
 21+  008E                  ; no, the buffer is empty
 22+  008E 20 08            jr nz,_usb_no_char
 23+  0090                  ; yes, read the received char
 24+  0090 DB 01            in a,(UM245R_DATA)
 25+  0092                  ; is CR?
 26+  0092 FE 0D            cp ESC_R
 27+  0094                  ; no:
 28+  0094 C0               ret nz
 29+  0095                  ; yes: convert CR to LF
 30+  0095 3E 0A            ld a, ESC_N
 31+  0097 C9               ret
 32+  0098              _usb_no_char:
 33+  0098 3E 00            ld a,0
 34+  009A C9               ret
 35+  009B
 36+  009B              usb_putchar:
 37+  009B                  ; newline?
 38+  009B FE 0A            cp ESC_N
 39+  009D                  ; no: just send the char
 40+  009D 20 07            jr nz,_do_usb_put
 41+  009F 3E 0D            ld a, ESC_R
 42+  00A1 CD AA 00         call _usb_put
 43+  00A4 3E 0A            ld a, ESC_N
 44+  00A6              _do_usb_put:
 45+  00A6 CD AA 00         call _usb_put
 46+  00A9 C9               ret
 47+  00AA
 48+  00AA              ; transmit character in A
 49+  00AA              _usb_put:
 50+  00AA C5               push bc
 51+  00AB                  ; stash the transmit character
 52+  00AB 47               ld b,a
 53+  00AC              _usb_put_loop:
 54+  00AC                  ; get the USB status
 55+  00AC DB 00            in a,(UM245R_CTRL)
 56+  00AE                  ; ready to transmit? (active low)
 57+  00AE CB 47            bit 0,a
 58+  00B0                  ; no: bit is high
 59+  00B0 20 FA            jr nz,_usb_put_loop
 60+  00B2                  ; yes: restore the stashed transmit character
 61+  00B2 78               ld a,b
 62+  00B3                  ; transmit the character
 63+  00B3 D3 01            out (UM245R_DATA),a
 64+  00B5 C1               pop bc
 65+  00B6 C9               ret
 66+  00B7
 67+  00B7              ; print a zero-terminated string pointed to by hl to the USB
 68+  00B7              usb_puts:
 69+  00B7 E5               push hl
 70+  00B8              _usb_puts_loop:
 71+  00B8                  ; get character from string
 72+  00B8 7E               ld a,(hl)
 73+  00B9                  ; is it zero?
 74+  00B9 FE 00            cp 0
 75+  00BB                  ; yes
 76+  00BB 28 07            jr z, _usb_puts_end
 77+  00BD                  ; no: send character
 78+  00BD CD 9B 00         call usb_putchar
 79+  00C0                  ; next character position
 80+  00C0 23               inc hl
 81+  00C1                  ; loop for next character
 82+  00C1 C3 B8 00         jp _usb_puts_loop
 83+  00C4              _usb_puts_end:
 84+  00C4 E1               pop hl
 85+  00C5 C9               ret
 86+  00C6
# file closed: asm/UM245R.asm
 13   00C6              include "asm/marvin.asm"
# file opened: asm/marvin.asm
  1+  00C6              ; ****************************************************
  2+  00C6              ; *  Marvin - a Z80 homebrew monitor program
  3+  00C6              ; * (c) Stephen Willcock 2024
  4+  00C6              ; * https://github.com/PainfulDiodes
  5+  00C6              ; ****************************************************
  6+  00C6
  7+  00C6              ; MAIN PROGRAM LOOP
  8+  00C6
  9+  00C6              MARVIN:
 10+  00C6                  ; point DE to zero - this is the default address argument for commands
 11+  00C6 11 00 00         ld de,0x0000
 12+  00C9
 13+  00C9 21 C4 03         ld hl,WELCOME_MSG
 14+  00CC CD 65 00         call puts
 15+  00CF
 16+  00CF              PROMPT:
 17+  00CF                  ; point HL to the beginning of the input buffer
 18+  00CF 21 20 F0         ld hl,CMD_BUFFER
 19+  00D2 3E 3E            ld a,'>'
 20+  00D4 CD 45 00         call putchar
 21+  00D7
 22+  00D7              _get_cmd:
 23+  00D7                  ; get character from console
 24+  00D7 CD 23 00         call getchar
 25+  00DA                  ; echo the character to console
 26+  00DA CD 45 00         call putchar
 27+  00DD                  ; is CR?
 28+  00DD FE 0D            cp ESC_R
 29+  00DF                  ; yes: skip this
 30+  00DF 28 F6            jr z,_get_cmd
 31+  00E1                  ; is tab?
 32+  00E1 FE 09            cp ESC_T
 33+  00E3                  ; yes: skip this
 34+  00E3 28 F2            jr z,_get_cmd
 35+  00E5                  ; is space?
 36+  00E5 FE 20            cp ' '
 37+  00E7                  ; yes - skip this
 38+  00E7 28 EE            jr z,_get_cmd
 39+  00E9                  ; escape?
 40+  00E9 FE 1B            cp ESC_E
 41+  00EB                  ; yes
 42+  00EB 28 08            jr z, _get_cmd_esc
 43+  00ED                  ; end of line?
 44+  00ED FE 0A            cp ESC_N
 45+  00EF                  ; yes
 46+  00EF 28 0B            jr z, _get_cmd_end
 47+  00F1                  ; no: add character to the buffer
 48+  00F1 77               ld(hl),a
 49+  00F2                  ; move pointer to next buffer location - we're not checking for overrun
 50+  00F2 23               inc hl
 51+  00F3                  ; next character
 52+  00F3 18 E2            jr _get_cmd
 53+  00F5                  ; do escape
 54+  00F5              _get_cmd_esc:
 55+  00F5                  ; new line
 56+  00F5 3E 0A            ld a,ESC_N
 57+  00F7 CD 45 00         call putchar
 58+  00FA                  ; back to prompt
 59+  00FA 18 D3            jr PROMPT
 60+  00FC              _get_cmd_end:
 61+  00FC                  ; string terminator
 62+  00FC 3E 00            ld a,0
 63+  00FE                  ; add terminator to end of buffer
 64+  00FE 77               ld(hl),a
 65+  00FF              ; process command from buffer
 66+  00FF                  ; point to start of buffer
 67+  00FF 21 20 F0         ld hl,CMD_BUFFER
 68+  0102                  ; load character from buffer
 69+  0102 7E               ld a,(hl)
 70+  0103                  ; end of string?
 71+  0103 FE 00            cp 0
 72+  0105                  ; yes - empty line - go back to prompt
 73+  0105 28 C8            jr z,PROMPT
 74+  0107                  ; advance the buffer pointer
 75+  0107 23               inc hl
 76+  0108 FE 72            cp 'r'
 77+  010A 28 15            jr z,_cmd_read
 78+  010C FE 77            cp 'w'
 79+  010E 28 47            jr z,_cmd_write
 80+  0110 FE 78            cp 'x'
 81+  0112 28 68            jr z,_cmd_execute
 82+  0114                  ; ':' = load from intel hex format
 83+  0114 FE 3A            cp ':'
 84+  0116 28 79            jr z,_cmd_load
 85+  0118                  ; otherwise error
 86+  0118 21 ED 03         ld hl,BAD_CMD_MSG
 87+  011B CD 65 00         call puts
 88+  011E                  ; loop back to the prompt
 89+  011E C3 CF 00         jp PROMPT
 90+  0121
 91+  0121              ; COMMANDS
 92+  0121
 93+  0121              ; READ
 94+  0121              ; read bytes from memory and send hex values to console
 95+  0121              _cmd_read:
 96+  0121                  ; load character from buffer
 97+  0121 7E               ld a,(hl)
 98+  0122                  ; end of string?
 99+  0122 FE 00            cp 0
100+  0124                  ; yes: no address argument, so skip to read row
101+  0124 28 08            jr z, _cmd_read_row
102+  0126                  ; parse first pair of characters
103+  0126 CD C0 01         call hex_byte_val
104+  0129                  ; load into upper byte of memory pointer
105+  0129 57               ld d,a
106+  012A                  ; parse second pair of characters
107+  012A CD C0 01         call hex_byte_val
108+  012D                  ; load into lower byte of memory pointer
109+  012D 5F               ld e,a
110+  012E              _cmd_read_row:
111+  012E                  ; initialise byte counter - each row will have this many bytes
112+  012E 0E 10            ld c, 0x10
113+  0130                  ; print DE content: the read address
114+  0130 7A               ld a,d
115+  0131 CD F4 01         call putchar_hex
116+  0134 7B               ld a,e
117+  0135 CD F4 01         call putchar_hex
118+  0138                  ; separator between address and data
119+  0138 3E 3A            ld a,':'
120+  013A CD 45 00         call putchar
121+  013D 3E 20            ld a,' '
122+  013F CD 45 00         call putchar
123+  0142                  ; get a byte
124+  0142              _cmd_read_byte:
125+  0142 1A               ld a,(de)
126+  0143                  ; and print it
127+  0143 CD F4 01         call putchar_hex
128+  0146                  ; add space between bytes
129+  0146 3E 20            ld a,' '
130+  0148 CD 45 00         call putchar
131+  014B                  ; next address
132+  014B 13               inc de
133+  014C                  ; reduce byte counter
134+  014C                  ; TODO djnz ?
135+  014C 0D               dec c
136+  014D                  ; repeat if the counter is not 0
137+  014D 20 F3            jr nz, _cmd_read_byte
138+  014F                  ; otherwise, new line
139+  014F 3E 0A            ld a,ESC_N
140+  0151 CD 45 00         call putchar
141+  0154                  ; and back to prompt
142+  0154 C3 CF 00         jp PROMPT
143+  0157
144+  0157              ; WRITE
145+  0157
146+  0157              ; write bytes to memory interpreting hex values from console
147+  0157              _cmd_write:
148+  0157                  ; load character from buffer
149+  0157 7E               ld a,(hl)
150+  0158                  ; end of string?
151+  0158 FE 00            cp 0
152+  015A                  ; yes: no data
153+  015A 28 17            jr z, _cmd_write_null
154+  015C                  ; parse first pair of characters - address high
155+  015C CD C0 01         call hex_byte_val
156+  015F                  ; load into upper byte of memory pointer
157+  015F 57               ld d,a
158+  0160                  ; parse second pair of characters - address low
159+  0160 CD C0 01         call hex_byte_val
160+  0163                  ; load into lower byte of memory pointer
161+  0163 5F               ld e,a
162+  0164              _cmd_write_data:
163+  0164                  ; load character from buffer
164+  0164 7E               ld a,(hl)
165+  0165                  ; end of string?
166+  0165 FE 00            cp 0
167+  0167                  ; yes: we're done
168+  0167 28 07            jr z, _cmd_write_end
169+  0169                  ; parse data byte
170+  0169 CD C0 01         call hex_byte_val
171+  016C                  ; write byte to memory
172+  016C 12               ld (de),a
173+  016D                  ; advance destination pointer
174+  016D 13               inc de
175+  016E 18 F4            jr _cmd_write_data
176+  0170              _cmd_write_end:
177+  0170 C3 CF 00         jp PROMPT
178+  0173                  ; w with no data
179+  0173              _cmd_write_null:
180+  0173 21 FA 03         ld hl,CMD_W_NULL_MSG
181+  0176 CD 65 00         call puts
182+  0179                  ; and back to prompt
183+  0179 C3 CF 00         jp PROMPT
184+  017C
185+  017C              ; EXECUTE
186+  017C
187+  017C              ; start executing from given address
188+  017C              _cmd_execute:
189+  017C                  ; load character from buffer
190+  017C 7E               ld a,(hl)
191+  017D                  ; end of string?
192+  017D FE 00            cp 0
193+  017F                  ; yes - no data
194+  017F CA 8D 01         jp z, _cmd_exec_df
195+  0182                  ; parse first pair of characters - address high
196+  0182 CD C0 01         call hex_byte_val
197+  0185                  ; load into upper byte of memory pointer
198+  0185 57               ld d,a
199+  0186                  ; parse second pair of characters - address low
200+  0186 CD C0 01         call hex_byte_val
201+  0189                  ; load into lower byte of memory pointer
202+  0189 5F               ld e,a
203+  018A 62 6B            ld hl,de
204+  018C                  ; execute from address
205+  018C E9               jp (hl)
206+  018D                  ; start executing from default address
207+  018D              _cmd_exec_df:
208+  018D 21 00 80         ld hl,RAMSTART
209+  0190                  ; execute from address
210+  0190 E9               jp (hl)
211+  0191
212+  0191              ; LOAD
213+  0191
214+  0191              ; load from INTEL HEX - records are read from the buffer
215+  0191              _cmd_load:
216+  0191                  ; load character from buffer
217+  0191 7E               ld a,(hl)
218+  0192                  ; end of string?
219+  0192 FE 00            cp 0
220+  0194                  ; yes: no data - quit
221+  0194 CA BD 01         jp z, _cmd_load_end
222+  0197                  ; parse first pair of characters - byte count
223+  0197 CD C0 01         call hex_byte_val
224+  019A FE 00            cp 0
225+  019C                  ; yes - zero byte count - quit
226+  019C CA BD 01         jp z, _cmd_load_end
227+  019F                  ; load byte count into C
228+  019F 4F               ld c,a
229+  01A0                  ; parse address high
230+  01A0 CD C0 01         call hex_byte_val
231+  01A3                  ; load into upper byte of memory pointer
232+  01A3 57               ld d,a
233+  01A4                  ; parse address low
234+  01A4 CD C0 01         call hex_byte_val
235+  01A7                  ; load into lower byte of memory pointer
236+  01A7 5F               ld e,a
237+  01A8                  ; parse record type
238+  01A8 CD C0 01         call hex_byte_val
239+  01AB                  ; record type zero?
240+  01AB FE 00            cp 0
241+  01AD                  ; no: quit
242+  01AD C2 BD 01         jp nz, _cmd_load_end
243+  01B0              _cmd_load_data:
244+  01B0                  ; load character from buffer
245+  01B0 7E               ld a,(hl)
246+  01B1                  ; end of string?
247+  01B1 FE 00            cp 0
248+  01B3                  ; yes: we're done
249+  01B3 28 08            jr z, _cmd_load_end
250+  01B5                  ; no:
251+  01B5                  ; parse data byte
252+  01B5 CD C0 01         call hex_byte_val
253+  01B8                  ; write byte to memory
254+  01B8 12               ld (de),a
255+  01B9                  ; advance destination pointer
256+  01B9 13               inc de
257+  01BA                  ; decrement byte counter
258+  01BA                  ; TODO djnz
259+  01BA 0D               dec c
260+  01BB                  ; if byte counter not zero then go again
261+  01BB 20 F3            jr nz,_cmd_load_data
262+  01BD              _cmd_load_end:
263+  01BD C3 CF 00         jp PROMPT
# file closed: asm/marvin.asm
 14   01C0              include "asm/strings.asm"
# file opened: asm/strings.asm
  1+  01C0              ; string subroutines
  2+  01C0
  3+  01C0              ; read 2 ASCII hex chars from memory by HL pointer, return converted value in A and advance HL pointer
  4+  01C0              hex_byte_val:
  5+  01C0                  ; preserve BC
  6+  01C0 C5               push bc
  7+  01C1                  ; load 1st character from memory
  8+  01C1 7E               ld a,(hl)
  9+  01C2                  ; end of string?
 10+  01C2 FE 00            cp 0
 11+  01C4                  ; yes: no value - return zero
 12+  01C4 28 19            jr z,_hex_byte_val_zero
 13+  01C6                  ; no:
 14+  01C6                  ; advance the buffer pointer
 15+  01C6 23               inc hl
 16+  01C7                  ; convert first hex digit
 17+  01C7 CD E3 01         call hex_val
 18+  01CA                  ; shift left 4 bits to put value into top nibble
 19+  01CA CB 27            sla a
 20+  01CC CB 27            sla a
 21+  01CE CB 27            sla a
 22+  01D0 CB 27            sla a
 23+  01D2                  ; cache the result
 24+  01D2 47               ld b,a
 25+  01D3                  ; load 2nd character from memory
 26+  01D3 7E               ld a,(hl)
 27+  01D4                  ; end of string?
 28+  01D4 FE 00            cp 0
 29+  01D6                  ; yes: incomplete byte - return zero
 30+  01D6 28 07            jr z,_hex_byte_val_zero
 31+  01D8                  ; advance the buffer pointer
 32+  01D8 23               inc hl
 33+  01D9                  ; and convert 2nd hex digit
 34+  01D9 CD E3 01         call hex_val
 35+  01DC                  ; add first and second digits
 36+  01DC 80               add a,b
 37+  01DD                  ; restore BC
 38+  01DD C1               pop bc
 39+  01DE C9               ret
 40+  01DF              _hex_byte_val_zero:
 41+  01DF                  ; zero return value
 42+  01DF 3E 00            ld a,0
 43+  01E1                  ; restore BC
 44+  01E1 C1               pop bc
 45+  01E2 C9               ret
 46+  01E3
 47+  01E3              ; convert an ASCII hex char in A to a number value (lower 4 bits)
 48+  01E3              hex_val:
 49+  01E3                  ; is it lowercase alphabetic?
 50+  01E3 FE 61            cp 'a'
 51+  01E5                  ; no: uppercase/numeric
 52+  01E5 38 03            jr c,_hex_val_u_n
 53+  01E7                  ; yes: alphabetic
 54+  01E7 D6 57            sub 'a'-0x0a
 55+  01E9 C9               ret
 56+  01EA              _hex_val_u_n:
 57+  01EA                  ; is it uppercase alphabetic?
 58+  01EA FE 41            cp 'A'
 59+  01EC                  ; no: numeric
 60+  01EC 38 03            jr c,_hex_val_n
 61+  01EE                  ; y:
 62+  01EE D6 37            sub 'A'-0x0a
 63+  01F0 C9               ret
 64+  01F1              _hex_val_n:
 65+  01F1                  ; numeric
 66+  01F1 D6 30            sub '0'
 67+  01F3 C9               ret
 68+  01F4
 69+  01F4              ; convert value in A into an ASCII pair and send to console
 70+  01F4              putchar_hex:
 71+  01F4 F5               push af
 72+  01F5 C5               push bc
 73+  01F6                  ; stash in B
 74+  01F6 47               ld b,a
 75+  01F7                  ; shift A right x4 e.g. transform 10110010 to 00001011
 76+  01F7 CB 3F            srl a
 77+  01F9 CB 3F            srl a
 78+  01FB CB 3F            srl a
 79+  01FD CB 3F            srl a
 80+  01FF                  ; most significant digit
 81+  01FF CD 0B 02         call _putchar_hex_dgt
 82+  0202                  ; recover from stash
 83+  0202 78               ld a,b
 84+  0203                  ; clear the top 4 bits
 85+  0203 E6 0F            and 0b00001111
 86+  0205                  ; least significant digit
 87+  0205 CD 0B 02         call _putchar_hex_dgt
 88+  0208 C1               pop bc
 89+  0209 F1               pop af
 90+  020A C9               ret
 91+  020B              _putchar_hex_dgt:
 92+  020B                  ; is it an alpha or numeric?
 93+  020B FE 0A            cp 0x0a
 94+  020D                  ; numeric
 95+  020D 38 06            jr c,_putchar_hex_n
 96+  020F                  ; alpha
 97+  020F                  ; for alpha add the base ascii for 'a' but then sub 10 / 0x0a as hex 'a' = 10d
 98+  020F C6 57            add a,'a'-0x0a
 99+  0211 CD 45 00         call putchar
100+  0214 C9               ret
101+  0215              _putchar_hex_n:
102+  0215                  ; for numeric add the base ascii for '0'
103+  0215 C6 30            add a,'0'
104+  0217 CD 45 00         call putchar
105+  021A C9               ret
106+  021B
# file closed: asm/strings.asm
 15   021B              include "asm/HD44780LCD.asm"
# file opened: asm/HD44780LCD.asm
  1+  021B              ; initialise LCD
  2+  021B              lcd_init:
  3+  021B              ; preserve registers
  4+  021B F5               push af
  5+  021C              ; intitialise device
  6+  021C 3E 38        	ld a,LCD_FUNCTION_SET+LCD_DATA_LEN_8+LCD_DISP_LINES_2+LCD_FONT_8
  7+  021E CD 32 02     	call lcd_putcmd
  8+  0221 3E 0F        	ld a,LCD_DISPLAY_ON_OFF_CONTROL+LCD_DISPLAY_ON+LCD_CURSOR_ON+LCD_BLINK_ON
  9+  0223 CD 32 02     	call lcd_putcmd
 10+  0226 3E 01        	ld a,LCD_CLEAR_DISPLAY
 11+  0228 CD 32 02     	call lcd_putcmd
 12+  022B 3E D4            ld a,LCD_SET_DDRAM_ADDR+LCD_LINE_3_ADDR
 13+  022D CD 32 02     	call lcd_putcmd
 14+  0230
 15+  0230              ; restore registers
 16+  0230 F1               pop af
 17+  0231 C9               ret
 18+  0232
 19+  0232              ; transmit character in A to the LCD control port
 20+  0232              lcd_putcmd:
 21+  0232 C5               push bc
 22+  0233              ; save the transmit character
 23+  0233 47               ld b,a
 24+  0234              _lcd_putcmd_loop:
 25+  0234              ; get the LCD status
 26+  0234 DB 04            in a,(LCD_CTRL)
 27+  0236              ; busy ?
 28+  0236 CB 7F            bit 7,a
 29+  0238              ; yes
 30+  0238 20 FA            jr nz,_lcd_putcmd_loop
 31+  023A              ; no, restore the transmit character
 32+  023A 78               ld a,b
 33+  023B              ; transmit the character
 34+  023B D3 04            out (LCD_CTRL),a
 35+  023D C1               pop bc
 36+  023E C9               ret
 37+  023F
 38+  023F              ; get character from LCD data port and return in A
 39+  023F              lcd_getchar:
 40+  023F              ; get the LCD status
 41+  023F DB 04            in a,(LCD_CTRL)
 42+  0241              ; busy ?
 43+  0241 CB 7F            bit 7,a
 44+  0243              ; yes
 45+  0243 20 FA            jr nz,lcd_getchar
 46+  0245              ; no, get a character
 47+  0245 DB 05            in a,(LCD_DATA)
 48+  0247 C9               ret
 49+  0248
 50+  0248              ; transmit character in A to the LCD data port
 51+  0248              lcd_putchar:
 52+  0248                  ; newline char?
 53+  0248 FE 0A            cp ESC_N
 54+  024A C2 59 02         jp nz,_lcd_putchar_printable
 55+  024D                  ; newline - fill out the line until EOL
 56+  024D              _lcd_putchar_pad:
 57+  024D 3E 20            ld a,' '
 58+  024F CD 6D 02         call _lcd_putdata
 59+  0252 FE 67            cp LCD_EOL_3
 60+  0254 CA 64 02         jp z,_lcd_putchar_eol3
 61+  0257                  ; loop until EOL
 62+  0257 18 F4            jr _lcd_putchar_pad
 63+  0259              _lcd_putchar_printable:
 64+  0259 CD 6D 02         call _lcd_putdata
 65+  025C                  ; check for overflow - DDRAM address returned in A
 66+  025C FE 67            cp LCD_EOL_3
 67+  025E CA 64 02         jp z,_lcd_putchar_eol3
 68+  0261 C3 6C 02         jp _lcd_putchar_end
 69+  0264              _lcd_putchar_eol3:
 70+  0264                  ; line feed
 71+  0264 CD 7E 02         call lcd_scroll
 72+  0267                  ; carriage return
 73+  0267 3E D4            ld a,LCD_SET_DDRAM_ADDR+LCD_LINE_3_ADDR
 74+  0269 CD 32 02     	call lcd_putcmd
 75+  026C              _lcd_putchar_end:
 76+  026C C9               ret
 77+  026D
 78+  026D              ; transmit character in A to the LCD data port,
 79+  026D              ; return in A the DDRAM address where the character was sent
 80+  026D              _lcd_putdata:
 81+  026D C5               push bc
 82+  026E                  ; save the transmit character
 83+  026E 47               ld b,a
 84+  026F              _lcd_putdata_loop:
 85+  026F                  ; get the LCD status
 86+  026F DB 04            in a,(LCD_CTRL)
 87+  0271                  ; busy ?
 88+  0271 CB 7F            bit 7,a
 89+  0273                  ; yes
 90+  0273 20 FA            jr nz,_lcd_putdata_loop
 91+  0275                  ; no, reset the 'busy' bit and preserve the DDRAM address
 92+  0275 E6 7F            and 0b01111111
 93+  0277 4F               ld c,a
 94+  0278                  ; restore the transmit character and send it
 95+  0278 78               ld a,b
 96+  0279 D3 05            out (LCD_DATA),a
 97+  027B                  ; restore the DDRAM address
 98+  027B 79               ld a,c
 99+  027C C1               pop bc
100+  027D C9               ret
101+  027E
102+  027E              lcd_scroll:
103+  027E C5               push bc
104+  027F D5               push de
105+  0280 16 C0            ld d,LCD_SET_DDRAM_ADDR+LCD_LINE_1_ADDR
106+  0282 1E 80            ld e,LCD_SET_DDRAM_ADDR+LCD_LINE_0_ADDR
107+  0284 CD 9D 02         call _lcd_scroll_line
108+  0287 16 94            ld d,LCD_SET_DDRAM_ADDR+LCD_LINE_2_ADDR
109+  0289 1E C0            ld e,LCD_SET_DDRAM_ADDR+LCD_LINE_1_ADDR
110+  028B CD 9D 02         call _lcd_scroll_line
111+  028E 16 D4            ld d,LCD_SET_DDRAM_ADDR+LCD_LINE_3_ADDR
112+  0290 1E 94            ld e,LCD_SET_DDRAM_ADDR+LCD_LINE_2_ADDR
113+  0292 CD 9D 02         call _lcd_scroll_line
114+  0295 3E D4            ld a,LCD_SET_DDRAM_ADDR+LCD_LINE_3_ADDR
115+  0297 CD B6 02         call _lcd_scroll_clear_line
116+  029A D1               pop de
117+  029B C1               pop bc
118+  029C C9               ret
119+  029D              _lcd_scroll_line:
120+  029D                  ; b = character counter
121+  029D                  ; c = stash char
122+  029D                  ; d = source line to copy from
123+  029D                  ; e = destination line to copy to
124+  029D 06 14            ld b,LCD_LINE_LEN
125+  029F              _lcd_scroll_line_loop:
126+  029F                  ; load source
127+  029F 7A               ld a,d
128+  02A0                  ; character counter is an offset
129+  02A0 80               add b
130+  02A1                  ; zero based index so -1
131+  02A1 3D               dec a
132+  02A2 CD 32 02         call lcd_putcmd
133+  02A5 CD 3F 02         call lcd_getchar
134+  02A8                  ; stash the value
135+  02A8 4F               ld c,a
136+  02A9                  ; load destination
137+  02A9 7B               ld a,e
138+  02AA                  ; character counter is an offset
139+  02AA 80               add b
140+  02AB                  ; zero based index so -1
141+  02AB 3D               dec a
142+  02AC CD 32 02         call lcd_putcmd
143+  02AF                  ; recover the stashed value
144+  02AF 79               ld a,c
145+  02B0 CD 6D 02         call _lcd_putdata
146+  02B3 10 EA            djnz _lcd_scroll_line_loop
147+  02B5 C9               ret
148+  02B6              _lcd_scroll_clear_line:
149+  02B6                  ; a = destination line to clear
150+  02B6                  ; b = character counter
151+  02B6 06 14            ld b,LCD_LINE_LEN
152+  02B8 CD 32 02         call lcd_putcmd
153+  02BB              _lcd_scroll_clear_line_loop:
154+  02BB 3E 20            ld a,' '
155+  02BD CD 6D 02         call _lcd_putdata
156+  02C0 10 F9            djnz _lcd_scroll_clear_line_loop
157+  02C2 C9               ret
158+  02C3
159+  02C3              ; print a zero-terminated string pointed to by hl to the LCD
160+  02C3              lcd_puts:
161+  02C3 E5               push hl
162+  02C4              _lcd_puts_loop:
163+  02C4                  ; get character from string
164+  02C4 7E               ld a,(hl)
165+  02C5                  ; is it zero?
166+  02C5 FE 00            cp 0
167+  02C7                  ; yes
168+  02C7 28 07            jr z, _lcd_puts_end
169+  02C9                  ; no: send character
170+  02C9 CD 48 02         call lcd_putchar
171+  02CC                  ; next character position
172+  02CC 23               inc hl
173+  02CD                  ; loop for next character
174+  02CD C3 C4 02         jp _lcd_puts_loop
175+  02D0              _lcd_puts_end:
176+  02D0 E1               pop hl
177+  02D1 C9               ret
178+  02D2
# file closed: asm/HD44780LCD.asm
 16   02D2              include "asm/keymatrix.asm"
# file opened: asm/keymatrix.asm
  1+  02D2              DEBOUNCE_DELAY  equ 0x4000
  2+  02D2
  3+  02D2              MOD_KEY_SHIFT   equ 0b00000001
  4+  02D2              MOD_KEY_FN      equ 0b00000010
  5+  02D2              MOD_KEY_CONTROL equ 0b00000100
  6+  02D2              MOD_KEY_ALT     equ 0b00001000
  7+  02D2              MOD_KEY_CMD     equ 0b00010000
  8+  02D2
  9+  02D2              ; return keyboard char value in A, or 0
 10+  02D2              key_readchar:
 11+  02D2 C5               push bc
 12+  02D3 D5               push de
 13+  02D4 E5               push hl
 14+  02D5                  ; initial row bit - only 1 bit is ever set at a time - it is shifted from bit 0 to bit 7
 15+  02D5 06 01            ld b,0x01
 16+  02D7                  ; row counter - 0 => 7
 17+  02D7 0E 00            ld c,0x00
 18+  02D9                  ; location of previous values
 19+  02D9 21 10 F0         ld hl,KEY_MATRIX_BUFFER
 20+  02DC CD 1F 03         call modifierkeys
 21+  02DF                  ; initialise map pointer
 22+  02DF 11 44 03         ld de,QWERTY_KEYMAP_L
 23+  02E2                  ; shift key down?
 24+  02E2 E6 01            and MOD_KEY_SHIFT
 25+  02E4 CA EA 02         jp z,_keyscanloop
 26+  02E7 11 84 03         ld de,QWERTY_KEYMAP_U
 27+  02EA              _keyscanloop:
 28+  02EA CD 12 03         call _rowscan
 29+  02ED                  ; ASCII returned in A, or 0
 30+  02ED CD 2F 03         call _colscan
 31+  02F0 FE 00            cp 0
 32+  02F2 C2 FC 02         jp nz,key_readchar_end
 33+  02F5                  ; move the pointer of previous values to the next row slot
 34+  02F5 23               inc hl
 35+  02F6                  ; increment row counter
 36+  02F6 0C               inc c
 37+  02F7                  ; clear the carry flag
 38+  02F7 B7               or a
 39+  02F8                  ; shift row bit left - when we've done all 8, it will move to the carry flag
 40+  02F8 CB 10            rl b
 41+  02FA                  ; loop if not done all rows
 42+  02FA 30 EE            jr nc,_keyscanloop
 43+  02FC              key_readchar_end:
 44+  02FC                  ; debounce delay, restore state and return
 45+  02FC CD 03 03         call _debounce_delay
 46+  02FF E1               pop hl
 47+  0300 D1               pop de
 48+  0301 C1               pop bc
 49+  0302 C9               ret
 50+  0303
 51+  0303              _debounce_delay:
 52+  0303 F5               push af
 53+  0304 D5               push de
 54+  0305 11 00 40         ld de,DEBOUNCE_DELAY
 55+  0308              _delay_loop:
 56+  0308 1B               dec de
 57+  0309 00               nop
 58+  030A 7A               ld a, d
 59+  030B FE 00            cp 0
 60+  030D 20 F9            jr nz,_delay_loop
 61+  030F              _delay_end:
 62+  030F D1               pop de
 63+  0310 F1               pop af
 64+  0311 C9               ret
 65+  0312
 66+  0312              ; get row bitmap representing new keystrokes:
 67+  0312              ; B contains row bit,
 68+  0312              ; C contains row count,
 69+  0312              ; HL contains a pointer to the old value.
 70+  0312              ; return value in A
 71+  0312              _rowscan:
 72+  0312                  ; preserve registers
 73+  0312 D5               push de
 74+  0313                  ; fetch previous value for comparison
 75+  0313 7E               ld a,(hl)
 76+  0314                  ; invert A - we want to check keys becoming closed - so zeroed bits on the previous value are significant
 77+  0314 2F               cpl
 78+  0315                  ; store inverted previous value
 79+  0315 57               ld d,a
 80+  0316                  ; get the current row bit
 81+  0316 78               ld a,b
 82+  0317                  ; output row strobe
 83+  0317 D3 02            out (KEYSCAN_OUT),a
 84+  0319                  ; get column values
 85+  0319 DB 03            in a,(KEYSCAN_IN)
 86+  031B                  ; store the new value
 87+  031B 77               ld (hl),a
 88+  031C                  ; newVal AND ~oldVal means bits are set only when the previous bit value was 0
 89+  031C A2               and d
 90+  031D                  ; restore registers
 91+  031D D1               pop de
 92+  031E C9               ret
 93+  031F
 94+  031F              ; return bitmap representing modifier keys in A
 95+  031F              modifierkeys:
 96+  031F 3E 10            ld a,0b00010000 ; row 4
 97+  0321                  ; output row strobe
 98+  0321 D3 02            out (KEYSCAN_OUT),a
 99+  0323                  ; get column values
100+  0323 DB 03            in a,(KEYSCAN_IN)
101+  0325 E6 01            and 0b00000001 ; row 4, bit 0 is SHIFT
102+  0327                  ; left shift modifier
103+  0327 20 03            jr nz,_modifier_shift
104+  0329                  ; no modifiers
105+  0329 3E 00            ld a,0
106+  032B C9               ret
107+  032C              _modifier_shift:
108+  032C 3E 01            ld a,MOD_KEY_SHIFT
109+  032E C9               ret
110+  032F
111+  032F              ; A contains row bitmap representing new keystrokes,
112+  032F              ; DE contains a pointer to the ASCII map for the row - which is incremented in the subroutine
113+  032F              ; first printable character returned in A
114+  032F              _colscan:
115+  032F                  ; preserve registers
116+  032F C5               push bc
117+  0330                  ; initialise col bit mask - only 1 bit is ever set at a time - it is shifted from bit 0 to bit 7
118+  0330 0E 01            ld c,0x01
119+  0332                  ; stash the bitmap
120+  0332 47               ld b,a
121+  0333              _colscanloop:
122+  0333                  ; reload the bitmap
123+  0333 78               ld a,b
124+  0334                  ; mask the bitmap - use the column mask (C) over the bitmap value in A
125+  0334 A1               and c
126+  0335                  ; if zero then no keypress
127+  0335 28 05            jr z,_colscanloopnext
128+  0337 1A               ld a,(de)
129+  0338                  ; ASCII is 0?
130+  0338 FE 00            cp 0
131+  033A 20 06            jr nz,_colscanend
132+  033C              _colscanloopnext:
133+  033C                  ; increment character map pointer
134+  033C 13               inc de
135+  033D                  ; clear the carry flag
136+  033D B7               or a
137+  033E                  ; shift row bit left - when we've done all 8, it will move to the carry flag
138+  033E CB 11            rl c
139+  0340                  ; loop if not done all rows
140+  0340 30 F1            jr nc,_colscanloop
141+  0342              _colscanend:
142+  0342                  ; restore registers
143+  0342 C1               pop bc
144+  0343 C9               ret
145+  0344
146+  0344              ; define values for control keys
147+  0344              ; modifiers have zero value
148+  0344              QWERTY_SHIFT equ 0
149+  0344              QWERTY_FN equ 0
150+  0344              QWERTY_CTRL equ 0
151+  0344              QWERTY_ALT equ 0
152+  0344              QWERTY_CMD equ 0
153+  0344              QWERTY_CURS_UP equ 1
154+  0344              QWERTY_CURS_DOWN equ 2
155+  0344              QWERTY_CURS_LEFT equ 3
156+  0344              QWERTY_CURS_RIGHT equ 4
157+  0344              QWERTY_CAPS equ 5
158+  0344
159+  0344              QWERTY_KEYMAP_L:
160+  0344 1B 71 77 65      db ESC_E,'q','w','e','r','t','y','u','i','o','p',QWERTY_CAPS,ESC_B,'7','8','9'
160+  0348 72 74 79 75
160+  034C 69 6F 70 05
160+  0350 08 37 38 39
161+  0354 09 61 73 64      db ESC_T,'a','s','d','f','g','h','j','k','l',';',QUOTE,ESC_N,'4','5','6'
161+  0358 66 67 68 6A
161+  035C 6B 6C 3B 27
161+  0360 0A 34 35 36
162+  0364 00 7A 78 63      db QWERTY_SHIFT,'z','x','c','v','b','n','m',',','.','/',SLASH,QWERTY_CURS_UP,'1','2','3'
162+  0368 76 62 6E 6D
162+  036C 2C 2E 2F 5C
162+  0370 01 31 32 33
163+  0374 00 00 00 00      db QWERTY_FN,QWERTY_CTRL,QWERTY_ALT,QWERTY_CMD,' ','[',']',' ','`','-','=',QWERTY_CURS_LEFT,QWERTY_CURS_DOWN,QWERTY_CURS_RIGHT,'0',ESC_N
163+  0378 20 5B 5D 20
163+  037C 60 2D 3D 03
163+  0380 02 04 30 0A
164+  0384              QWERTY_KEYMAP_U:
165+  0384 1B 51 57 45      db ESC_E,'Q','W','E','R','T','Y','U','I','O','P',QWERTY_CAPS,ESC_B,'&','*','('
165+  0388 52 54 59 55
165+  038C 49 4F 50 05
165+  0390 08 26 2A 28
166+  0394 09 41 53 44      db ESC_T,'A','S','D','F','G','H','J','K','L',':','"',ESC_N,'$','%','^'
166+  0398 46 47 48 4A
166+  039C 4B 4C 3A 22
166+  03A0 0A 24 25 5E
167+  03A4 00 5A 58 43      db QWERTY_SHIFT,'Z','X','C','V','B','N','M','<','>','?',SLASH,QWERTY_CURS_UP,'!','@','#'
167+  03A8 56 42 4E 4D
167+  03AC 3C 3E 3F 5C
167+  03B0 01 21 40 23
168+  03B4 00 00 00 00      db QWERTY_FN,QWERTY_CTRL,QWERTY_ALT,QWERTY_CMD,' ','{','}',' ','~','_','+',QWERTY_CURS_LEFT,QWERTY_CURS_DOWN,QWERTY_CURS_RIGHT,')',ESC_N
168+  03B8 20 7B 7D 20
168+  03BC 7E 5F 2B 03
168+  03C0 02 04 29 0A
169+  03C4
# file closed: asm/keymatrix.asm
 17   03C4              include "asm/messages_small.asm"
# file opened: asm/messages_small.asm
  1+  03C4              WELCOME_MSG:
  2+  03C4 50 61 69 6E                  db "PainfulDiodes\n"
  2+  03C8 66 75 6C 44
  2+  03CC 69 6F 64 65
  2+  03D0 73 0A
  3+  03D2 4D 41 52 56                  db "MARVIN Z80 monitor\n"
  3+  03D6 49 4E 20 5A
  3+  03DA 38 30 20 6D
  3+  03DE 6F 6E 69 74
  3+  03E2 6F 72 0A
  4+  03E5 76 31 2E 32                  db "v1.2.1\n",0
  4+  03E9 2E 31 0A 00
  5+  03ED
  6+  03ED
  7+  03ED              BAD_CMD_MSG:
  8+  03ED 42 61 64 20                  db "Bad command\n",0
  8+  03F1 63 6F 6D 6D
  8+  03F5 61 6E 64 0A
  8+  03F9 00
  9+  03FA
 10+  03FA              CMD_W_NULL_MSG:
 11+  03FA 4E 6F 20 64                  db "No data\n",0
 11+  03FE 61 74 61 0A
 11+  0402 00
# file closed: asm/messages_small.asm
# file closed: beanboard.asm

Value    Label
------ - -----------------------------------------------------------
0x0005   QWERTY_CAPS
0x0004   QWERTY_CURS_RIGHT
0x0003   QWERTY_CURS_LEFT
0x0002   QWERTY_CURS_DOWN
0x0001   QWERTY_CURS_UP
0x0000   QWERTY_CMD
0x0000   QWERTY_ALT
0x0000   QWERTY_CTRL
0x0000   QWERTY_FN
0x0000   QWERTY_SHIFT
0x0342   _colscanend
0x033C   _colscanloopnext
0x0333   _colscanloop
0x032C   _modifier_shift
0x030F X _delay_end
0x0308   _delay_loop
0x0303   _debounce_delay
0x02FC   key_readchar_end
0x032F   _colscan
0x0312   _rowscan
0x0384   QWERTY_KEYMAP_U
0x02EA   _keyscanloop
0x0344   QWERTY_KEYMAP_L
0x0010 X MOD_KEY_CMD
0x0008 X MOD_KEY_ALT
0x0004 X MOD_KEY_CONTROL
0x0002 X MOD_KEY_FN
0x4000   DEBOUNCE_DELAY
0x02D0   _lcd_puts_end
0x02C4   _lcd_puts_loop
0x02C3 X lcd_puts
0x02BB   _lcd_scroll_clear_line_loop
0x029F   _lcd_scroll_line_loop
0x02B6   _lcd_scroll_clear_line
0x029D   _lcd_scroll_line
0x026F   _lcd_putdata_loop
0x027E   lcd_scroll
0x026C   _lcd_putchar_end
0x0264   _lcd_putchar_eol3
0x026D   _lcd_putdata
0x024D   _lcd_putchar_pad
0x0259   _lcd_putchar_printable
0x023F   lcd_getchar
0x0234   _lcd_putcmd_loop
0x0232   lcd_putcmd
0x0215   _putchar_hex_n
0x020B   _putchar_hex_dgt
0x01F1   _hex_val_n
0x01EA   _hex_val_u_n
0x01E3   hex_val
0x01DF   _hex_byte_val_zero
0x01B0   _cmd_load_data
0x01BD   _cmd_load_end
0x018D   _cmd_exec_df
0x03FA   CMD_W_NULL_MSG
0x0170   _cmd_write_end
0x0164   _cmd_write_data
0x0173   _cmd_write_null
0x0142   _cmd_read_byte
0x01F4   putchar_hex
0x01C0   hex_byte_val
0x012E   _cmd_read_row
0x03ED   BAD_CMD_MSG
0x0191   _cmd_load
0x017C   _cmd_execute
0x0157   _cmd_write
0x0121   _cmd_read
0x00FC   _get_cmd_end
0x00F5   _get_cmd_esc
0x00D7   _get_cmd
0x03C4   WELCOME_MSG
0x00C4   _usb_puts_end
0x00B8   _usb_puts_loop
0x00B7 X usb_puts
0x00AC   _usb_put_loop
0x00AA   _usb_put
0x00A6   _do_usb_put
0x0098   _usb_no_char
0x0083   _beanboard_console_init_usb
0x0001   MOD_KEY_SHIFT
0x031F   modifierkeys
0x0072   _puts_end
0x0066   _puts_loop
0x0065   puts
0x009B   usb_putchar
0x0248   lcd_putchar
0x0061   _putchar_end
0x005D   _putchar_usb
0x0057   _putchar_beanboard
0x0045   putchar
0x008A   usb_readchar
0x02D2   key_readchar
0x0043   _readchar_end
0x0040   _readchar_usb
0x003B   _readchar_beanboard
0x002B   readchar
0x0023   getchar
0x00CF   PROMPT
0x0020 X WARMSTART2
0x00C6   MARVIN
0x0010 X WARMSTART
0x0074   beanboard_console_init
0x021B   lcd_init
0x0067   LCD_EOL_3
0x0027 X LCD_EOL_2
0x0053 X LCD_EOL_1
0x0013 X LCD_EOL_0
0x0054   LCD_LINE_3_ADDR
0x0014   LCD_LINE_2_ADDR
0x0040   LCD_LINE_1_ADDR
0x0000   LCD_LINE_0_ADDR
0x0050 X LCD_BUFFER_LEN
0x0004   LCD_NUM_LINES
0x0014   LCD_LINE_LEN
0x0000   LCD_FONT_8
0x0004 X LCD_FONT_10
0x0000 X LCD_DISP_LINES_1
0x0008   LCD_DISP_LINES_2
0x0000 X LCD_DATA_LEN_4
0x0010   LCD_DATA_LEN_8
0x0000 X LCD_SHIFT_LEFT
0x0004 X LCD_SHIFT_RIGHT
0x0000 X LCD_SHIFT_CURSOR
0x0008 X LCD_SHIFT_DISPLAY
0x0000 X LCD_BLINK_OFF
0x0001   LCD_BLINK_ON
0x0000 X LCD_CURSOR_OFF
0x0002   LCD_CURSOR_ON
0x0000 X LCD_DISPLAY_OFF
0x0004   LCD_DISPLAY_ON
0x0000 X LCD_ENTRY_NO_SHIFT
0x0001 X LCD_ENTRY_SHIFT
0x0000 X LCD_ENTRY_DEC
0x0002 X LCD_ENTRY_INC
0x0080   LCD_SET_DDRAM_ADDR
0x0040 X LCD_SET_CGRAM_ADDR
0x0020   LCD_FUNCTION_SET
0x0010 X LCD_CURSOR_DISPLAY_SHIFT
0x0008   LCD_DISPLAY_ON_OFF_CONTROL
0x0004 X LCD_ENTRY_MODE_SET
0x0002 X LCD_RETURN_HOME
0x0001   LCD_CLEAR_DISPLAY
0x0027   QUOTE
0x005C   SLASH
0x001B   ESC_E
0x000D   ESC_R
0x000A   ESC_N
0x0009   ESC_T
0x0008   ESC_B
0x0002   CONSOLE_STATUS_BEANBOARD
0x0001   CONSOLE_STATUS_USB
0x0007 X GPIO_IN
0x0006 X GPIO_OUT
0x0005   LCD_DATA
0x0004   LCD_CTRL
0x0003   KEYSCAN_IN
0x0002   KEYSCAN_OUT
0x0001   UM245R_DATA
0x0000   UM245R_CTRL
0xFFFF   STACK
0xF020   CMD_BUFFER
0xF010   KEY_MATRIX_BUFFER
0xF000   CONSOLE_STATUS
0x8000   RAMSTART
0x0001   BEANBOARD
