beanzee.asm:
     1                          ; MARVIN build for beanzee / Z80 breadboard computer
     2                          ; https://github.com/PainfulDiodes/BeanZee
     3                          
     4                          
     5                          BEANBOARD EQU 0
     6                          
     7                          include "asm/main.inc"
asm/main.inc:
     1                          ; start of user RAM
     2                          RAMSTART equ 0x8000
     3                          
     4                          ; 8-byte status area
     5                          CONSOLE_STATUS equ 0xf000
     6                          ; 8-byte keyscan buffer
     7                          KEY_MATRIX_BUFFER equ 0xf010
     8                          ; command buffer
     9                          CMD_BUFFER equ 0xf020
    10                          ; this should really be 0x0000 as the CPU will dec SP before PUSH
    11                          STACK equ 0xffff
    12                          
    13                          UM245R_CTRL equ 0 ; serial control port
    14                          UM245R_DATA equ 1 ; serial data port
    15                          KEYSCAN_OUT equ 2 ; either 2 or 3 will work
    16                          KEYSCAN_IN  equ 3 ; either 2 or 3 will work
    17                          LCD_CTRL    equ 4 ; LCD control port
    18                          LCD_DATA    equ 5 ; LCD data port
    19                          GPIO_OUT    equ 6 ; either 6 or 7 will work
    20                          GPIO_IN     equ 7 ; either 6 or 7 will work
    21                          
    22                          CONSOLE_STATUS_USB equ 1
    23                          CONSOLE_STATUS_BEANBOARD equ 2
    24                          
beanzee.asm:
     8                          include "asm/escapestring.inc"
asm/escapestring.inc:
     1                          ; escape character constants for assembler compatibility
     2                          ; sjasmplus requires double quotes around escape sequences: "\n" and would not interpret '\n' but truncate
     3                          ; z88dk-z80asm requires single quotes around so would correctly interpret '\n' but reject "\n"
     4                          
     5                          ESC_B equ 0x08 ; \b
     6                          ESC_T equ 0x09 ; \t
     7                          ESC_N equ 0x0a ; \n
     8                          ESC_R equ 0x0d ; \r
     9                          ESC_E equ 0x1b ; \e
    10                          SLASH equ 0x5c ; \\
    11                          QUOTE equ 0x27 ; \'
    12                          
beanzee.asm:
     9                          include "asm/HD44780LCD.inc"
asm/HD44780LCD.inc:
     1                          ; LCD commands
     2                          LCD_CLEAR_DISPLAY equ 0x01
     3                          LCD_RETURN_HOME equ 0x02
     4                          LCD_ENTRY_MODE_SET equ 0x04
     5                          LCD_DISPLAY_ON_OFF_CONTROL equ 0x08
     6                          LCD_CURSOR_DISPLAY_SHIFT equ 0x10
     7                          LCD_FUNCTION_SET equ 0x20
     8                          LCD_SET_CGRAM_ADDR equ 0x40
     9                          LCD_SET_DDRAM_ADDR equ 0x80
    10                          
    11                          ; LCD_ENTRY_MODE_SET options
    12                          LCD_ENTRY_INC equ 0x02 ; left
    13                          LCD_ENTRY_DEC equ 0x00 ; right
    14                          LCD_ENTRY_SHIFT equ 0x01
    15                          LCD_ENTRY_NO_SHIFT equ 0x00
    16                          
    17                          ; LCD_DISPLAY_ON_OFF_CONTROL options
    18                          LCD_DISPLAY_ON equ 0x04
    19                          LCD_DISPLAY_OFF equ 0x00
    20                          LCD_CURSOR_ON equ 0x02
    21                          LCD_CURSOR_OFF equ 0x00
    22                          LCD_BLINK_ON equ 0x01
    23                          LCD_BLINK_OFF equ 0x00
    24                          
    25                          ; LCD_CURSOR_DISPLAY_SHIFT options
    26                          LCD_SHIFT_DISPLAY equ 0x08
    27                          LCD_SHIFT_CURSOR equ 0x00
    28                          LCD_SHIFT_RIGHT equ 0x04
    29                          LCD_SHIFT_LEFT equ 0x00
    30                          
    31                          ; LCD_FUNCTION_SET options
    32                          LCD_DATA_LEN_8 equ 0x10
    33                          LCD_DATA_LEN_4 equ 0x00
    34                          LCD_DISP_LINES_2 equ 0x08
    35                          LCD_DISP_LINES_1 equ 0x00
    36                          LCD_FONT_10 equ 0x04
    37                          LCD_FONT_8 equ 0x00
    38                          
    39                          LCD_LINE_LEN equ 0x14
    40                          LCD_NUM_LINES equ 4
    41                          LCD_BUFFER_LEN equ LCD_LINE_LEN*LCD_NUM_LINES
    42                          
    43                          ; LCD_SET_DDRAM_ADDR options
    44                          LCD_LINE_0_ADDR equ 0x00
    45                          LCD_LINE_1_ADDR equ 0x40
    46                          LCD_LINE_2_ADDR equ 0x00+LCD_LINE_LEN
    47                          LCD_LINE_3_ADDR equ 0x40+LCD_LINE_LEN
    48                          LCD_EOL_0 equ 0x00+LCD_LINE_LEN-1
    49                          LCD_EOL_1 equ 0x40+LCD_LINE_LEN-1
    50                          LCD_EOL_2 equ 0x00+LCD_LINE_LEN*2-1
    51                          LCD_EOL_3 equ 0x40+LCD_LINE_LEN*2-1
    52                          
beanzee.asm:
    10                          include "asm/main.asm"
asm/main.asm:
     1                          IFDEF ORGDEF
     2                              ORG ORGDEF
     3                          ELSE
     4                              ORG 0x0000
     5                          ENDIF
     6                          
     7  0000  31ffff                ld sp, STACK
     8                          IF BEANBOARD
     9                              call lcd_init
    10                              call beanboard_console_init
    11                          ELSE
    12  0003  cd7000                call console_init
    13                          ENDIF
    14  0006  c3f000                jp START
    15                          
beanzee.asm:
    11                          include "asm/console.asm"
asm/console.asm:
     1  0009  00000000000000    ALIGN 0x10
     2                          
     3                          ; wait for a character and return in A
     4                          getchar:
     5  0010  cd2000                call readchar
     6  0013  fe00                  cp 0
     7  0015  c0                    ret nz
     8  0016  18f8                  jr getchar
     9                          
    10  0018  0000000000000000  ALIGN 0x10
    11                          
    12                          ; read a character from the console and return in A - return 0 if there is no character
    13                          readchar:
    14  0020  e5                    push hl
    15  0021  2100f0                ld hl,CONSOLE_STATUS
    16  0024  3e02                  ld a,CONSOLE_STATUS_BEANBOARD
    17  0026  a6                    and (hl)
    18  0027  2007                  jr nz,_readchar_beanboard
    19  0029  3e01                  ld a,CONSOLE_STATUS_USB
    20  002b  a6                    and (hl)
    21  002c  2007                  jr nz,_readchar_usb
    22  002e  1808                  jr _readchar_end
    23                          _readchar_beanboard:
    24  0030  cda003                call key_readchar
    25  0033  1803                  jr _readchar_end
    26                          _readchar_usb:
    27  0035  cda000                call usb_readchar
    28                          _readchar_end:
    29  0038  e1                    pop hl
    30  0039  c9                    ret
    31                          
    32  003a  000000000000      ALIGN 0x10
    33                          
    34                          ; sent character in A to the console
    35                          putchar:
    36  0040  e5                    push hl
    37  0041  c5                    push bc
    38  0042  47                    ld b,a
    39  0043  2100f0                ld hl,CONSOLE_STATUS
    40  0046  3e02                  ld a,CONSOLE_STATUS_BEANBOARD
    41  0048  a6                    and (hl)
    42  0049  2007                  jr nz,_putchar_beanboard
    43  004b  3e01                  ld a,CONSOLE_STATUS_USB
    44  004d  a6                    and (hl)
    45  004e  2008                  jr nz,_putchar_usb
    46  0050  180a                  jr _putchar_end
    47                          _putchar_beanboard:
    48  0052  78                    ld a,b
    49  0053  cdc002                call lcd_putchar
    50  0056  1804                  jr _putchar_end
    51                          _putchar_usb:
    52  0058  78                    ld a,b
    53  0059  cdc000                call usb_putchar
    54                          _putchar_end:
    55  005c  78                    ld a,b
    56  005d  c1                    pop bc
    57  005e  e1                    pop hl
    58  005f  c9                    ret
    59                          
    60                          ALIGN 0x10
    61                          
    62                          ; print a zero-terminated string pointed to by hl to the console
    63                          puts:
    64  0060  e5                    push hl
    65                          _puts_loop:
    66                              ; get character from string
    67  0061  7e                    ld a,(hl)
    68                              ; is it zero?
    69  0062  fe00                  cp 0
    70                              ; yes
    71  0064  2807                  jr z, _puts_end
    72                              ; no: send character
    73  0066  cd4000                call putchar
    74                              ; next character position
    75  0069  23                    inc hl
    76                              ; loop for next character
    77  006a  c36100                jp _puts_loop
    78                          _puts_end:
    79  006d  e1                    pop hl
    80  006e  c9                    ret
    81                          
    82  006f  00                ALIGN 0x10
    83                          
    84                          ; BeanZee console init - USB is the active console
    85                          console_init:
    86  0070  3e01                  ld a,CONSOLE_STATUS_USB
    87  0072  2100f0                ld hl,CONSOLE_STATUS
    88  0075  77                    ld (hl),a
    89  0076  c9                    ret
    90                          
    91  0077  0000000000000000  ALIGN 0x10
              00                
    92                          
    93                          ; determine which console should be active - Reset=beanboard, shift-Reset=USB
    94                          beanboard_console_init:
    95                              ; check for modifier keys being held down
    96  0080  cde003                call modifierkeys
    97                              ; shift key down?
    98  0083  e601                  and MOD_KEY_SHIFT
    99                              ; yes shift
   100  0085  c28f00                jp nz,_beanboard_console_init_usb
   101                              ; no shift
   102  0088  3e02                  ld a,CONSOLE_STATUS_BEANBOARD
   103  008a  2100f0                ld hl,CONSOLE_STATUS
   104  008d  77                    ld (hl),a
   105  008e  c9                    ret
   106                          _beanboard_console_init_usb:
   107  008f  3e01                  ld a,CONSOLE_STATUS_USB
   108  0091  2100f0                ld hl,CONSOLE_STATUS
   109  0094  77                    ld (hl),a
   110  0095  c9                    ret
   111                          
beanzee.asm:
    12                          include "asm/UM245R.asm"
asm/UM245R.asm:
     1                          ; It is assumed that UM245R status signals are gated to the data bus as an IO port where:
     2                          ; /TXE = bit 0
     3                          ; /RXF = bit 1
     4                          ; As per:
     5                          ; https://github.com/PainfulDiodes/z80-breadboard-computer
     6                          ;
     7                          ; line endings are translated:
     8                          ; incoming line endings from the terminal are expected to be \r
     9                          ; and are tranlslated to \n
    10                          ; (\r\n would count as 2 line endings)
    11                          ; and outgoing line endings are sent as \r\n
    12                          ; externally this is consistent with VT100/ANSI terminal behaviour
    13                          ; and internally line endings are always \n
    14                          
    15  0096  0000000000000000  ALIGN 0x10
              0000              
    16                          
    17                          ; get character and return in A
    18                          usb_readchar:
    19                              ; get the USB status
    20  00a0  db00                  in a,(UM245R_CTRL)
    21                              ; data to read? (active low)
    22  00a2  cb4f                  bit 1,a
    23                              ; no, the buffer is empty
    24  00a4  2008                  jr nz,_usb_no_char
    25                              ; yes, read the received char
    26  00a6  db01                  in a,(UM245R_DATA)
    27                              ; is CR?
    28  00a8  fe0d                  cp ESC_R
    29                              ; no:
    30  00aa  c0                    ret nz
    31                              ; yes: convert CR to LF
    32  00ab  3e0a                  ld a, ESC_N
    33  00ad  c9                    ret
    34                          _usb_no_char:
    35  00ae  3e00                  ld a,0
    36  00b0  c9                    ret
    37                          
    38  00b1  0000000000000000  ALIGN 0x10
              00000000000000    
    39                          
    40                          usb_putchar:
    41                              ; newline?
    42  00c0  fe0a                  cp ESC_N
    43                              ; no: just send the char
    44  00c2  2007                  jr nz,_do_usb_put
    45  00c4  3e0d                  ld a, ESC_R
    46  00c6  cdcf00                call _usb_put
    47  00c9  3e0a                  ld a, ESC_N
    48                          _do_usb_put:
    49  00cb  cdcf00                call _usb_put
    50  00ce  c9                    ret
    51                          
    52                          ; transmit character in A
    53                          _usb_put:
    54  00cf  c5                    push bc
    55                              ; stash the transmit character
    56  00d0  47                    ld b,a
    57                          _usb_put_loop:
    58                              ; get the USB status
    59  00d1  db00                  in a,(UM245R_CTRL)
    60                              ; ready to transmit? (active low)
    61  00d3  cb47                  bit 0,a
    62                              ; no: bit is high
    63  00d5  20fa                  jr nz,_usb_put_loop
    64                              ; yes: restore the stashed transmit character
    65  00d7  78                    ld a,b
    66                              ; transmit the character
    67  00d8  d301                  out (UM245R_DATA),a
    68  00da  c1                    pop bc
    69  00db  c9                    ret
    70                          
    71  00dc  00000000          ALIGN 0x10
    72                          
    73                          ; print a zero-terminated string pointed to by hl to the USB
    74                          usb_puts:
    75  00e0  e5                    push hl
    76                          _usb_puts_loop:
    77                              ; get character from string
    78  00e1  7e                    ld a,(hl)
    79                              ; is it zero?
    80  00e2  fe00                  cp 0
    81                              ; yes
    82  00e4  2807                  jr z, _usb_puts_end
    83                              ; no: send character
    84  00e6  cdc000                call usb_putchar
    85                              ; next character position
    86  00e9  23                    inc hl
    87                              ; loop for next character
    88  00ea  c3e100                jp _usb_puts_loop
    89                          _usb_puts_end:
    90  00ed  e1                    pop hl
    91  00ee  c9                    ret
    92                          
    93                          
beanzee.asm:
    13                          include "asm/marvin.asm"
asm/marvin.asm:
     1                          ; ****************************************************
     2                          ; *  Marvin - a Z80 homebrew monitor program
     3                          ; * (c) Stephen Willcock 2024
     4                          ; * https://github.com/PainfulDiodes
     5                          ; ****************************************************
     6                          
     7                          ; MAIN PROGRAM LOOP
     8                          
     9  00ef  00                ALIGN 0x10
    10                          
    11                          START:
    12                              ; point DE to zero - this is the default address argument for commands
    13  00f0  110000                ld de,0x0000
    14                          
    15  00f3  219004                ld hl,welcome_msg
    16  00f6  cd6000                call puts
    17                          
    18  00f9  00000000000000    ALIGN 0x10
    19                          
    20                          PROMPT:
    21                              ; point HL to the beginning of the input buffer
    22  0100  2120f0                ld hl,CMD_BUFFER
    23  0103  3e3e                  ld a,'>'
    24  0105  cd4000                call putchar
    25                          
    26                          _get_cmd:
    27                              ; get character from console
    28  0108  cd1000                call getchar
    29                              ; echo the character to console
    30  010b  cd4000                call putchar
    31                              ; is CR?
    32  010e  fe0d                  cp ESC_R
    33                              ; yes: skip this
    34  0110  28f6                  jr z,_get_cmd
    35                              ; is tab?
    36  0112  fe09                  cp ESC_T
    37                              ; yes: skip this
    38  0114  28f2                  jr z,_get_cmd
    39                              ; is space?
    40  0116  fe20                  cp ' '
    41                              ; yes - skip this
    42  0118  28ee                  jr z,_get_cmd
    43                              ; escape?
    44  011a  fe1b                  cp ESC_E
    45                              ; yes
    46  011c  2808                  jr z, _get_cmd_esc
    47                              ; end of line?
    48  011e  fe0a                  cp ESC_N
    49                              ; yes
    50  0120  280b                  jr z, _get_cmd_end
    51                              ; no: add character to the buffer
    52  0122  77                    ld(hl),a
    53                              ; move pointer to next buffer location - we're not checking for overrun
    54  0123  23                    inc hl
    55                              ; next character
    56  0124  18e2                  jr _get_cmd
    57                              ; do escape
    58                          _get_cmd_esc:
    59                              ; new line
    60  0126  3e0a                  ld a,ESC_N
    61  0128  cd4000                call putchar
    62                              ; back to prompt
    63  012b  18d3                  jr PROMPT
    64                          _get_cmd_end:
    65                              ; string terminator
    66  012d  3e00                  ld a,0
    67                              ; add terminator to end of buffer
    68  012f  77                    ld(hl),a
    69                          ; process command from buffer
    70                              ; point to start of buffer
    71  0130  2120f0                ld hl,CMD_BUFFER
    72                              ; load character from buffer
    73  0133  7e                    ld a,(hl)
    74                              ; end of string?
    75  0134  fe00                  cp 0
    76                              ; yes - empty line - go back to prompt
    77  0136  28c8                  jr z,PROMPT
    78                              ; advance the buffer pointer
    79  0138  23                    inc hl
    80  0139  fe72                  cp 'r'
    81  013b  2815                  jr z,_cmd_read
    82  013d  fe77                  cp 'w'
    83  013f  2847                  jr z,_cmd_write
    84  0141  fe78                  cp 'x'
    85  0143  2868                  jr z,_cmd_execute
    86                              ; ':' = load from intel hex format
    87  0145  fe3a                  cp ':'
    88  0147  2879                  jr z,_cmd_load
    89                              ; otherwise error
    90  0149  210005                ld hl,bad_cmd_msg
    91  014c  cd6000                call puts
    92                              ; loop back to the prompt
    93  014f  c30001                jp PROMPT
    94                          
    95                          ; COMMANDS
    96                          
    97                          ; READ
    98                          ; read bytes from memory and send hex values to console
    99                          _cmd_read:
   100                              ; load character from buffer
   101  0152  7e                    ld a,(hl)
   102                              ; end of string?
   103  0153  fe00                  cp 0
   104                              ; yes: no address argument, so skip to read row
   105  0155  2808                  jr z, _cmd_read_row
   106                              ; parse first pair of characters
   107  0157  cd0002                call hex_byte_val
   108                              ; load into upper byte of memory pointer
   109  015a  57                    ld d,a
   110                              ; parse second pair of characters
   111  015b  cd0002                call hex_byte_val
   112                              ; load into lower byte of memory pointer
   113  015e  5f                    ld e,a
   114                          _cmd_read_row:
   115                              ; initialise byte counter - each row will have this many bytes
   116  015f  0e10                  ld c, 0x10
   117                              ; print DE content: the read address
   118  0161  7a                    ld a,d
   119  0162  cd5002                call putchar_hex
   120  0165  7b                    ld a,e
   121  0166  cd5002                call putchar_hex
   122                              ; separator between address and data
   123  0169  3e3a                  ld a,':'
   124  016b  cd4000                call putchar
   125  016e  3e20                  ld a,' '
   126  0170  cd4000                call putchar
   127                              ; get a byte
   128                          _cmd_read_byte:
   129  0173  1a                    ld a,(de)
   130                              ; and print it
   131  0174  cd5002                call putchar_hex
   132                              ; add space between bytes
   133  0177  3e20                  ld a,' '
   134  0179  cd4000                call putchar
   135                              ; next address
   136  017c  13                    inc de
   137                              ; reduce byte counter
   138                              ; TODO djnz ?
   139  017d  0d                    dec c
   140                              ; repeat if the counter is not 0
   141  017e  20f3                  jr nz, _cmd_read_byte
   142                              ; otherwise, new line
   143  0180  3e0a                  ld a,ESC_N
   144  0182  cd4000                call putchar
   145                              ; and back to prompt
   146  0185  c30001                jp PROMPT
   147                          
   148                          ; WRITE
   149                          
   150                          ; write bytes to memory interpreting hex values from console
   151                          _cmd_write:
   152                              ; load character from buffer
   153  0188  7e                    ld a,(hl)
   154                              ; end of string?
   155  0189  fe00                  cp 0
   156                              ; yes: no data
   157  018b  2817                  jr z, _cmd_write_null
   158                              ; parse first pair of characters - address high
   159  018d  cd0002                call hex_byte_val
   160                              ; load into upper byte of memory pointer
   161  0190  57                    ld d,a
   162                              ; parse second pair of characters - address low
   163  0191  cd0002                call hex_byte_val
   164                              ; load into lower byte of memory pointer
   165  0194  5f                    ld e,a
   166                          _cmd_write_data:
   167                              ; load character from buffer
   168  0195  7e                    ld a,(hl)
   169                              ; end of string?
   170  0196  fe00                  cp 0
   171                              ; yes: we're done
   172  0198  2807                  jr z, _cmd_write_end
   173                              ; parse data byte
   174  019a  cd0002                call hex_byte_val
   175                              ; write byte to memory
   176  019d  12                    ld (de),a
   177                              ; advance destination pointer
   178  019e  13                    inc de
   179  019f  18f4                  jr _cmd_write_data
   180                          _cmd_write_end:
   181  01a1  c30001                jp PROMPT
   182                              ; w with no data
   183                          _cmd_write_null:
   184  01a4  212005                ld hl,cmd_w_null_msg
   185  01a7  cd6000                call puts
   186                              ; and back to prompt
   187  01aa  c30001                jp PROMPT
   188                          
   189                          ; EXECUTE
   190                          
   191                          ; start executing from given address
   192                          _cmd_execute:
   193                              ; load character from buffer
   194  01ad  7e                    ld a,(hl)
   195                              ; end of string?
   196  01ae  fe00                  cp 0
   197                              ; yes - no data
   198  01b0  cabe01                jp z, _cmd_exec_df
   199                              ; parse first pair of characters - address high
   200  01b3  cd0002                call hex_byte_val
   201                              ; load into upper byte of memory pointer
   202  01b6  57                    ld d,a
   203                              ; parse second pair of characters - address low
   204  01b7  cd0002                call hex_byte_val
   205                              ; load into lower byte of memory pointer
   206  01ba  5f                    ld e,a
   207  01bb  626b                  ld hl,de
   208                              ; execute from address
   209  01bd  e9                    jp (hl)
   210                              ; start executing from default address
   211                          _cmd_exec_df:
   212  01be  210080                ld hl,RAMSTART
   213                              ; execute from address
   214  01c1  e9                    jp (hl)
   215                          
   216                          ; LOAD
   217                          
   218                          ; load from INTEL HEX - records are read from the buffer
   219                          _cmd_load:
   220                              ; load character from buffer
   221  01c2  7e                    ld a,(hl)
   222                              ; end of string?
   223  01c3  fe00                  cp 0
   224                              ; yes: no data - quit
   225  01c5  caee01                jp z, _cmd_load_end
   226                              ; parse first pair of characters - byte count
   227  01c8  cd0002                call hex_byte_val
   228  01cb  fe00                  cp 0
   229                              ; yes - zero byte count - quit
   230  01cd  caee01                jp z, _cmd_load_end
   231                              ; load byte count into C
   232  01d0  4f                    ld c,a
   233                              ; parse address high
   234  01d1  cd0002                call hex_byte_val
   235                              ; load into upper byte of memory pointer
   236  01d4  57                    ld d,a
   237                              ; parse address low
   238  01d5  cd0002                call hex_byte_val
   239                              ; load into lower byte of memory pointer
   240  01d8  5f                    ld e,a
   241                              ; parse record type
   242  01d9  cd0002                call hex_byte_val
   243                              ; record type zero?
   244  01dc  fe00                  cp 0
   245                              ; no: quit
   246  01de  c2ee01                jp nz, _cmd_load_end
   247                          _cmd_load_data:
   248                              ; load character from buffer
   249  01e1  7e                    ld a,(hl)
   250                              ; end of string?
   251  01e2  fe00                  cp 0
   252                              ; yes: we're done
   253  01e4  2808                  jr z, _cmd_load_end
   254                              ; no:
   255                              ; parse data byte
   256  01e6  cd0002                call hex_byte_val
   257                              ; write byte to memory
   258  01e9  12                    ld (de),a
   259                              ; advance destination pointer
   260  01ea  13                    inc de
   261                              ; decrement byte counter
   262                              ; TODO djnz
   263  01eb  0d                    dec c
   264                              ; if byte counter not zero then go again
   265  01ec  20f3                  jr nz,_cmd_load_data
   266                          _cmd_load_end:
   267  01ee  c30001                jp PROMPT
   268                          
beanzee.asm:
    14                          include "asm/strings.asm"
asm/strings.asm:
     1                          ; string subroutines
     2                          
     3  01f1  0000000000000000  ALIGN 0x10
              00000000000000    
     4                          
     5                          ; read 2 ASCII hex chars from memory by HL pointer, return converted value in A and advance HL pointer
     6                          hex_byte_val:
     7                              ; preserve BC
     8  0200  c5                    push bc
     9                              ; load 1st character from memory
    10  0201  7e                    ld a,(hl)
    11                              ; end of string?
    12  0202  fe00                  cp 0
    13                              ; yes: no value - return zero
    14  0204  2819                  jr z,_hex_byte_val_zero
    15                              ; no:
    16                              ; advance the buffer pointer
    17  0206  23                    inc hl
    18                              ; convert first hex digit
    19  0207  cd3002                call hex_val
    20                              ; shift left 4 bits to put value into top nibble
    21  020a  cb27                  sla a
    22  020c  cb27                  sla a
    23  020e  cb27                  sla a
    24  0210  cb27                  sla a
    25                              ; cache the result
    26  0212  47                    ld b,a
    27                              ; load 2nd character from memory
    28  0213  7e                    ld a,(hl)
    29                              ; end of string?
    30  0214  fe00                  cp 0
    31                              ; yes: incomplete byte - return zero
    32  0216  2807                  jr z,_hex_byte_val_zero
    33                              ; advance the buffer pointer
    34  0218  23                    inc hl
    35                              ; and convert 2nd hex digit
    36  0219  cd3002                call hex_val
    37                              ; add first and second digits
    38  021c  80                    add a,b
    39                              ; restore BC
    40  021d  c1                    pop bc
    41  021e  c9                    ret
    42                          _hex_byte_val_zero:
    43                              ; zero return value
    44  021f  3e00                  ld a,0
    45                              ; restore BC
    46  0221  c1                    pop bc
    47  0222  c9                    ret
    48                          
    49  0223  0000000000000000  ALIGN 0x10
              0000000000        
    50                          
    51                          ; convert an ASCII hex char in A to a number value (lower 4 bits)
    52                          hex_val:
    53                              ; is it lowercase alphabetic?
    54  0230  fe61                  cp 'a'
    55                              ; no: uppercase/numeric
    56  0232  3803                  jr c,_hex_val_u_n
    57                              ; yes: alphabetic
    58  0234  d657                  sub 'a'-0x0a
    59  0236  c9                    ret
    60                          _hex_val_u_n:
    61                              ; is it uppercase alphabetic?
    62  0237  fe41                  cp 'A'
    63                              ; no: numeric
    64  0239  3803                  jr c,_hex_val_n
    65                              ; y:
    66  023b  d637                  sub 'A'-0x0a
    67  023d  c9                    ret
    68                          _hex_val_n:
    69                              ; numeric
    70  023e  d630                  sub '0'
    71  0240  c9                    ret
    72                          
    73  0241  0000000000000000  ALIGN 0x10
              00000000000000    
    74                          
    75                          ; convert value in A into an ASCII pair and send to console
    76                          putchar_hex:
    77  0250  f5                    push af
    78  0251  c5                    push bc
    79                              ; stash in B
    80  0252  47                    ld b,a
    81                              ; shift A right x4 e.g. transform 10110010 to 00001011
    82  0253  cb3f                  srl a
    83  0255  cb3f                  srl a
    84  0257  cb3f                  srl a
    85  0259  cb3f                  srl a
    86                              ; most significant digit
    87  025b  cd6702                call _putchar_hex_dgt
    88                              ; recover from stash
    89  025e  78                    ld a,b
    90                              ; clear the top 4 bits
    91  025f  e60f                  and 0b00001111
    92                              ; least significant digit
    93  0261  cd6702                call _putchar_hex_dgt
    94  0264  c1                    pop bc
    95  0265  f1                    pop af
    96  0266  c9                    ret
    97                          _putchar_hex_dgt:
    98                              ; is it an alpha or numeric?
    99  0267  fe0a                  cp 0x0a
   100                              ; numeric
   101  0269  3806                  jr c,_putchar_hex_n
   102                              ; alpha
   103                              ; for alpha add the base ascii for 'a' but then sub 10 / 0x0a as hex 'a' = 10d
   104  026b  c657                  add a,'a'-0x0a
   105  026d  cd4000                call putchar
   106  0270  c9                    ret
   107                          _putchar_hex_n:
   108                              ; for numeric add the base ascii for '0'
   109  0271  c630                  add a,'0'
   110  0273  cd4000                call putchar
   111  0276  c9                    ret
   112                          
beanzee.asm:
    15                          include "asm/HD44780LCD.asm"
asm/HD44780LCD.asm:
     1                          LCD_COMMAND_0 equ LCD_FUNCTION_SET+LCD_DATA_LEN_8+LCD_DISP_LINES_2+LCD_FONT_8
     2                          LCD_COMMAND_1 equ LCD_DISPLAY_ON_OFF_CONTROL+LCD_DISPLAY_ON+LCD_CURSOR_ON+LCD_BLINK_ON
     3                          
     4  0277  0000000000000000  ALIGN 0x10
              00                
     5                          
     6                          ; initialise LCD
     7                          lcd_init:
     8                          ; preserve registers
     9  0280  f5                    push af
    10                          ; intitialise device
    11  0281  3e38              	ld a,LCD_COMMAND_0
    12  0283  cda002            	call lcd_putcmd
    13  0286  3e0f              	ld a,LCD_COMMAND_1
    14  0288  cda002            	call lcd_putcmd
    15  028b  3e01              	ld a,LCD_CLEAR_DISPLAY
    16  028d  cda002            	call lcd_putcmd
    17  0290  3e00                  ld a,0
    18  0292  cdc002                call lcd_putchar
    19                          ; restore registers
    20  0295  f1                    pop af
    21  0296  c9                    ret
    22                          
    23  0297  0000000000000000  ALIGN 0x10
              00                
    24                          
    25                          ; transmit character in A to the LCD control port
    26                          lcd_putcmd:
    27  02a0  c5                    push bc
    28                          ; save the transmit character
    29  02a1  47                    ld b,a
    30                          _lcd_putcmd_loop:
    31                          ; get the LCD status
    32  02a2  db04                  in a,(LCD_CTRL)
    33                          ; busy ?
    34  02a4  cb7f                  bit 7,a
    35                          ; yes
    36  02a6  20fa                  jr nz,_lcd_putcmd_loop
    37                          ; no, restore the transmit character
    38  02a8  78                    ld a,b
    39                          ; transmit the character
    40  02a9  d304                  out (LCD_CTRL),a
    41  02ab  c1                    pop bc
    42  02ac  c9                    ret
    43                          
    44  02ad  000000            ALIGN 0x10
    45                          
    46                          ; get character from LCD data port and return in A
    47                          lcd_getchar:
    48                          ; get the LCD status
    49  02b0  db04                  in a,(LCD_CTRL)
    50                          ; busy ?
    51  02b2  cb7f                  bit 7,a
    52                          ; yes
    53  02b4  20fa                  jr nz,lcd_getchar
    54                          ; no, get a character
    55  02b6  db05                  in a,(LCD_DATA)
    56  02b8  c9                    ret
    57                          
    58  02b9  00000000000000    ALIGN 0x10
    59                          
    60                          ; transmit character in A to the LCD data port
    61                          lcd_putchar:
    62                              ; newline char?
    63  02c0  fe0a                  cp ESC_N
    64  02c2  c2e002                jp nz,_lcd_putchar_printable
    65                              ; newline - fill out the line until EOL
    66                          _lcd_putchar_pad:
    67  02c5  3e20                  ld a,' '
    68  02c7  cd2003                call lcd_putdata
    69  02ca  fe13                  cp LCD_EOL_0
    70  02cc  cafa02                jp z,_lcd_putchar_eol0
    71  02cf  fe53                  cp LCD_EOL_1
    72  02d1  ca0103                jp z,_lcd_putchar_eol1
    73  02d4  fe27                  cp LCD_EOL_2
    74  02d6  ca0803                jp z,_lcd_putchar_eol2
    75  02d9  fe67                  cp LCD_EOL_3
    76  02db  ca0f03                jp z,_lcd_putchar_eol3
    77                              ; loop until EOL
    78  02de  18e5                  jr _lcd_putchar_pad
    79                          _lcd_putchar_printable:
    80  02e0  cd2003                call lcd_putdata
    81                              ; check for overflow - DDRAM address returned in A
    82  02e3  fe13                  cp LCD_EOL_0
    83  02e5  cafa02                jp z,_lcd_putchar_eol0
    84  02e8  fe53                  cp LCD_EOL_1
    85  02ea  ca0103                jp z,_lcd_putchar_eol1
    86  02ed  fe27                  cp LCD_EOL_2
    87  02ef  ca0803                jp z,_lcd_putchar_eol2
    88  02f2  fe67                  cp LCD_EOL_3
    89  02f4  ca0f03                jp z,_lcd_putchar_eol3
    90  02f7  c31703                jp _lcd_putchar_end
    91                          _lcd_putchar_eol0:
    92  02fa  3ec0                  ld a,LCD_SET_DDRAM_ADDR+LCD_LINE_1_ADDR
    93  02fc  cda002            	call lcd_putcmd
    94  02ff  1816                  jr _lcd_putchar_end
    95                          _lcd_putchar_eol1:
    96  0301  3e94                  ld a,LCD_SET_DDRAM_ADDR+LCD_LINE_2_ADDR
    97  0303  cda002            	call lcd_putcmd
    98  0306  180f                  jr _lcd_putchar_end
    99                          _lcd_putchar_eol2:
   100  0308  3ed4                  ld a,LCD_SET_DDRAM_ADDR+LCD_LINE_3_ADDR
   101  030a  cda002            	call lcd_putcmd
   102  030d  1808                  jr _lcd_putchar_end
   103                          _lcd_putchar_eol3:
   104  030f  cd4003                call lcd_scroll
   105  0312  3ed4                  ld a,LCD_SET_DDRAM_ADDR+LCD_LINE_3_ADDR
   106  0314  cda002            	call lcd_putcmd
   107                          _lcd_putchar_end:
   108  0317  c9                    ret
   109                          
   110  0318  0000000000000000  ALIGN 0x10
   111                          
   112                          ; transmit character in A to the LCD data port,
   113                          ; return in A the DDRAM address where the character was sent
   114                          lcd_putdata:
   115  0320  c5                    push bc
   116                              ; save the transmit character
   117  0321  47                    ld b,a
   118                          _lcd_putdata_loop:
   119                              ; get the LCD status
   120  0322  db04                  in a,(LCD_CTRL)
   121                              ; busy ?
   122  0324  cb7f                  bit 7,a
   123                              ; yes
   124  0326  20fa                  jr nz,_lcd_putdata_loop
   125                              ; no, reset the 'busy' bit and preserve the DDRAM address
   126  0328  e67f                  and 0b01111111
   127  032a  4f                    ld c,a
   128                              ; restore the transmit character and send it
   129  032b  78                    ld a,b
   130  032c  d305                  out (LCD_DATA),a
   131                              ; restore the DDRAM address
   132  032e  79                    ld a,c
   133  032f  c1                    pop bc
   134  0330  c9                    ret
   135                          
   136  0331  0000000000000000  ALIGN 0x10
              00000000000000    
   137                          
   138                          lcd_scroll:
   139  0340  c5                    push bc
   140  0341  d5                    push de
   141  0342  16c0                  ld d,LCD_SET_DDRAM_ADDR+LCD_LINE_1_ADDR
   142  0344  1e80                  ld e,LCD_SET_DDRAM_ADDR+LCD_LINE_0_ADDR
   143  0346  cd5f03                call _lcd_scroll_line
   144  0349  1694                  ld d,LCD_SET_DDRAM_ADDR+LCD_LINE_2_ADDR
   145  034b  1ec0                  ld e,LCD_SET_DDRAM_ADDR+LCD_LINE_1_ADDR
   146  034d  cd5f03                call _lcd_scroll_line
   147  0350  16d4                  ld d,LCD_SET_DDRAM_ADDR+LCD_LINE_3_ADDR
   148  0352  1e94                  ld e,LCD_SET_DDRAM_ADDR+LCD_LINE_2_ADDR
   149  0354  cd5f03                call _lcd_scroll_line
   150  0357  3ed4                  ld a,LCD_SET_DDRAM_ADDR+LCD_LINE_3_ADDR
   151  0359  cd7803                call _lcd_scroll_clear_line
   152  035c  d1                    pop de
   153  035d  c1                    pop bc
   154  035e  c9                    ret
   155                          _lcd_scroll_line:
   156                              ; b = character counter
   157                              ; c = stash char
   158                              ; d = source line to copy from
   159                              ; e = destination line to copy to
   160  035f  0614                  ld b,LCD_LINE_LEN
   161                          _lcd_scroll_line_loop:
   162                              ; load source
   163  0361  7a                    ld a,d
   164                              ; character counter is an offset
   165  0362  80                    add b
   166                              ; zero based index so -1
   167  0363  3d                    dec a
   168  0364  cda002                call lcd_putcmd
   169  0367  cdb002                call lcd_getchar
   170                              ; stash the value
   171  036a  4f                    ld c,a
   172                              ; load destination
   173  036b  7b                    ld a,e
   174                              ; character counter is an offset
   175  036c  80                    add b
   176                              ; zero based index so -1
   177  036d  3d                    dec a
   178  036e  cda002                call lcd_putcmd
   179                              ; recover the stashed value
   180  0371  79                    ld a,c
   181  0372  cd2003                call lcd_putdata
   182  0375  10ea                  djnz _lcd_scroll_line_loop
   183  0377  c9                    ret
   184                          _lcd_scroll_clear_line:
   185                              ; a = destination line to clear
   186                              ; b = character counter
   187  0378  0614                  ld b,LCD_LINE_LEN
   188  037a  cda002                call lcd_putcmd
   189                          _lcd_scroll_clear_line_loop:
   190  037d  3e20                  ld a,' '
   191  037f  cd2003                call lcd_putdata
   192  0382  10f9                  djnz _lcd_scroll_clear_line_loop
   193  0384  c9                    ret
   194                          
   195  0385  0000000000000000  ALIGN 0x10
              000000            
   196                          
   197                          ; print a zero-terminated string pointed to by hl to the LCD
   198                          lcd_puts:
   199  0390  e5                    push hl
   200                          _lcd_puts_loop:
   201                              ; get character from string
   202  0391  7e                    ld a,(hl)
   203                              ; is it zero?
   204  0392  fe00                  cp 0
   205                              ; yes
   206  0394  2807                  jr z, _lcd_puts_end
   207                              ; no: send character
   208  0396  cdc002                call lcd_putchar
   209                              ; next character position
   210  0399  23                    inc hl
   211                              ; loop for next character
   212  039a  c39103                jp _lcd_puts_loop
   213                          _lcd_puts_end:
   214  039d  e1                    pop hl
   215  039e  c9                    ret
   216                          
   217                          
beanzee.asm:
    16                          include "asm/keymatrix.asm"
asm/keymatrix.asm:
     1                          DEBOUNCE_DELAY  equ 0xf0
     2                          
     3                          MOD_KEY_SHIFT   equ 0b00000001
     4                          MOD_KEY_FN      equ 0b00000010
     5                          MOD_KEY_CONTROL equ 0b00000100
     6                          MOD_KEY_ALT     equ 0b00001000
     7                          MOD_KEY_CMD     equ 0b00010000
     8                          
     9  039f  00                ALIGN 0x10
    10                          
    11                          ; return keyboard char value in A, or 0
    12                          key_readchar:
    13  03a0  c5                    push bc
    14  03a1  d5                    push de
    15  03a2  e5                    push hl
    16                              ; initial row bit - only 1 bit is ever set at a time - it is shifted from bit 0 to bit 7
    17  03a3  0601                  ld b,0x01
    18                              ; row counter - 0 => 7
    19  03a5  0e00                  ld c,0x00
    20                              ; location of previous values
    21  03a7  2110f0                ld hl,KEY_MATRIX_BUFFER
    22  03aa  cde003                call modifierkeys
    23                              ; initialise map pointer
    24  03ad  110504                ld de,QWERTY_KEYMAP_L
    25                              ; shift key down?
    26  03b0  e601                  and MOD_KEY_SHIFT
    27  03b2  cab803                jp z,_keyscanloop
    28  03b5  114504                ld de,QWERTY_KEYMAP_U
    29                          _keyscanloop:
    30  03b8  cdd303                call _rowscan
    31                              ; ASCII returned in A, or 0
    32  03bb  cdf003                call _colscan
    33  03be  fe00                  cp 0
    34  03c0  c2ca03                jp nz,_delay
    35                              ; move the pointer of previous values to the next row slot
    36  03c3  23                    inc hl
    37                              ; increment row counter
    38  03c4  0c                    inc c
    39                              ; clear the carry flag
    40  03c5  b7                    or a
    41                              ; shift row bit left - when we've done all 8, it will move to the carry flag
    42  03c6  cb10                  rl b
    43                              ; loop if not done all rows
    44  03c8  30ee                  jr nc,_keyscanloop
    45                              ; key debounce
    46                          _delay:
    47                              ; set a to the length of the delay
    48  03ca  06f0                  ld b,DEBOUNCE_DELAY
    49                          _delayloop:
    50                              ; wait a few cycles
    51  03cc  00                    nop
    52                              ; no - loop again
    53  03cd  10fd                  djnz _delayloop
    54                          ; end
    55  03cf  e1                    pop hl
    56  03d0  d1                    pop de
    57  03d1  c1                    pop bc
    58  03d2  c9                    ret
    59                          
    60                          ; get row bitmap representing new keystrokes:
    61                          ; B contains row bit,
    62                          ; C contains row count,
    63                          ; HL contains a pointer to the old value.
    64                          ; return value in A
    65                          _rowscan:
    66                              ; preserve registers
    67  03d3  d5                    push de
    68                              ; fetch previous value for comparison
    69  03d4  7e                    ld a,(hl)
    70                              ; invert A - we want to check keys becoming closed - so zeroed bits on the previous value are significant
    71  03d5  2f                    cpl
    72                              ; store inverted previous value
    73  03d6  57                    ld d,a
    74                              ; get the current row bit
    75  03d7  78                    ld a,b
    76                              ; output row strobe
    77  03d8  d302                  out (KEYSCAN_OUT),a
    78                              ; get column values
    79  03da  db03                  in a,(KEYSCAN_IN)
    80                              ; store the new value
    81  03dc  77                    ld (hl),a
    82                              ; newVal AND ~oldVal means bits are set only when the previous bit value was 0
    83  03dd  a2                    and d
    84                              ; restore registers
    85  03de  d1                    pop de
    86  03df  c9                    ret
    87                          
    88                          ALIGN 0x10
    89                          
    90                          ; return bitmap representing modifier keys in A
    91                          modifierkeys:
    92  03e0  3e10                  ld a,0b00010000 ; row 4
    93                              ; output row strobe
    94  03e2  d302                  out (KEYSCAN_OUT),a
    95                              ; get column values
    96  03e4  db03                  in a,(KEYSCAN_IN)
    97  03e6  e601                  and 0b00000001 ; row 4, bit 0 is SHIFT
    98                              ; left shift modifier
    99  03e8  2003                  jr nz,_modifier_shift
   100                              ; no modifiers
   101  03ea  3e00                  ld a,0
   102  03ec  c9                    ret
   103                          _modifier_shift:
   104  03ed  3e01                  ld a,MOD_KEY_SHIFT
   105  03ef  c9                    ret
   106                          
   107                          ; A contains row bitmap representing new keystrokes,
   108                          ; DE contains a pointer to the ASCII map for the row - which is incremented in the subroutine
   109                          ; first printable character returned in A
   110                          _colscan:
   111                              ; preserve registers
   112  03f0  c5                    push bc
   113                              ; initialise col bit mask - only 1 bit is ever set at a time - it is shifted from bit 0 to bit 7
   114  03f1  0e01                  ld c,0x01
   115                              ; stash the bitmap
   116  03f3  47                    ld b,a
   117                          _colscanloop:
   118                              ; reload the bitmap
   119  03f4  78                    ld a,b
   120                              ; mask the bitmap - use the column mask (C) over the bitmap value in A
   121  03f5  a1                    and c
   122                              ; if zero then no keypress
   123  03f6  2805                  jr z,_colscanloopnext
   124  03f8  1a                    ld a,(de)
   125                              ; ASCII is 0?
   126  03f9  fe00                  cp 0
   127  03fb  2006                  jr nz,_colscanend
   128                          _colscanloopnext:
   129                              ; increment character map pointer
   130  03fd  13                    inc de
   131                              ; clear the carry flag
   132  03fe  b7                    or a
   133                              ; shift row bit left - when we've done all 8, it will move to the carry flag
   134  03ff  cb11                  rl c
   135                              ; loop if not done all rows
   136  0401  30f1                  jr nc,_colscanloop
   137                          _colscanend:
   138                              ; restore registers
   139  0403  c1                    pop bc
   140  0404  c9                    ret
   141                          
   142                          ; define values for control keys
   143                          ; modifiers have zero value
   144                          QWERTY_SHIFT equ 0
   145                          QWERTY_FN equ 0
   146                          QWERTY_CTRL equ 0
   147                          QWERTY_ALT equ 0
   148                          QWERTY_CMD equ 0
   149                          QWERTY_CURS_UP equ 1
   150                          QWERTY_CURS_DOWN equ 2
   151                          QWERTY_CURS_LEFT equ 3
   152                          QWERTY_CURS_RIGHT equ 4
   153                          QWERTY_CAPS equ 5
   154                          
   155                          QWERTY_KEYMAP_L:
   156  0405  1b71776572747975      db ESC_E,'q','w','e','r','t','y','u','i','o','p',QWERTY_CAPS,ESC_B,'7','8','9'
              696f700508373839  
   157  0415  096173646667686a      db ESC_T,'a','s','d','f','g','h','j','k','l',';',QUOTE,ESC_N,'4','5','6'
              6b6c3b270a343536  
   158  0425  007a786376626e6d      db QWERTY_SHIFT,'z','x','c','v','b','n','m',',','.','/',SLASH,QWERTY_CURS_UP,'1','2','3'
              2c2e2f5c01313233  
   159  0435  00000000205b5d20      db QWERTY_FN,QWERTY_CTRL,QWERTY_ALT,QWERTY_CMD,' ','[',']',' ','`','-','=',QWERTY_CURS_LEFT,QWERTY_CURS_DOWN,QWERTY_CURS_RIGHT,'0',ESC_N
              602d3d030204300a  
   160                          QWERTY_KEYMAP_U:
   161  0445  1b51574552545955      db ESC_E,'Q','W','E','R','T','Y','U','I','O','P',QWERTY_CAPS,ESC_B,'&','*','('
              494f500508262a28  
   162  0455  094153444647484a      db ESC_T,'A','S','D','F','G','H','J','K','L',':','"',ESC_N,'$','%','^'
              4b4c3a220a24255e  
   163  0465  005a584356424e4d      db QWERTY_SHIFT,'Z','X','C','V','B','N','M','<','>','?',SLASH,QWERTY_CURS_UP,'!','@','#'
              3c3e3f5c01214023  
   164  0475  00000000207b7d20      db QWERTY_FN,QWERTY_CTRL,QWERTY_ALT,QWERTY_CMD,' ','{','}',' ','~','_','+',QWERTY_CURS_LEFT,QWERTY_CURS_DOWN,QWERTY_CURS_RIGHT,')',ESC_N
              7e5f2b030204290a  
   165                          
beanzee.asm:
    17                          include "asm/messages.asm"
asm/messages.asm:
     1  0485  0000000000000000  ALIGN 0x10
              000000            
     2                          
     3                          welcome_msg:
     4  0490  4d415256494e2076                  db "MARVIN v1.2\n"
              312e320a          
     5  049c  412073696d706c65                  db "A simple Z80 homebrew monitor program\n"
              205a383020686f6d  
              6562726577206d6f  
              6e69746f72207072  
              6f6772616d0a      
     6  04c2  2863292053746570                  db "(c) Stephen Willcock 2024\n"
              68656e2057696c6c  
              636f636b20323032  
              340a              
     7  04dc  68747470733a2f2f                  db "https://github.com/PainfulDiodes\n\n",0
              6769746875622e63  
              6f6d2f5061696e66  
              756c44696f646573  
              0a0a00            
     8                          
     9  04ff  00                ALIGN 0x10
    10                          
    11                          bad_cmd_msg:
    12  0500  436f6d6d616e6420                  db "Command not recognised\n",0
              6e6f74207265636f  
              676e697365640a00  
    13                          
    14  0518  0000000000000000  ALIGN 0x10
    15                          
    16                          cmd_w_null_msg:
    17  0520  4e6f206461746120                  db "No data to write\n",0
              746f207772697465  
              0a00              
    18                          
beanzee.asm:
    18                          
